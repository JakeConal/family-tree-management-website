
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model TreeOwner
 * 
 */
export type TreeOwner = $Result.DefaultSelection<Prisma.$TreeOwnerPayload>
/**
 * Model FamilyTree
 * 
 */
export type FamilyTree = $Result.DefaultSelection<Prisma.$FamilyTreePayload>
/**
 * Model FamilyMember
 * 
 */
export type FamilyMember = $Result.DefaultSelection<Prisma.$FamilyMemberPayload>
/**
 * Model Occupation
 * 
 */
export type Occupation = $Result.DefaultSelection<Prisma.$OccupationPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model AchievementType
 * 
 */
export type AchievementType = $Result.DefaultSelection<Prisma.$AchievementTypePayload>
/**
 * Model PassingRecord
 * 
 */
export type PassingRecord = $Result.DefaultSelection<Prisma.$PassingRecordPayload>
/**
 * Model CauseOfDeath
 * 
 */
export type CauseOfDeath = $Result.DefaultSelection<Prisma.$CauseOfDeathPayload>
/**
 * Model BuriedPlace
 * 
 */
export type BuriedPlace = $Result.DefaultSelection<Prisma.$BuriedPlacePayload>
/**
 * Model PlaceOfOrigin
 * 
 */
export type PlaceOfOrigin = $Result.DefaultSelection<Prisma.$PlaceOfOriginPayload>
/**
 * Model FamilyMember_has_PlaceOfOrigin
 * 
 */
export type FamilyMember_has_PlaceOfOrigin = $Result.DefaultSelection<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
/**
 * Model SpouseRelationship
 * 
 */
export type SpouseRelationship = $Result.DefaultSelection<Prisma.$SpouseRelationshipPayload>
/**
 * Model GuestEditor
 * 
 */
export type GuestEditor = $Result.DefaultSelection<Prisma.$GuestEditorPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  LOCAL: 'LOCAL',
  GOOGLE: 'GOOGLE'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more TreeOwners
 * const treeOwners = await prisma.treeOwner.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more TreeOwners
   * const treeOwners = await prisma.treeOwner.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.treeOwner`: Exposes CRUD operations for the **TreeOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreeOwners
    * const treeOwners = await prisma.treeOwner.findMany()
    * ```
    */
  get treeOwner(): Prisma.TreeOwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyTree`: Exposes CRUD operations for the **FamilyTree** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyTrees
    * const familyTrees = await prisma.familyTree.findMany()
    * ```
    */
  get familyTree(): Prisma.FamilyTreeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMember`: Exposes CRUD operations for the **FamilyMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMembers
    * const familyMembers = await prisma.familyMember.findMany()
    * ```
    */
  get familyMember(): Prisma.FamilyMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.occupation`: Exposes CRUD operations for the **Occupation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occupations
    * const occupations = await prisma.occupation.findMany()
    * ```
    */
  get occupation(): Prisma.OccupationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievementType`: Exposes CRUD operations for the **AchievementType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AchievementTypes
    * const achievementTypes = await prisma.achievementType.findMany()
    * ```
    */
  get achievementType(): Prisma.AchievementTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passingRecord`: Exposes CRUD operations for the **PassingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PassingRecords
    * const passingRecords = await prisma.passingRecord.findMany()
    * ```
    */
  get passingRecord(): Prisma.PassingRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.causeOfDeath`: Exposes CRUD operations for the **CauseOfDeath** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CauseOfDeaths
    * const causeOfDeaths = await prisma.causeOfDeath.findMany()
    * ```
    */
  get causeOfDeath(): Prisma.CauseOfDeathDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buriedPlace`: Exposes CRUD operations for the **BuriedPlace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuriedPlaces
    * const buriedPlaces = await prisma.buriedPlace.findMany()
    * ```
    */
  get buriedPlace(): Prisma.BuriedPlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.placeOfOrigin`: Exposes CRUD operations for the **PlaceOfOrigin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlaceOfOrigins
    * const placeOfOrigins = await prisma.placeOfOrigin.findMany()
    * ```
    */
  get placeOfOrigin(): Prisma.PlaceOfOriginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMember_has_PlaceOfOrigin`: Exposes CRUD operations for the **FamilyMember_has_PlaceOfOrigin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMember_has_PlaceOfOrigins
    * const familyMember_has_PlaceOfOrigins = await prisma.familyMember_has_PlaceOfOrigin.findMany()
    * ```
    */
  get familyMember_has_PlaceOfOrigin(): Prisma.FamilyMember_has_PlaceOfOriginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spouseRelationship`: Exposes CRUD operations for the **SpouseRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpouseRelationships
    * const spouseRelationships = await prisma.spouseRelationship.findMany()
    * ```
    */
  get spouseRelationship(): Prisma.SpouseRelationshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guestEditor`: Exposes CRUD operations for the **GuestEditor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestEditors
    * const guestEditors = await prisma.guestEditor.findMany()
    * ```
    */
  get guestEditor(): Prisma.GuestEditorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    TreeOwner: 'TreeOwner',
    FamilyTree: 'FamilyTree',
    FamilyMember: 'FamilyMember',
    Occupation: 'Occupation',
    Achievement: 'Achievement',
    AchievementType: 'AchievementType',
    PassingRecord: 'PassingRecord',
    CauseOfDeath: 'CauseOfDeath',
    BuriedPlace: 'BuriedPlace',
    PlaceOfOrigin: 'PlaceOfOrigin',
    FamilyMember_has_PlaceOfOrigin: 'FamilyMember_has_PlaceOfOrigin',
    SpouseRelationship: 'SpouseRelationship',
    GuestEditor: 'GuestEditor',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "treeOwner" | "familyTree" | "familyMember" | "occupation" | "achievement" | "achievementType" | "passingRecord" | "causeOfDeath" | "buriedPlace" | "placeOfOrigin" | "familyMember_has_PlaceOfOrigin" | "spouseRelationship" | "guestEditor" | "user" | "account" | "session" | "verificationToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      TreeOwner: {
        payload: Prisma.$TreeOwnerPayload<ExtArgs>
        fields: Prisma.TreeOwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreeOwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreeOwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          findFirst: {
            args: Prisma.TreeOwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreeOwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          findMany: {
            args: Prisma.TreeOwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>[]
          }
          create: {
            args: Prisma.TreeOwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          createMany: {
            args: Prisma.TreeOwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TreeOwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          update: {
            args: Prisma.TreeOwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          deleteMany: {
            args: Prisma.TreeOwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreeOwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreeOwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreeOwnerPayload>
          }
          aggregate: {
            args: Prisma.TreeOwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreeOwner>
          }
          groupBy: {
            args: Prisma.TreeOwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreeOwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreeOwnerCountArgs<ExtArgs>
            result: $Utils.Optional<TreeOwnerCountAggregateOutputType> | number
          }
        }
      }
      FamilyTree: {
        payload: Prisma.$FamilyTreePayload<ExtArgs>
        fields: Prisma.FamilyTreeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyTreeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyTreeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          findFirst: {
            args: Prisma.FamilyTreeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyTreeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          findMany: {
            args: Prisma.FamilyTreeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>[]
          }
          create: {
            args: Prisma.FamilyTreeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          createMany: {
            args: Prisma.FamilyTreeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyTreeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          update: {
            args: Prisma.FamilyTreeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          deleteMany: {
            args: Prisma.FamilyTreeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyTreeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyTreeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyTreePayload>
          }
          aggregate: {
            args: Prisma.FamilyTreeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyTree>
          }
          groupBy: {
            args: Prisma.FamilyTreeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyTreeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyTreeCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyTreeCountAggregateOutputType> | number
          }
        }
      }
      FamilyMember: {
        payload: Prisma.$FamilyMemberPayload<ExtArgs>
        fields: Prisma.FamilyMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findFirst: {
            args: Prisma.FamilyMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findMany: {
            args: Prisma.FamilyMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          create: {
            args: Prisma.FamilyMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          createMany: {
            args: Prisma.FamilyMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          update: {
            args: Prisma.FamilyMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          aggregate: {
            args: Prisma.FamilyMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMember>
          }
          groupBy: {
            args: Prisma.FamilyMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMemberCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberCountAggregateOutputType> | number
          }
        }
      }
      Occupation: {
        payload: Prisma.$OccupationPayload<ExtArgs>
        fields: Prisma.OccupationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccupationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccupationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          findFirst: {
            args: Prisma.OccupationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccupationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          findMany: {
            args: Prisma.OccupationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>[]
          }
          create: {
            args: Prisma.OccupationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          createMany: {
            args: Prisma.OccupationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OccupationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          update: {
            args: Prisma.OccupationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          deleteMany: {
            args: Prisma.OccupationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OccupationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OccupationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OccupationPayload>
          }
          aggregate: {
            args: Prisma.OccupationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccupation>
          }
          groupBy: {
            args: Prisma.OccupationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccupationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccupationCountArgs<ExtArgs>
            result: $Utils.Optional<OccupationCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      AchievementType: {
        payload: Prisma.$AchievementTypePayload<ExtArgs>
        fields: Prisma.AchievementTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          findFirst: {
            args: Prisma.AchievementTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          findMany: {
            args: Prisma.AchievementTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>[]
          }
          create: {
            args: Prisma.AchievementTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          createMany: {
            args: Prisma.AchievementTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AchievementTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          update: {
            args: Prisma.AchievementTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          deleteMany: {
            args: Prisma.AchievementTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementTypePayload>
          }
          aggregate: {
            args: Prisma.AchievementTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievementType>
          }
          groupBy: {
            args: Prisma.AchievementTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementTypeCountAggregateOutputType> | number
          }
        }
      }
      PassingRecord: {
        payload: Prisma.$PassingRecordPayload<ExtArgs>
        fields: Prisma.PassingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          findFirst: {
            args: Prisma.PassingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          findMany: {
            args: Prisma.PassingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>[]
          }
          create: {
            args: Prisma.PassingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          createMany: {
            args: Prisma.PassingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PassingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          update: {
            args: Prisma.PassingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          deleteMany: {
            args: Prisma.PassingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PassingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassingRecordPayload>
          }
          aggregate: {
            args: Prisma.PassingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassingRecord>
          }
          groupBy: {
            args: Prisma.PassingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<PassingRecordCountAggregateOutputType> | number
          }
        }
      }
      CauseOfDeath: {
        payload: Prisma.$CauseOfDeathPayload<ExtArgs>
        fields: Prisma.CauseOfDeathFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CauseOfDeathFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CauseOfDeathFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          findFirst: {
            args: Prisma.CauseOfDeathFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CauseOfDeathFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          findMany: {
            args: Prisma.CauseOfDeathFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>[]
          }
          create: {
            args: Prisma.CauseOfDeathCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          createMany: {
            args: Prisma.CauseOfDeathCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CauseOfDeathDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          update: {
            args: Prisma.CauseOfDeathUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          deleteMany: {
            args: Prisma.CauseOfDeathDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CauseOfDeathUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CauseOfDeathUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CauseOfDeathPayload>
          }
          aggregate: {
            args: Prisma.CauseOfDeathAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCauseOfDeath>
          }
          groupBy: {
            args: Prisma.CauseOfDeathGroupByArgs<ExtArgs>
            result: $Utils.Optional<CauseOfDeathGroupByOutputType>[]
          }
          count: {
            args: Prisma.CauseOfDeathCountArgs<ExtArgs>
            result: $Utils.Optional<CauseOfDeathCountAggregateOutputType> | number
          }
        }
      }
      BuriedPlace: {
        payload: Prisma.$BuriedPlacePayload<ExtArgs>
        fields: Prisma.BuriedPlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuriedPlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuriedPlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          findFirst: {
            args: Prisma.BuriedPlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuriedPlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          findMany: {
            args: Prisma.BuriedPlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>[]
          }
          create: {
            args: Prisma.BuriedPlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          createMany: {
            args: Prisma.BuriedPlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuriedPlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          update: {
            args: Prisma.BuriedPlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          deleteMany: {
            args: Prisma.BuriedPlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuriedPlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuriedPlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuriedPlacePayload>
          }
          aggregate: {
            args: Prisma.BuriedPlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuriedPlace>
          }
          groupBy: {
            args: Prisma.BuriedPlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuriedPlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuriedPlaceCountArgs<ExtArgs>
            result: $Utils.Optional<BuriedPlaceCountAggregateOutputType> | number
          }
        }
      }
      PlaceOfOrigin: {
        payload: Prisma.$PlaceOfOriginPayload<ExtArgs>
        fields: Prisma.PlaceOfOriginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceOfOriginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          findFirst: {
            args: Prisma.PlaceOfOriginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceOfOriginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          findMany: {
            args: Prisma.PlaceOfOriginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>[]
          }
          create: {
            args: Prisma.PlaceOfOriginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          createMany: {
            args: Prisma.PlaceOfOriginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlaceOfOriginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          update: {
            args: Prisma.PlaceOfOriginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          deleteMany: {
            args: Prisma.PlaceOfOriginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceOfOriginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaceOfOriginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaceOfOriginPayload>
          }
          aggregate: {
            args: Prisma.PlaceOfOriginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaceOfOrigin>
          }
          groupBy: {
            args: Prisma.PlaceOfOriginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceOfOriginGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceOfOriginCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceOfOriginCountAggregateOutputType> | number
          }
        }
      }
      FamilyMember_has_PlaceOfOrigin: {
        payload: Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>
        fields: Prisma.FamilyMember_has_PlaceOfOriginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMember_has_PlaceOfOriginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMember_has_PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          findFirst: {
            args: Prisma.FamilyMember_has_PlaceOfOriginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMember_has_PlaceOfOriginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          findMany: {
            args: Prisma.FamilyMember_has_PlaceOfOriginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>[]
          }
          create: {
            args: Prisma.FamilyMember_has_PlaceOfOriginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          createMany: {
            args: Prisma.FamilyMember_has_PlaceOfOriginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyMember_has_PlaceOfOriginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          update: {
            args: Prisma.FamilyMember_has_PlaceOfOriginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMember_has_PlaceOfOriginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMember_has_PlaceOfOriginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyMember_has_PlaceOfOriginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload>
          }
          aggregate: {
            args: Prisma.FamilyMember_has_PlaceOfOriginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMember_has_PlaceOfOrigin>
          }
          groupBy: {
            args: Prisma.FamilyMember_has_PlaceOfOriginGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMember_has_PlaceOfOriginGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMember_has_PlaceOfOriginCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMember_has_PlaceOfOriginCountAggregateOutputType> | number
          }
        }
      }
      SpouseRelationship: {
        payload: Prisma.$SpouseRelationshipPayload<ExtArgs>
        fields: Prisma.SpouseRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpouseRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpouseRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          findFirst: {
            args: Prisma.SpouseRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpouseRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          findMany: {
            args: Prisma.SpouseRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>[]
          }
          create: {
            args: Prisma.SpouseRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          createMany: {
            args: Prisma.SpouseRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SpouseRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          update: {
            args: Prisma.SpouseRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.SpouseRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpouseRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpouseRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpouseRelationshipPayload>
          }
          aggregate: {
            args: Prisma.SpouseRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpouseRelationship>
          }
          groupBy: {
            args: Prisma.SpouseRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpouseRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpouseRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<SpouseRelationshipCountAggregateOutputType> | number
          }
        }
      }
      GuestEditor: {
        payload: Prisma.$GuestEditorPayload<ExtArgs>
        fields: Prisma.GuestEditorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GuestEditorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GuestEditorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          findFirst: {
            args: Prisma.GuestEditorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GuestEditorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          findMany: {
            args: Prisma.GuestEditorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>[]
          }
          create: {
            args: Prisma.GuestEditorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          createMany: {
            args: Prisma.GuestEditorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GuestEditorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          update: {
            args: Prisma.GuestEditorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          deleteMany: {
            args: Prisma.GuestEditorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GuestEditorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GuestEditorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GuestEditorPayload>
          }
          aggregate: {
            args: Prisma.GuestEditorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuestEditor>
          }
          groupBy: {
            args: Prisma.GuestEditorGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestEditorGroupByOutputType>[]
          }
          count: {
            args: Prisma.GuestEditorCountArgs<ExtArgs>
            result: $Utils.Optional<GuestEditorCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    treeOwner?: TreeOwnerOmit
    familyTree?: FamilyTreeOmit
    familyMember?: FamilyMemberOmit
    occupation?: OccupationOmit
    achievement?: AchievementOmit
    achievementType?: AchievementTypeOmit
    passingRecord?: PassingRecordOmit
    causeOfDeath?: CauseOfDeathOmit
    buriedPlace?: BuriedPlaceOmit
    placeOfOrigin?: PlaceOfOriginOmit
    familyMember_has_PlaceOfOrigin?: FamilyMember_has_PlaceOfOriginOmit
    spouseRelationship?: SpouseRelationshipOmit
    guestEditor?: GuestEditorOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TreeOwnerCountOutputType
   */

  export type TreeOwnerCountOutputType = {
    familyTrees: number
  }

  export type TreeOwnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyTrees?: boolean | TreeOwnerCountOutputTypeCountFamilyTreesArgs
  }

  // Custom InputTypes
  /**
   * TreeOwnerCountOutputType without action
   */
  export type TreeOwnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwnerCountOutputType
     */
    select?: TreeOwnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TreeOwnerCountOutputType without action
   */
  export type TreeOwnerCountOutputTypeCountFamilyTreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyTreeWhereInput
  }


  /**
   * Count Type FamilyTreeCountOutputType
   */

  export type FamilyTreeCountOutputType = {
    familyMembers: number
    guestEditors: number
    achievementTypes: number
  }

  export type FamilyTreeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMembers?: boolean | FamilyTreeCountOutputTypeCountFamilyMembersArgs
    guestEditors?: boolean | FamilyTreeCountOutputTypeCountGuestEditorsArgs
    achievementTypes?: boolean | FamilyTreeCountOutputTypeCountAchievementTypesArgs
  }

  // Custom InputTypes
  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTreeCountOutputType
     */
    select?: FamilyTreeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeCountFamilyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeCountGuestEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestEditorWhereInput
  }

  /**
   * FamilyTreeCountOutputType without action
   */
  export type FamilyTreeCountOutputTypeCountAchievementTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementTypeWhereInput
  }


  /**
   * Count Type FamilyMemberCountOutputType
   */

  export type FamilyMemberCountOutputType = {
    children: number
    achievements: number
    passingRecords: number
    causesOfDeath: number
    occupations: number
    birthPlaces: number
    spouse1: number
    spouse2: number
    guestEditors: number
  }

  export type FamilyMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FamilyMemberCountOutputTypeCountChildrenArgs
    achievements?: boolean | FamilyMemberCountOutputTypeCountAchievementsArgs
    passingRecords?: boolean | FamilyMemberCountOutputTypeCountPassingRecordsArgs
    causesOfDeath?: boolean | FamilyMemberCountOutputTypeCountCausesOfDeathArgs
    occupations?: boolean | FamilyMemberCountOutputTypeCountOccupationsArgs
    birthPlaces?: boolean | FamilyMemberCountOutputTypeCountBirthPlacesArgs
    spouse1?: boolean | FamilyMemberCountOutputTypeCountSpouse1Args
    spouse2?: boolean | FamilyMemberCountOutputTypeCountSpouse2Args
    guestEditors?: boolean | FamilyMemberCountOutputTypeCountGuestEditorsArgs
  }

  // Custom InputTypes
  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMemberCountOutputType
     */
    select?: FamilyMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountPassingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassingRecordWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountCausesOfDeathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CauseOfDeathWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountOccupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupationWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountBirthPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMember_has_PlaceOfOriginWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountSpouse1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpouseRelationshipWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountSpouse2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpouseRelationshipWhereInput
  }

  /**
   * FamilyMemberCountOutputType without action
   */
  export type FamilyMemberCountOutputTypeCountGuestEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestEditorWhereInput
  }


  /**
   * Count Type AchievementTypeCountOutputType
   */

  export type AchievementTypeCountOutputType = {
    achievements: number
  }

  export type AchievementTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    achievements?: boolean | AchievementTypeCountOutputTypeCountAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementTypeCountOutputType without action
   */
  export type AchievementTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementTypeCountOutputType
     */
    select?: AchievementTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementTypeCountOutputType without action
   */
  export type AchievementTypeCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }


  /**
   * Count Type PassingRecordCountOutputType
   */

  export type PassingRecordCountOutputType = {
    buriedPlaces: number
  }

  export type PassingRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    buriedPlaces?: boolean | PassingRecordCountOutputTypeCountBuriedPlacesArgs
  }

  // Custom InputTypes
  /**
   * PassingRecordCountOutputType without action
   */
  export type PassingRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecordCountOutputType
     */
    select?: PassingRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PassingRecordCountOutputType without action
   */
  export type PassingRecordCountOutputTypeCountBuriedPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuriedPlaceWhereInput
  }


  /**
   * Count Type PlaceOfOriginCountOutputType
   */

  export type PlaceOfOriginCountOutputType = {
    familyMembers: number
  }

  export type PlaceOfOriginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMembers?: boolean | PlaceOfOriginCountOutputTypeCountFamilyMembersArgs
  }

  // Custom InputTypes
  /**
   * PlaceOfOriginCountOutputType without action
   */
  export type PlaceOfOriginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOriginCountOutputType
     */
    select?: PlaceOfOriginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaceOfOriginCountOutputType without action
   */
  export type PlaceOfOriginCountOutputTypeCountFamilyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMember_has_PlaceOfOriginWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model TreeOwner
   */

  export type AggregateTreeOwner = {
    _count: TreeOwnerCountAggregateOutputType | null
    _avg: TreeOwnerAvgAggregateOutputType | null
    _sum: TreeOwnerSumAggregateOutputType | null
    _min: TreeOwnerMinAggregateOutputType | null
    _max: TreeOwnerMaxAggregateOutputType | null
  }

  export type TreeOwnerAvgAggregateOutputType = {
    id: number | null
  }

  export type TreeOwnerSumAggregateOutputType = {
    id: number | null
  }

  export type TreeOwnerMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TreeOwnerMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type TreeOwnerCountAggregateOutputType = {
    id: number
    fullName: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type TreeOwnerAvgAggregateInputType = {
    id?: true
  }

  export type TreeOwnerSumAggregateInputType = {
    id?: true
  }

  export type TreeOwnerMinAggregateInputType = {
    id?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TreeOwnerMaxAggregateInputType = {
    id?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type TreeOwnerCountAggregateInputType = {
    id?: true
    fullName?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type TreeOwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreeOwner to aggregate.
     */
    where?: TreeOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreeOwners to fetch.
     */
    orderBy?: TreeOwnerOrderByWithRelationInput | TreeOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreeOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreeOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreeOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreeOwners
    **/
    _count?: true | TreeOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreeOwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreeOwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreeOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreeOwnerMaxAggregateInputType
  }

  export type GetTreeOwnerAggregateType<T extends TreeOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateTreeOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreeOwner[P]>
      : GetScalarType<T[P], AggregateTreeOwner[P]>
  }




  export type TreeOwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreeOwnerWhereInput
    orderBy?: TreeOwnerOrderByWithAggregationInput | TreeOwnerOrderByWithAggregationInput[]
    by: TreeOwnerScalarFieldEnum[] | TreeOwnerScalarFieldEnum
    having?: TreeOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreeOwnerCountAggregateInputType | true
    _avg?: TreeOwnerAvgAggregateInputType
    _sum?: TreeOwnerSumAggregateInputType
    _min?: TreeOwnerMinAggregateInputType
    _max?: TreeOwnerMaxAggregateInputType
  }

  export type TreeOwnerGroupByOutputType = {
    id: number
    fullName: string
    createdAt: Date
    updatedAt: Date | null
    userId: string | null
    _count: TreeOwnerCountAggregateOutputType | null
    _avg: TreeOwnerAvgAggregateOutputType | null
    _sum: TreeOwnerSumAggregateOutputType | null
    _min: TreeOwnerMinAggregateOutputType | null
    _max: TreeOwnerMaxAggregateOutputType | null
  }

  type GetTreeOwnerGroupByPayload<T extends TreeOwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreeOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreeOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreeOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], TreeOwnerGroupByOutputType[P]>
        }
      >
    >


  export type TreeOwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    user?: boolean | TreeOwner$userArgs<ExtArgs>
    familyTrees?: boolean | TreeOwner$familyTreesArgs<ExtArgs>
    _count?: boolean | TreeOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treeOwner"]>



  export type TreeOwnerSelectScalar = {
    id?: boolean
    fullName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type TreeOwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["treeOwner"]>
  export type TreeOwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | TreeOwner$userArgs<ExtArgs>
    familyTrees?: boolean | TreeOwner$familyTreesArgs<ExtArgs>
    _count?: boolean | TreeOwnerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TreeOwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreeOwner"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      familyTrees: Prisma.$FamilyTreePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      createdAt: Date
      updatedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["treeOwner"]>
    composites: {}
  }

  type TreeOwnerGetPayload<S extends boolean | null | undefined | TreeOwnerDefaultArgs> = $Result.GetResult<Prisma.$TreeOwnerPayload, S>

  type TreeOwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TreeOwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreeOwnerCountAggregateInputType | true
    }

  export interface TreeOwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreeOwner'], meta: { name: 'TreeOwner' } }
    /**
     * Find zero or one TreeOwner that matches the filter.
     * @param {TreeOwnerFindUniqueArgs} args - Arguments to find a TreeOwner
     * @example
     * // Get one TreeOwner
     * const treeOwner = await prisma.treeOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreeOwnerFindUniqueArgs>(args: SelectSubset<T, TreeOwnerFindUniqueArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TreeOwner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreeOwnerFindUniqueOrThrowArgs} args - Arguments to find a TreeOwner
     * @example
     * // Get one TreeOwner
     * const treeOwner = await prisma.treeOwner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreeOwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, TreeOwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreeOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerFindFirstArgs} args - Arguments to find a TreeOwner
     * @example
     * // Get one TreeOwner
     * const treeOwner = await prisma.treeOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreeOwnerFindFirstArgs>(args?: SelectSubset<T, TreeOwnerFindFirstArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreeOwner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerFindFirstOrThrowArgs} args - Arguments to find a TreeOwner
     * @example
     * // Get one TreeOwner
     * const treeOwner = await prisma.treeOwner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreeOwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, TreeOwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TreeOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreeOwners
     * const treeOwners = await prisma.treeOwner.findMany()
     * 
     * // Get first 10 TreeOwners
     * const treeOwners = await prisma.treeOwner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treeOwnerWithIdOnly = await prisma.treeOwner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreeOwnerFindManyArgs>(args?: SelectSubset<T, TreeOwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TreeOwner.
     * @param {TreeOwnerCreateArgs} args - Arguments to create a TreeOwner.
     * @example
     * // Create one TreeOwner
     * const TreeOwner = await prisma.treeOwner.create({
     *   data: {
     *     // ... data to create a TreeOwner
     *   }
     * })
     * 
     */
    create<T extends TreeOwnerCreateArgs>(args: SelectSubset<T, TreeOwnerCreateArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TreeOwners.
     * @param {TreeOwnerCreateManyArgs} args - Arguments to create many TreeOwners.
     * @example
     * // Create many TreeOwners
     * const treeOwner = await prisma.treeOwner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreeOwnerCreateManyArgs>(args?: SelectSubset<T, TreeOwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TreeOwner.
     * @param {TreeOwnerDeleteArgs} args - Arguments to delete one TreeOwner.
     * @example
     * // Delete one TreeOwner
     * const TreeOwner = await prisma.treeOwner.delete({
     *   where: {
     *     // ... filter to delete one TreeOwner
     *   }
     * })
     * 
     */
    delete<T extends TreeOwnerDeleteArgs>(args: SelectSubset<T, TreeOwnerDeleteArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TreeOwner.
     * @param {TreeOwnerUpdateArgs} args - Arguments to update one TreeOwner.
     * @example
     * // Update one TreeOwner
     * const treeOwner = await prisma.treeOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreeOwnerUpdateArgs>(args: SelectSubset<T, TreeOwnerUpdateArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TreeOwners.
     * @param {TreeOwnerDeleteManyArgs} args - Arguments to filter TreeOwners to delete.
     * @example
     * // Delete a few TreeOwners
     * const { count } = await prisma.treeOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreeOwnerDeleteManyArgs>(args?: SelectSubset<T, TreeOwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreeOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreeOwners
     * const treeOwner = await prisma.treeOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreeOwnerUpdateManyArgs>(args: SelectSubset<T, TreeOwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TreeOwner.
     * @param {TreeOwnerUpsertArgs} args - Arguments to update or create a TreeOwner.
     * @example
     * // Update or create a TreeOwner
     * const treeOwner = await prisma.treeOwner.upsert({
     *   create: {
     *     // ... data to create a TreeOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreeOwner we want to update
     *   }
     * })
     */
    upsert<T extends TreeOwnerUpsertArgs>(args: SelectSubset<T, TreeOwnerUpsertArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TreeOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerCountArgs} args - Arguments to filter TreeOwners to count.
     * @example
     * // Count the number of TreeOwners
     * const count = await prisma.treeOwner.count({
     *   where: {
     *     // ... the filter for the TreeOwners we want to count
     *   }
     * })
    **/
    count<T extends TreeOwnerCountArgs>(
      args?: Subset<T, TreeOwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreeOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreeOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreeOwnerAggregateArgs>(args: Subset<T, TreeOwnerAggregateArgs>): Prisma.PrismaPromise<GetTreeOwnerAggregateType<T>>

    /**
     * Group by TreeOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreeOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreeOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreeOwnerGroupByArgs['orderBy'] }
        : { orderBy?: TreeOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreeOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreeOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreeOwner model
   */
  readonly fields: TreeOwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreeOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreeOwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends TreeOwner$userArgs<ExtArgs> = {}>(args?: Subset<T, TreeOwner$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    familyTrees<T extends TreeOwner$familyTreesArgs<ExtArgs> = {}>(args?: Subset<T, TreeOwner$familyTreesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreeOwner model
   */
  interface TreeOwnerFieldRefs {
    readonly id: FieldRef<"TreeOwner", 'Int'>
    readonly fullName: FieldRef<"TreeOwner", 'String'>
    readonly createdAt: FieldRef<"TreeOwner", 'DateTime'>
    readonly updatedAt: FieldRef<"TreeOwner", 'DateTime'>
    readonly userId: FieldRef<"TreeOwner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TreeOwner findUnique
   */
  export type TreeOwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter, which TreeOwner to fetch.
     */
    where: TreeOwnerWhereUniqueInput
  }

  /**
   * TreeOwner findUniqueOrThrow
   */
  export type TreeOwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter, which TreeOwner to fetch.
     */
    where: TreeOwnerWhereUniqueInput
  }

  /**
   * TreeOwner findFirst
   */
  export type TreeOwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter, which TreeOwner to fetch.
     */
    where?: TreeOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreeOwners to fetch.
     */
    orderBy?: TreeOwnerOrderByWithRelationInput | TreeOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreeOwners.
     */
    cursor?: TreeOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreeOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreeOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreeOwners.
     */
    distinct?: TreeOwnerScalarFieldEnum | TreeOwnerScalarFieldEnum[]
  }

  /**
   * TreeOwner findFirstOrThrow
   */
  export type TreeOwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter, which TreeOwner to fetch.
     */
    where?: TreeOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreeOwners to fetch.
     */
    orderBy?: TreeOwnerOrderByWithRelationInput | TreeOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreeOwners.
     */
    cursor?: TreeOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreeOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreeOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreeOwners.
     */
    distinct?: TreeOwnerScalarFieldEnum | TreeOwnerScalarFieldEnum[]
  }

  /**
   * TreeOwner findMany
   */
  export type TreeOwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter, which TreeOwners to fetch.
     */
    where?: TreeOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreeOwners to fetch.
     */
    orderBy?: TreeOwnerOrderByWithRelationInput | TreeOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreeOwners.
     */
    cursor?: TreeOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreeOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreeOwners.
     */
    skip?: number
    distinct?: TreeOwnerScalarFieldEnum | TreeOwnerScalarFieldEnum[]
  }

  /**
   * TreeOwner create
   */
  export type TreeOwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a TreeOwner.
     */
    data: XOR<TreeOwnerCreateInput, TreeOwnerUncheckedCreateInput>
  }

  /**
   * TreeOwner createMany
   */
  export type TreeOwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreeOwners.
     */
    data: TreeOwnerCreateManyInput | TreeOwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TreeOwner update
   */
  export type TreeOwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a TreeOwner.
     */
    data: XOR<TreeOwnerUpdateInput, TreeOwnerUncheckedUpdateInput>
    /**
     * Choose, which TreeOwner to update.
     */
    where: TreeOwnerWhereUniqueInput
  }

  /**
   * TreeOwner updateMany
   */
  export type TreeOwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreeOwners.
     */
    data: XOR<TreeOwnerUpdateManyMutationInput, TreeOwnerUncheckedUpdateManyInput>
    /**
     * Filter which TreeOwners to update
     */
    where?: TreeOwnerWhereInput
    /**
     * Limit how many TreeOwners to update.
     */
    limit?: number
  }

  /**
   * TreeOwner upsert
   */
  export type TreeOwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the TreeOwner to update in case it exists.
     */
    where: TreeOwnerWhereUniqueInput
    /**
     * In case the TreeOwner found by the `where` argument doesn't exist, create a new TreeOwner with this data.
     */
    create: XOR<TreeOwnerCreateInput, TreeOwnerUncheckedCreateInput>
    /**
     * In case the TreeOwner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreeOwnerUpdateInput, TreeOwnerUncheckedUpdateInput>
  }

  /**
   * TreeOwner delete
   */
  export type TreeOwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    /**
     * Filter which TreeOwner to delete.
     */
    where: TreeOwnerWhereUniqueInput
  }

  /**
   * TreeOwner deleteMany
   */
  export type TreeOwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreeOwners to delete
     */
    where?: TreeOwnerWhereInput
    /**
     * Limit how many TreeOwners to delete.
     */
    limit?: number
  }

  /**
   * TreeOwner.user
   */
  export type TreeOwner$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TreeOwner.familyTrees
   */
  export type TreeOwner$familyTreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    where?: FamilyTreeWhereInput
    orderBy?: FamilyTreeOrderByWithRelationInput | FamilyTreeOrderByWithRelationInput[]
    cursor?: FamilyTreeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyTreeScalarFieldEnum | FamilyTreeScalarFieldEnum[]
  }

  /**
   * TreeOwner without action
   */
  export type TreeOwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
  }


  /**
   * Model FamilyTree
   */

  export type AggregateFamilyTree = {
    _count: FamilyTreeCountAggregateOutputType | null
    _avg: FamilyTreeAvgAggregateOutputType | null
    _sum: FamilyTreeSumAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  export type FamilyTreeAvgAggregateOutputType = {
    id: number | null
    establishYear: number | null
    treeOwnerId: number | null
    rootMemberId: number | null
  }

  export type FamilyTreeSumAggregateOutputType = {
    id: number | null
    establishYear: number | null
    treeOwnerId: number | null
    rootMemberId: number | null
  }

  export type FamilyTreeMinAggregateOutputType = {
    id: number | null
    familyName: string | null
    origin: string | null
    establishYear: number | null
    createdAt: Date | null
    treeOwnerId: number | null
    rootMemberId: number | null
  }

  export type FamilyTreeMaxAggregateOutputType = {
    id: number | null
    familyName: string | null
    origin: string | null
    establishYear: number | null
    createdAt: Date | null
    treeOwnerId: number | null
    rootMemberId: number | null
  }

  export type FamilyTreeCountAggregateOutputType = {
    id: number
    familyName: number
    origin: number
    establishYear: number
    createdAt: number
    treeOwnerId: number
    rootMemberId: number
    _all: number
  }


  export type FamilyTreeAvgAggregateInputType = {
    id?: true
    establishYear?: true
    treeOwnerId?: true
    rootMemberId?: true
  }

  export type FamilyTreeSumAggregateInputType = {
    id?: true
    establishYear?: true
    treeOwnerId?: true
    rootMemberId?: true
  }

  export type FamilyTreeMinAggregateInputType = {
    id?: true
    familyName?: true
    origin?: true
    establishYear?: true
    createdAt?: true
    treeOwnerId?: true
    rootMemberId?: true
  }

  export type FamilyTreeMaxAggregateInputType = {
    id?: true
    familyName?: true
    origin?: true
    establishYear?: true
    createdAt?: true
    treeOwnerId?: true
    rootMemberId?: true
  }

  export type FamilyTreeCountAggregateInputType = {
    id?: true
    familyName?: true
    origin?: true
    establishYear?: true
    createdAt?: true
    treeOwnerId?: true
    rootMemberId?: true
    _all?: true
  }

  export type FamilyTreeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyTree to aggregate.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: FamilyTreeOrderByWithRelationInput | FamilyTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyTrees
    **/
    _count?: true | FamilyTreeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyTreeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyTreeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyTreeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyTreeMaxAggregateInputType
  }

  export type GetFamilyTreeAggregateType<T extends FamilyTreeAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyTree]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyTree[P]>
      : GetScalarType<T[P], AggregateFamilyTree[P]>
  }




  export type FamilyTreeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyTreeWhereInput
    orderBy?: FamilyTreeOrderByWithAggregationInput | FamilyTreeOrderByWithAggregationInput[]
    by: FamilyTreeScalarFieldEnum[] | FamilyTreeScalarFieldEnum
    having?: FamilyTreeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyTreeCountAggregateInputType | true
    _avg?: FamilyTreeAvgAggregateInputType
    _sum?: FamilyTreeSumAggregateInputType
    _min?: FamilyTreeMinAggregateInputType
    _max?: FamilyTreeMaxAggregateInputType
  }

  export type FamilyTreeGroupByOutputType = {
    id: number
    familyName: string
    origin: string | null
    establishYear: number | null
    createdAt: Date
    treeOwnerId: number
    rootMemberId: number | null
    _count: FamilyTreeCountAggregateOutputType | null
    _avg: FamilyTreeAvgAggregateOutputType | null
    _sum: FamilyTreeSumAggregateOutputType | null
    _min: FamilyTreeMinAggregateOutputType | null
    _max: FamilyTreeMaxAggregateOutputType | null
  }

  type GetFamilyTreeGroupByPayload<T extends FamilyTreeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyTreeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyTreeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyTreeGroupByOutputType[P]>
        }
      >
    >


  export type FamilyTreeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    familyName?: boolean
    origin?: boolean
    establishYear?: boolean
    createdAt?: boolean
    treeOwnerId?: boolean
    rootMemberId?: boolean
    treeOwner?: boolean | TreeOwnerDefaultArgs<ExtArgs>
    rootMember?: boolean | FamilyTree$rootMemberArgs<ExtArgs>
    familyMembers?: boolean | FamilyTree$familyMembersArgs<ExtArgs>
    guestEditors?: boolean | FamilyTree$guestEditorsArgs<ExtArgs>
    achievementTypes?: boolean | FamilyTree$achievementTypesArgs<ExtArgs>
    _count?: boolean | FamilyTreeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyTree"]>



  export type FamilyTreeSelectScalar = {
    id?: boolean
    familyName?: boolean
    origin?: boolean
    establishYear?: boolean
    createdAt?: boolean
    treeOwnerId?: boolean
    rootMemberId?: boolean
  }

  export type FamilyTreeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "familyName" | "origin" | "establishYear" | "createdAt" | "treeOwnerId" | "rootMemberId", ExtArgs["result"]["familyTree"]>
  export type FamilyTreeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treeOwner?: boolean | TreeOwnerDefaultArgs<ExtArgs>
    rootMember?: boolean | FamilyTree$rootMemberArgs<ExtArgs>
    familyMembers?: boolean | FamilyTree$familyMembersArgs<ExtArgs>
    guestEditors?: boolean | FamilyTree$guestEditorsArgs<ExtArgs>
    achievementTypes?: boolean | FamilyTree$achievementTypesArgs<ExtArgs>
    _count?: boolean | FamilyTreeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FamilyTreePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyTree"
    objects: {
      treeOwner: Prisma.$TreeOwnerPayload<ExtArgs>
      rootMember: Prisma.$FamilyMemberPayload<ExtArgs> | null
      familyMembers: Prisma.$FamilyMemberPayload<ExtArgs>[]
      guestEditors: Prisma.$GuestEditorPayload<ExtArgs>[]
      achievementTypes: Prisma.$AchievementTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      familyName: string
      origin: string | null
      establishYear: number | null
      createdAt: Date
      treeOwnerId: number
      rootMemberId: number | null
    }, ExtArgs["result"]["familyTree"]>
    composites: {}
  }

  type FamilyTreeGetPayload<S extends boolean | null | undefined | FamilyTreeDefaultArgs> = $Result.GetResult<Prisma.$FamilyTreePayload, S>

  type FamilyTreeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyTreeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyTreeCountAggregateInputType | true
    }

  export interface FamilyTreeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyTree'], meta: { name: 'FamilyTree' } }
    /**
     * Find zero or one FamilyTree that matches the filter.
     * @param {FamilyTreeFindUniqueArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyTreeFindUniqueArgs>(args: SelectSubset<T, FamilyTreeFindUniqueArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyTree that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyTreeFindUniqueOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyTreeFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyTreeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyTree that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyTreeFindFirstArgs>(args?: SelectSubset<T, FamilyTreeFindFirstArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyTree that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindFirstOrThrowArgs} args - Arguments to find a FamilyTree
     * @example
     * // Get one FamilyTree
     * const familyTree = await prisma.familyTree.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyTreeFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyTreeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyTrees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany()
     * 
     * // Get first 10 FamilyTrees
     * const familyTrees = await prisma.familyTree.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyTreeWithIdOnly = await prisma.familyTree.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyTreeFindManyArgs>(args?: SelectSubset<T, FamilyTreeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyTree.
     * @param {FamilyTreeCreateArgs} args - Arguments to create a FamilyTree.
     * @example
     * // Create one FamilyTree
     * const FamilyTree = await prisma.familyTree.create({
     *   data: {
     *     // ... data to create a FamilyTree
     *   }
     * })
     * 
     */
    create<T extends FamilyTreeCreateArgs>(args: SelectSubset<T, FamilyTreeCreateArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyTrees.
     * @param {FamilyTreeCreateManyArgs} args - Arguments to create many FamilyTrees.
     * @example
     * // Create many FamilyTrees
     * const familyTree = await prisma.familyTree.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyTreeCreateManyArgs>(args?: SelectSubset<T, FamilyTreeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyTree.
     * @param {FamilyTreeDeleteArgs} args - Arguments to delete one FamilyTree.
     * @example
     * // Delete one FamilyTree
     * const FamilyTree = await prisma.familyTree.delete({
     *   where: {
     *     // ... filter to delete one FamilyTree
     *   }
     * })
     * 
     */
    delete<T extends FamilyTreeDeleteArgs>(args: SelectSubset<T, FamilyTreeDeleteArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyTree.
     * @param {FamilyTreeUpdateArgs} args - Arguments to update one FamilyTree.
     * @example
     * // Update one FamilyTree
     * const familyTree = await prisma.familyTree.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyTreeUpdateArgs>(args: SelectSubset<T, FamilyTreeUpdateArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyTrees.
     * @param {FamilyTreeDeleteManyArgs} args - Arguments to filter FamilyTrees to delete.
     * @example
     * // Delete a few FamilyTrees
     * const { count } = await prisma.familyTree.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyTreeDeleteManyArgs>(args?: SelectSubset<T, FamilyTreeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyTrees
     * const familyTree = await prisma.familyTree.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyTreeUpdateManyArgs>(args: SelectSubset<T, FamilyTreeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyTree.
     * @param {FamilyTreeUpsertArgs} args - Arguments to update or create a FamilyTree.
     * @example
     * // Update or create a FamilyTree
     * const familyTree = await prisma.familyTree.upsert({
     *   create: {
     *     // ... data to create a FamilyTree
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyTree we want to update
     *   }
     * })
     */
    upsert<T extends FamilyTreeUpsertArgs>(args: SelectSubset<T, FamilyTreeUpsertArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyTrees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeCountArgs} args - Arguments to filter FamilyTrees to count.
     * @example
     * // Count the number of FamilyTrees
     * const count = await prisma.familyTree.count({
     *   where: {
     *     // ... the filter for the FamilyTrees we want to count
     *   }
     * })
    **/
    count<T extends FamilyTreeCountArgs>(
      args?: Subset<T, FamilyTreeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyTreeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyTreeAggregateArgs>(args: Subset<T, FamilyTreeAggregateArgs>): Prisma.PrismaPromise<GetFamilyTreeAggregateType<T>>

    /**
     * Group by FamilyTree.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyTreeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyTreeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyTreeGroupByArgs['orderBy'] }
        : { orderBy?: FamilyTreeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyTreeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyTreeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyTree model
   */
  readonly fields: FamilyTreeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyTree.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyTreeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    treeOwner<T extends TreeOwnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TreeOwnerDefaultArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rootMember<T extends FamilyTree$rootMemberArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTree$rootMemberArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    familyMembers<T extends FamilyTree$familyMembersArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTree$familyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guestEditors<T extends FamilyTree$guestEditorsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTree$guestEditorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievementTypes<T extends FamilyTree$achievementTypesArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTree$achievementTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyTree model
   */
  interface FamilyTreeFieldRefs {
    readonly id: FieldRef<"FamilyTree", 'Int'>
    readonly familyName: FieldRef<"FamilyTree", 'String'>
    readonly origin: FieldRef<"FamilyTree", 'String'>
    readonly establishYear: FieldRef<"FamilyTree", 'Int'>
    readonly createdAt: FieldRef<"FamilyTree", 'DateTime'>
    readonly treeOwnerId: FieldRef<"FamilyTree", 'Int'>
    readonly rootMemberId: FieldRef<"FamilyTree", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FamilyTree findUnique
   */
  export type FamilyTreeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree findUniqueOrThrow
   */
  export type FamilyTreeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree findFirst
   */
  export type FamilyTreeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: FamilyTreeOrderByWithRelationInput | FamilyTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: FamilyTreeScalarFieldEnum | FamilyTreeScalarFieldEnum[]
  }

  /**
   * FamilyTree findFirstOrThrow
   */
  export type FamilyTreeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter, which FamilyTree to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: FamilyTreeOrderByWithRelationInput | FamilyTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyTrees.
     */
    distinct?: FamilyTreeScalarFieldEnum | FamilyTreeScalarFieldEnum[]
  }

  /**
   * FamilyTree findMany
   */
  export type FamilyTreeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter, which FamilyTrees to fetch.
     */
    where?: FamilyTreeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyTrees to fetch.
     */
    orderBy?: FamilyTreeOrderByWithRelationInput | FamilyTreeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyTrees.
     */
    cursor?: FamilyTreeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyTrees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyTrees.
     */
    skip?: number
    distinct?: FamilyTreeScalarFieldEnum | FamilyTreeScalarFieldEnum[]
  }

  /**
   * FamilyTree create
   */
  export type FamilyTreeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyTree.
     */
    data: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
  }

  /**
   * FamilyTree createMany
   */
  export type FamilyTreeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyTrees.
     */
    data: FamilyTreeCreateManyInput | FamilyTreeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyTree update
   */
  export type FamilyTreeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyTree.
     */
    data: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
    /**
     * Choose, which FamilyTree to update.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree updateMany
   */
  export type FamilyTreeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyTrees.
     */
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyInput>
    /**
     * Filter which FamilyTrees to update
     */
    where?: FamilyTreeWhereInput
    /**
     * Limit how many FamilyTrees to update.
     */
    limit?: number
  }

  /**
   * FamilyTree upsert
   */
  export type FamilyTreeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyTree to update in case it exists.
     */
    where: FamilyTreeWhereUniqueInput
    /**
     * In case the FamilyTree found by the `where` argument doesn't exist, create a new FamilyTree with this data.
     */
    create: XOR<FamilyTreeCreateInput, FamilyTreeUncheckedCreateInput>
    /**
     * In case the FamilyTree was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyTreeUpdateInput, FamilyTreeUncheckedUpdateInput>
  }

  /**
   * FamilyTree delete
   */
  export type FamilyTreeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    /**
     * Filter which FamilyTree to delete.
     */
    where: FamilyTreeWhereUniqueInput
  }

  /**
   * FamilyTree deleteMany
   */
  export type FamilyTreeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyTrees to delete
     */
    where?: FamilyTreeWhereInput
    /**
     * Limit how many FamilyTrees to delete.
     */
    limit?: number
  }

  /**
   * FamilyTree.rootMember
   */
  export type FamilyTree$rootMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyTree.familyMembers
   */
  export type FamilyTree$familyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyTree.guestEditors
   */
  export type FamilyTree$guestEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    where?: GuestEditorWhereInput
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    cursor?: GuestEditorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestEditorScalarFieldEnum | GuestEditorScalarFieldEnum[]
  }

  /**
   * FamilyTree.achievementTypes
   */
  export type FamilyTree$achievementTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    where?: AchievementTypeWhereInput
    orderBy?: AchievementTypeOrderByWithRelationInput | AchievementTypeOrderByWithRelationInput[]
    cursor?: AchievementTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementTypeScalarFieldEnum | AchievementTypeScalarFieldEnum[]
  }

  /**
   * FamilyTree without action
   */
  export type FamilyTreeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMember
   */

  export type AggregateFamilyMember = {
    _count: FamilyMemberCountAggregateOutputType | null
    _avg: FamilyMemberAvgAggregateOutputType | null
    _sum: FamilyMemberSumAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  export type FamilyMemberAvgAggregateOutputType = {
    id: number | null
    familyTreeId: number | null
    parentId: number | null
  }

  export type FamilyMemberSumAggregateOutputType = {
    id: number | null
    familyTreeId: number | null
    parentId: number | null
  }

  export type FamilyMemberMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    gender: $Enums.Gender | null
    birthday: Date | null
    address: string | null
    profilePicture: string | null
    generation: string | null
    isRootPerson: boolean | null
    isAdopted: boolean | null
    familyTreeId: number | null
    parentId: number | null
  }

  export type FamilyMemberMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    gender: $Enums.Gender | null
    birthday: Date | null
    address: string | null
    profilePicture: string | null
    generation: string | null
    isRootPerson: boolean | null
    isAdopted: boolean | null
    familyTreeId: number | null
    parentId: number | null
  }

  export type FamilyMemberCountAggregateOutputType = {
    id: number
    fullName: number
    gender: number
    birthday: number
    address: number
    profilePicture: number
    generation: number
    isRootPerson: number
    isAdopted: number
    familyTreeId: number
    parentId: number
    _all: number
  }


  export type FamilyMemberAvgAggregateInputType = {
    id?: true
    familyTreeId?: true
    parentId?: true
  }

  export type FamilyMemberSumAggregateInputType = {
    id?: true
    familyTreeId?: true
    parentId?: true
  }

  export type FamilyMemberMinAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    birthday?: true
    address?: true
    profilePicture?: true
    generation?: true
    isRootPerson?: true
    isAdopted?: true
    familyTreeId?: true
    parentId?: true
  }

  export type FamilyMemberMaxAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    birthday?: true
    address?: true
    profilePicture?: true
    generation?: true
    isRootPerson?: true
    isAdopted?: true
    familyTreeId?: true
    parentId?: true
  }

  export type FamilyMemberCountAggregateInputType = {
    id?: true
    fullName?: true
    gender?: true
    birthday?: true
    address?: true
    profilePicture?: true
    generation?: true
    isRootPerson?: true
    isAdopted?: true
    familyTreeId?: true
    parentId?: true
    _all?: true
  }

  export type FamilyMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember to aggregate.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMembers
    **/
    _count?: true | FamilyMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type GetFamilyMemberAggregateType<T extends FamilyMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMember[P]>
      : GetScalarType<T[P], AggregateFamilyMember[P]>
  }




  export type FamilyMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithAggregationInput | FamilyMemberOrderByWithAggregationInput[]
    by: FamilyMemberScalarFieldEnum[] | FamilyMemberScalarFieldEnum
    having?: FamilyMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMemberCountAggregateInputType | true
    _avg?: FamilyMemberAvgAggregateInputType
    _sum?: FamilyMemberSumAggregateInputType
    _min?: FamilyMemberMinAggregateInputType
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type FamilyMemberGroupByOutputType = {
    id: number
    fullName: string
    gender: $Enums.Gender | null
    birthday: Date | null
    address: string | null
    profilePicture: string | null
    generation: string | null
    isRootPerson: boolean | null
    isAdopted: boolean | null
    familyTreeId: number
    parentId: number | null
    _count: FamilyMemberCountAggregateOutputType | null
    _avg: FamilyMemberAvgAggregateOutputType | null
    _sum: FamilyMemberSumAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  type GetFamilyMemberGroupByPayload<T extends FamilyMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    gender?: boolean
    birthday?: boolean
    address?: boolean
    profilePicture?: boolean
    generation?: boolean
    isRootPerson?: boolean
    isAdopted?: boolean
    familyTreeId?: boolean
    parentId?: boolean
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
    parent?: boolean | FamilyMember$parentArgs<ExtArgs>
    children?: boolean | FamilyMember$childrenArgs<ExtArgs>
    achievements?: boolean | FamilyMember$achievementsArgs<ExtArgs>
    passingRecords?: boolean | FamilyMember$passingRecordsArgs<ExtArgs>
    causesOfDeath?: boolean | FamilyMember$causesOfDeathArgs<ExtArgs>
    occupations?: boolean | FamilyMember$occupationsArgs<ExtArgs>
    birthPlaces?: boolean | FamilyMember$birthPlacesArgs<ExtArgs>
    spouse1?: boolean | FamilyMember$spouse1Args<ExtArgs>
    spouse2?: boolean | FamilyMember$spouse2Args<ExtArgs>
    guestEditors?: boolean | FamilyMember$guestEditorsArgs<ExtArgs>
    rootFor?: boolean | FamilyMember$rootForArgs<ExtArgs>
    _count?: boolean | FamilyMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>



  export type FamilyMemberSelectScalar = {
    id?: boolean
    fullName?: boolean
    gender?: boolean
    birthday?: boolean
    address?: boolean
    profilePicture?: boolean
    generation?: boolean
    isRootPerson?: boolean
    isAdopted?: boolean
    familyTreeId?: boolean
    parentId?: boolean
  }

  export type FamilyMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "gender" | "birthday" | "address" | "profilePicture" | "generation" | "isRootPerson" | "isAdopted" | "familyTreeId" | "parentId", ExtArgs["result"]["familyMember"]>
  export type FamilyMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
    parent?: boolean | FamilyMember$parentArgs<ExtArgs>
    children?: boolean | FamilyMember$childrenArgs<ExtArgs>
    achievements?: boolean | FamilyMember$achievementsArgs<ExtArgs>
    passingRecords?: boolean | FamilyMember$passingRecordsArgs<ExtArgs>
    causesOfDeath?: boolean | FamilyMember$causesOfDeathArgs<ExtArgs>
    occupations?: boolean | FamilyMember$occupationsArgs<ExtArgs>
    birthPlaces?: boolean | FamilyMember$birthPlacesArgs<ExtArgs>
    spouse1?: boolean | FamilyMember$spouse1Args<ExtArgs>
    spouse2?: boolean | FamilyMember$spouse2Args<ExtArgs>
    guestEditors?: boolean | FamilyMember$guestEditorsArgs<ExtArgs>
    rootFor?: boolean | FamilyMember$rootForArgs<ExtArgs>
    _count?: boolean | FamilyMemberCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FamilyMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMember"
    objects: {
      familyTree: Prisma.$FamilyTreePayload<ExtArgs>
      parent: Prisma.$FamilyMemberPayload<ExtArgs> | null
      children: Prisma.$FamilyMemberPayload<ExtArgs>[]
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      passingRecords: Prisma.$PassingRecordPayload<ExtArgs>[]
      causesOfDeath: Prisma.$CauseOfDeathPayload<ExtArgs>[]
      occupations: Prisma.$OccupationPayload<ExtArgs>[]
      birthPlaces: Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>[]
      spouse1: Prisma.$SpouseRelationshipPayload<ExtArgs>[]
      spouse2: Prisma.$SpouseRelationshipPayload<ExtArgs>[]
      guestEditors: Prisma.$GuestEditorPayload<ExtArgs>[]
      rootFor: Prisma.$FamilyTreePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      gender: $Enums.Gender | null
      birthday: Date | null
      address: string | null
      profilePicture: string | null
      generation: string | null
      isRootPerson: boolean | null
      isAdopted: boolean | null
      familyTreeId: number
      parentId: number | null
    }, ExtArgs["result"]["familyMember"]>
    composites: {}
  }

  type FamilyMemberGetPayload<S extends boolean | null | undefined | FamilyMemberDefaultArgs> = $Result.GetResult<Prisma.$FamilyMemberPayload, S>

  type FamilyMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMemberCountAggregateInputType | true
    }

  export interface FamilyMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMember'], meta: { name: 'FamilyMember' } }
    /**
     * Find zero or one FamilyMember that matches the filter.
     * @param {FamilyMemberFindUniqueArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMemberFindUniqueArgs>(args: SelectSubset<T, FamilyMemberFindUniqueArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMemberFindUniqueOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMemberFindFirstArgs>(args?: SelectSubset<T, FamilyMemberFindFirstArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany()
     * 
     * // Get first 10 FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMemberFindManyArgs>(args?: SelectSubset<T, FamilyMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMember.
     * @param {FamilyMemberCreateArgs} args - Arguments to create a FamilyMember.
     * @example
     * // Create one FamilyMember
     * const FamilyMember = await prisma.familyMember.create({
     *   data: {
     *     // ... data to create a FamilyMember
     *   }
     * })
     * 
     */
    create<T extends FamilyMemberCreateArgs>(args: SelectSubset<T, FamilyMemberCreateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMembers.
     * @param {FamilyMemberCreateManyArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMemberCreateManyArgs>(args?: SelectSubset<T, FamilyMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyMember.
     * @param {FamilyMemberDeleteArgs} args - Arguments to delete one FamilyMember.
     * @example
     * // Delete one FamilyMember
     * const FamilyMember = await prisma.familyMember.delete({
     *   where: {
     *     // ... filter to delete one FamilyMember
     *   }
     * })
     * 
     */
    delete<T extends FamilyMemberDeleteArgs>(args: SelectSubset<T, FamilyMemberDeleteArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMember.
     * @param {FamilyMemberUpdateArgs} args - Arguments to update one FamilyMember.
     * @example
     * // Update one FamilyMember
     * const familyMember = await prisma.familyMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMemberUpdateArgs>(args: SelectSubset<T, FamilyMemberUpdateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMembers.
     * @param {FamilyMemberDeleteManyArgs} args - Arguments to filter FamilyMembers to delete.
     * @example
     * // Delete a few FamilyMembers
     * const { count } = await prisma.familyMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMemberDeleteManyArgs>(args?: SelectSubset<T, FamilyMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMembers
     * const familyMember = await prisma.familyMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMemberUpdateManyArgs>(args: SelectSubset<T, FamilyMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyMember.
     * @param {FamilyMemberUpsertArgs} args - Arguments to update or create a FamilyMember.
     * @example
     * // Update or create a FamilyMember
     * const familyMember = await prisma.familyMember.upsert({
     *   create: {
     *     // ... data to create a FamilyMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMember we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMemberUpsertArgs>(args: SelectSubset<T, FamilyMemberUpsertArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberCountArgs} args - Arguments to filter FamilyMembers to count.
     * @example
     * // Count the number of FamilyMembers
     * const count = await prisma.familyMember.count({
     *   where: {
     *     // ... the filter for the FamilyMembers we want to count
     *   }
     * })
    **/
    count<T extends FamilyMemberCountArgs>(
      args?: Subset<T, FamilyMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMemberAggregateArgs>(args: Subset<T, FamilyMemberAggregateArgs>): Prisma.PrismaPromise<GetFamilyMemberAggregateType<T>>

    /**
     * Group by FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMemberGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMember model
   */
  readonly fields: FamilyMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyTree<T extends FamilyTreeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTreeDefaultArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends FamilyMember$parentArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$parentArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends FamilyMember$childrenArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achievements<T extends FamilyMember$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passingRecords<T extends FamilyMember$passingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$passingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    causesOfDeath<T extends FamilyMember$causesOfDeathArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$causesOfDeathArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    occupations<T extends FamilyMember$occupationsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$occupationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    birthPlaces<T extends FamilyMember$birthPlacesArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$birthPlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spouse1<T extends FamilyMember$spouse1Args<ExtArgs> = {}>(args?: Subset<T, FamilyMember$spouse1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    spouse2<T extends FamilyMember$spouse2Args<ExtArgs> = {}>(args?: Subset<T, FamilyMember$spouse2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guestEditors<T extends FamilyMember$guestEditorsArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$guestEditorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rootFor<T extends FamilyMember$rootForArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$rootForArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMember model
   */
  interface FamilyMemberFieldRefs {
    readonly id: FieldRef<"FamilyMember", 'Int'>
    readonly fullName: FieldRef<"FamilyMember", 'String'>
    readonly gender: FieldRef<"FamilyMember", 'Gender'>
    readonly birthday: FieldRef<"FamilyMember", 'DateTime'>
    readonly address: FieldRef<"FamilyMember", 'String'>
    readonly profilePicture: FieldRef<"FamilyMember", 'String'>
    readonly generation: FieldRef<"FamilyMember", 'String'>
    readonly isRootPerson: FieldRef<"FamilyMember", 'Boolean'>
    readonly isAdopted: FieldRef<"FamilyMember", 'Boolean'>
    readonly familyTreeId: FieldRef<"FamilyMember", 'Int'>
    readonly parentId: FieldRef<"FamilyMember", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMember findUnique
   */
  export type FamilyMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findUniqueOrThrow
   */
  export type FamilyMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findFirst
   */
  export type FamilyMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findFirstOrThrow
   */
  export type FamilyMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findMany
   */
  export type FamilyMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembers to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember create
   */
  export type FamilyMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMember.
     */
    data: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
  }

  /**
   * FamilyMember createMany
   */
  export type FamilyMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMember update
   */
  export type FamilyMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMember.
     */
    data: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
    /**
     * Choose, which FamilyMember to update.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember updateMany
   */
  export type FamilyMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMembers.
     */
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMembers to update
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to update.
     */
    limit?: number
  }

  /**
   * FamilyMember upsert
   */
  export type FamilyMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMember to update in case it exists.
     */
    where: FamilyMemberWhereUniqueInput
    /**
     * In case the FamilyMember found by the `where` argument doesn't exist, create a new FamilyMember with this data.
     */
    create: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
    /**
     * In case the FamilyMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
  }

  /**
   * FamilyMember delete
   */
  export type FamilyMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter which FamilyMember to delete.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember deleteMany
   */
  export type FamilyMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMembers to delete
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to delete.
     */
    limit?: number
  }

  /**
   * FamilyMember.parent
   */
  export type FamilyMember$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
  }

  /**
   * FamilyMember.children
   */
  export type FamilyMember$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember.achievements
   */
  export type FamilyMember$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * FamilyMember.passingRecords
   */
  export type FamilyMember$passingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    where?: PassingRecordWhereInput
    orderBy?: PassingRecordOrderByWithRelationInput | PassingRecordOrderByWithRelationInput[]
    cursor?: PassingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassingRecordScalarFieldEnum | PassingRecordScalarFieldEnum[]
  }

  /**
   * FamilyMember.causesOfDeath
   */
  export type FamilyMember$causesOfDeathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    where?: CauseOfDeathWhereInput
    orderBy?: CauseOfDeathOrderByWithRelationInput | CauseOfDeathOrderByWithRelationInput[]
    cursor?: CauseOfDeathWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CauseOfDeathScalarFieldEnum | CauseOfDeathScalarFieldEnum[]
  }

  /**
   * FamilyMember.occupations
   */
  export type FamilyMember$occupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    where?: OccupationWhereInput
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    cursor?: OccupationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * FamilyMember.birthPlaces
   */
  export type FamilyMember$birthPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMember_has_PlaceOfOriginScalarFieldEnum | FamilyMember_has_PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * FamilyMember.spouse1
   */
  export type FamilyMember$spouse1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    where?: SpouseRelationshipWhereInput
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    cursor?: SpouseRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpouseRelationshipScalarFieldEnum | SpouseRelationshipScalarFieldEnum[]
  }

  /**
   * FamilyMember.spouse2
   */
  export type FamilyMember$spouse2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    where?: SpouseRelationshipWhereInput
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    cursor?: SpouseRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpouseRelationshipScalarFieldEnum | SpouseRelationshipScalarFieldEnum[]
  }

  /**
   * FamilyMember.guestEditors
   */
  export type FamilyMember$guestEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    where?: GuestEditorWhereInput
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    cursor?: GuestEditorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GuestEditorScalarFieldEnum | GuestEditorScalarFieldEnum[]
  }

  /**
   * FamilyMember.rootFor
   */
  export type FamilyMember$rootForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyTree
     */
    select?: FamilyTreeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyTree
     */
    omit?: FamilyTreeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyTreeInclude<ExtArgs> | null
    where?: FamilyTreeWhereInput
  }

  /**
   * FamilyMember without action
   */
  export type FamilyMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
  }


  /**
   * Model Occupation
   */

  export type AggregateOccupation = {
    _count: OccupationCountAggregateOutputType | null
    _avg: OccupationAvgAggregateOutputType | null
    _sum: OccupationSumAggregateOutputType | null
    _min: OccupationMinAggregateOutputType | null
    _max: OccupationMaxAggregateOutputType | null
  }

  export type OccupationAvgAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
  }

  export type OccupationSumAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
  }

  export type OccupationMinAggregateOutputType = {
    id: number | null
    jobTitle: string | null
    startDate: Date | null
    endDate: Date | null
    familyMemberId: number | null
  }

  export type OccupationMaxAggregateOutputType = {
    id: number | null
    jobTitle: string | null
    startDate: Date | null
    endDate: Date | null
    familyMemberId: number | null
  }

  export type OccupationCountAggregateOutputType = {
    id: number
    jobTitle: number
    startDate: number
    endDate: number
    familyMemberId: number
    _all: number
  }


  export type OccupationAvgAggregateInputType = {
    id?: true
    familyMemberId?: true
  }

  export type OccupationSumAggregateInputType = {
    id?: true
    familyMemberId?: true
  }

  export type OccupationMinAggregateInputType = {
    id?: true
    jobTitle?: true
    startDate?: true
    endDate?: true
    familyMemberId?: true
  }

  export type OccupationMaxAggregateInputType = {
    id?: true
    jobTitle?: true
    startDate?: true
    endDate?: true
    familyMemberId?: true
  }

  export type OccupationCountAggregateInputType = {
    id?: true
    jobTitle?: true
    startDate?: true
    endDate?: true
    familyMemberId?: true
    _all?: true
  }

  export type OccupationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occupation to aggregate.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Occupations
    **/
    _count?: true | OccupationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OccupationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OccupationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccupationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccupationMaxAggregateInputType
  }

  export type GetOccupationAggregateType<T extends OccupationAggregateArgs> = {
        [P in keyof T & keyof AggregateOccupation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccupation[P]>
      : GetScalarType<T[P], AggregateOccupation[P]>
  }




  export type OccupationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccupationWhereInput
    orderBy?: OccupationOrderByWithAggregationInput | OccupationOrderByWithAggregationInput[]
    by: OccupationScalarFieldEnum[] | OccupationScalarFieldEnum
    having?: OccupationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccupationCountAggregateInputType | true
    _avg?: OccupationAvgAggregateInputType
    _sum?: OccupationSumAggregateInputType
    _min?: OccupationMinAggregateInputType
    _max?: OccupationMaxAggregateInputType
  }

  export type OccupationGroupByOutputType = {
    id: number
    jobTitle: string
    startDate: Date | null
    endDate: Date | null
    familyMemberId: number
    _count: OccupationCountAggregateOutputType | null
    _avg: OccupationAvgAggregateOutputType | null
    _sum: OccupationSumAggregateOutputType | null
    _min: OccupationMinAggregateOutputType | null
    _max: OccupationMaxAggregateOutputType | null
  }

  type GetOccupationGroupByPayload<T extends OccupationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccupationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccupationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccupationGroupByOutputType[P]>
            : GetScalarType<T[P], OccupationGroupByOutputType[P]>
        }
      >
    >


  export type OccupationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobTitle?: boolean
    startDate?: boolean
    endDate?: boolean
    familyMemberId?: boolean
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupation"]>



  export type OccupationSelectScalar = {
    id?: boolean
    jobTitle?: boolean
    startDate?: boolean
    endDate?: boolean
    familyMemberId?: boolean
  }

  export type OccupationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobTitle" | "startDate" | "endDate" | "familyMemberId", ExtArgs["result"]["occupation"]>
  export type OccupationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }

  export type $OccupationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Occupation"
    objects: {
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobTitle: string
      startDate: Date | null
      endDate: Date | null
      familyMemberId: number
    }, ExtArgs["result"]["occupation"]>
    composites: {}
  }

  type OccupationGetPayload<S extends boolean | null | undefined | OccupationDefaultArgs> = $Result.GetResult<Prisma.$OccupationPayload, S>

  type OccupationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OccupationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OccupationCountAggregateInputType | true
    }

  export interface OccupationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Occupation'], meta: { name: 'Occupation' } }
    /**
     * Find zero or one Occupation that matches the filter.
     * @param {OccupationFindUniqueArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OccupationFindUniqueArgs>(args: SelectSubset<T, OccupationFindUniqueArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Occupation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OccupationFindUniqueOrThrowArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OccupationFindUniqueOrThrowArgs>(args: SelectSubset<T, OccupationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindFirstArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OccupationFindFirstArgs>(args?: SelectSubset<T, OccupationFindFirstArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindFirstOrThrowArgs} args - Arguments to find a Occupation
     * @example
     * // Get one Occupation
     * const occupation = await prisma.occupation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OccupationFindFirstOrThrowArgs>(args?: SelectSubset<T, OccupationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Occupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Occupations
     * const occupations = await prisma.occupation.findMany()
     * 
     * // Get first 10 Occupations
     * const occupations = await prisma.occupation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const occupationWithIdOnly = await prisma.occupation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OccupationFindManyArgs>(args?: SelectSubset<T, OccupationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Occupation.
     * @param {OccupationCreateArgs} args - Arguments to create a Occupation.
     * @example
     * // Create one Occupation
     * const Occupation = await prisma.occupation.create({
     *   data: {
     *     // ... data to create a Occupation
     *   }
     * })
     * 
     */
    create<T extends OccupationCreateArgs>(args: SelectSubset<T, OccupationCreateArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Occupations.
     * @param {OccupationCreateManyArgs} args - Arguments to create many Occupations.
     * @example
     * // Create many Occupations
     * const occupation = await prisma.occupation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OccupationCreateManyArgs>(args?: SelectSubset<T, OccupationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Occupation.
     * @param {OccupationDeleteArgs} args - Arguments to delete one Occupation.
     * @example
     * // Delete one Occupation
     * const Occupation = await prisma.occupation.delete({
     *   where: {
     *     // ... filter to delete one Occupation
     *   }
     * })
     * 
     */
    delete<T extends OccupationDeleteArgs>(args: SelectSubset<T, OccupationDeleteArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Occupation.
     * @param {OccupationUpdateArgs} args - Arguments to update one Occupation.
     * @example
     * // Update one Occupation
     * const occupation = await prisma.occupation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OccupationUpdateArgs>(args: SelectSubset<T, OccupationUpdateArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Occupations.
     * @param {OccupationDeleteManyArgs} args - Arguments to filter Occupations to delete.
     * @example
     * // Delete a few Occupations
     * const { count } = await prisma.occupation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OccupationDeleteManyArgs>(args?: SelectSubset<T, OccupationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Occupations
     * const occupation = await prisma.occupation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OccupationUpdateManyArgs>(args: SelectSubset<T, OccupationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Occupation.
     * @param {OccupationUpsertArgs} args - Arguments to update or create a Occupation.
     * @example
     * // Update or create a Occupation
     * const occupation = await prisma.occupation.upsert({
     *   create: {
     *     // ... data to create a Occupation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Occupation we want to update
     *   }
     * })
     */
    upsert<T extends OccupationUpsertArgs>(args: SelectSubset<T, OccupationUpsertArgs<ExtArgs>>): Prisma__OccupationClient<$Result.GetResult<Prisma.$OccupationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationCountArgs} args - Arguments to filter Occupations to count.
     * @example
     * // Count the number of Occupations
     * const count = await prisma.occupation.count({
     *   where: {
     *     // ... the filter for the Occupations we want to count
     *   }
     * })
    **/
    count<T extends OccupationCountArgs>(
      args?: Subset<T, OccupationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccupationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Occupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccupationAggregateArgs>(args: Subset<T, OccupationAggregateArgs>): Prisma.PrismaPromise<GetOccupationAggregateType<T>>

    /**
     * Group by Occupation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccupationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccupationGroupByArgs['orderBy'] }
        : { orderBy?: OccupationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccupationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccupationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Occupation model
   */
  readonly fields: OccupationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Occupation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccupationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Occupation model
   */
  interface OccupationFieldRefs {
    readonly id: FieldRef<"Occupation", 'Int'>
    readonly jobTitle: FieldRef<"Occupation", 'String'>
    readonly startDate: FieldRef<"Occupation", 'DateTime'>
    readonly endDate: FieldRef<"Occupation", 'DateTime'>
    readonly familyMemberId: FieldRef<"Occupation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Occupation findUnique
   */
  export type OccupationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation findUniqueOrThrow
   */
  export type OccupationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation findFirst
   */
  export type OccupationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occupations.
     */
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation findFirstOrThrow
   */
  export type OccupationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupation to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occupations.
     */
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation findMany
   */
  export type OccupationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter, which Occupations to fetch.
     */
    where?: OccupationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occupations to fetch.
     */
    orderBy?: OccupationOrderByWithRelationInput | OccupationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Occupations.
     */
    cursor?: OccupationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occupations.
     */
    skip?: number
    distinct?: OccupationScalarFieldEnum | OccupationScalarFieldEnum[]
  }

  /**
   * Occupation create
   */
  export type OccupationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The data needed to create a Occupation.
     */
    data: XOR<OccupationCreateInput, OccupationUncheckedCreateInput>
  }

  /**
   * Occupation createMany
   */
  export type OccupationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Occupations.
     */
    data: OccupationCreateManyInput | OccupationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Occupation update
   */
  export type OccupationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The data needed to update a Occupation.
     */
    data: XOR<OccupationUpdateInput, OccupationUncheckedUpdateInput>
    /**
     * Choose, which Occupation to update.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation updateMany
   */
  export type OccupationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Occupations.
     */
    data: XOR<OccupationUpdateManyMutationInput, OccupationUncheckedUpdateManyInput>
    /**
     * Filter which Occupations to update
     */
    where?: OccupationWhereInput
    /**
     * Limit how many Occupations to update.
     */
    limit?: number
  }

  /**
   * Occupation upsert
   */
  export type OccupationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * The filter to search for the Occupation to update in case it exists.
     */
    where: OccupationWhereUniqueInput
    /**
     * In case the Occupation found by the `where` argument doesn't exist, create a new Occupation with this data.
     */
    create: XOR<OccupationCreateInput, OccupationUncheckedCreateInput>
    /**
     * In case the Occupation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccupationUpdateInput, OccupationUncheckedUpdateInput>
  }

  /**
   * Occupation delete
   */
  export type OccupationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
    /**
     * Filter which Occupation to delete.
     */
    where: OccupationWhereUniqueInput
  }

  /**
   * Occupation deleteMany
   */
  export type OccupationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occupations to delete
     */
    where?: OccupationWhereInput
    /**
     * Limit how many Occupations to delete.
     */
    limit?: number
  }

  /**
   * Occupation without action
   */
  export type OccupationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occupation
     */
    select?: OccupationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Occupation
     */
    omit?: OccupationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccupationInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
    achievementTypeId: number | null
  }

  export type AchievementSumAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
    achievementTypeId: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: number | null
    title: string | null
    achieveDate: Date | null
    description: string | null
    familyMemberId: number | null
    achievementTypeId: number | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: number | null
    title: string | null
    achieveDate: Date | null
    description: string | null
    familyMemberId: number | null
    achievementTypeId: number | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    achieveDate: number
    description: number
    familyMemberId: number
    achievementTypeId: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    id?: true
    familyMemberId?: true
    achievementTypeId?: true
  }

  export type AchievementSumAggregateInputType = {
    id?: true
    familyMemberId?: true
    achievementTypeId?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    achieveDate?: true
    description?: true
    familyMemberId?: true
    achievementTypeId?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    achieveDate?: true
    description?: true
    familyMemberId?: true
    achievementTypeId?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    achieveDate?: true
    description?: true
    familyMemberId?: true
    achievementTypeId?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: number
    title: string
    achieveDate: Date | null
    description: string | null
    familyMemberId: number
    achievementTypeId: number
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    achieveDate?: boolean
    description?: boolean
    familyMemberId?: boolean
    achievementTypeId?: boolean
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    achievementType?: boolean | AchievementTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>



  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    achieveDate?: boolean
    description?: boolean
    familyMemberId?: boolean
    achievementTypeId?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "achieveDate" | "description" | "familyMemberId" | "achievementTypeId", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    achievementType?: boolean | AchievementTypeDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
      achievementType: Prisma.$AchievementTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      achieveDate: Date | null
      description: string | null
      familyMemberId: number
      achievementTypeId: number
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievementType<T extends AchievementTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementTypeDefaultArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'Int'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly achieveDate: FieldRef<"Achievement", 'DateTime'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly familyMemberId: FieldRef<"Achievement", 'Int'>
    readonly achievementTypeId: FieldRef<"Achievement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model AchievementType
   */

  export type AggregateAchievementType = {
    _count: AchievementTypeCountAggregateOutputType | null
    _avg: AchievementTypeAvgAggregateOutputType | null
    _sum: AchievementTypeSumAggregateOutputType | null
    _min: AchievementTypeMinAggregateOutputType | null
    _max: AchievementTypeMaxAggregateOutputType | null
  }

  export type AchievementTypeAvgAggregateOutputType = {
    id: number | null
    familyTreeId: number | null
  }

  export type AchievementTypeSumAggregateOutputType = {
    id: number | null
    familyTreeId: number | null
  }

  export type AchievementTypeMinAggregateOutputType = {
    id: number | null
    typeName: string | null
    familyTreeId: number | null
  }

  export type AchievementTypeMaxAggregateOutputType = {
    id: number | null
    typeName: string | null
    familyTreeId: number | null
  }

  export type AchievementTypeCountAggregateOutputType = {
    id: number
    typeName: number
    familyTreeId: number
    _all: number
  }


  export type AchievementTypeAvgAggregateInputType = {
    id?: true
    familyTreeId?: true
  }

  export type AchievementTypeSumAggregateInputType = {
    id?: true
    familyTreeId?: true
  }

  export type AchievementTypeMinAggregateInputType = {
    id?: true
    typeName?: true
    familyTreeId?: true
  }

  export type AchievementTypeMaxAggregateInputType = {
    id?: true
    typeName?: true
    familyTreeId?: true
  }

  export type AchievementTypeCountAggregateInputType = {
    id?: true
    typeName?: true
    familyTreeId?: true
    _all?: true
  }

  export type AchievementTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementType to aggregate.
     */
    where?: AchievementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementTypes to fetch.
     */
    orderBy?: AchievementTypeOrderByWithRelationInput | AchievementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AchievementTypes
    **/
    _count?: true | AchievementTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementTypeMaxAggregateInputType
  }

  export type GetAchievementTypeAggregateType<T extends AchievementTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievementType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievementType[P]>
      : GetScalarType<T[P], AggregateAchievementType[P]>
  }




  export type AchievementTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementTypeWhereInput
    orderBy?: AchievementTypeOrderByWithAggregationInput | AchievementTypeOrderByWithAggregationInput[]
    by: AchievementTypeScalarFieldEnum[] | AchievementTypeScalarFieldEnum
    having?: AchievementTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementTypeCountAggregateInputType | true
    _avg?: AchievementTypeAvgAggregateInputType
    _sum?: AchievementTypeSumAggregateInputType
    _min?: AchievementTypeMinAggregateInputType
    _max?: AchievementTypeMaxAggregateInputType
  }

  export type AchievementTypeGroupByOutputType = {
    id: number
    typeName: string
    familyTreeId: number
    _count: AchievementTypeCountAggregateOutputType | null
    _avg: AchievementTypeAvgAggregateOutputType | null
    _sum: AchievementTypeSumAggregateOutputType | null
    _min: AchievementTypeMinAggregateOutputType | null
    _max: AchievementTypeMaxAggregateOutputType | null
  }

  type GetAchievementTypeGroupByPayload<T extends AchievementTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementTypeGroupByOutputType[P]>
        }
      >
    >


  export type AchievementTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    typeName?: boolean
    familyTreeId?: boolean
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
    achievements?: boolean | AchievementType$achievementsArgs<ExtArgs>
    _count?: boolean | AchievementTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievementType"]>



  export type AchievementTypeSelectScalar = {
    id?: boolean
    typeName?: boolean
    familyTreeId?: boolean
  }

  export type AchievementTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "typeName" | "familyTreeId", ExtArgs["result"]["achievementType"]>
  export type AchievementTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
    achievements?: boolean | AchievementType$achievementsArgs<ExtArgs>
    _count?: boolean | AchievementTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AchievementTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AchievementType"
    objects: {
      familyTree: Prisma.$FamilyTreePayload<ExtArgs>
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      typeName: string
      familyTreeId: number
    }, ExtArgs["result"]["achievementType"]>
    composites: {}
  }

  type AchievementTypeGetPayload<S extends boolean | null | undefined | AchievementTypeDefaultArgs> = $Result.GetResult<Prisma.$AchievementTypePayload, S>

  type AchievementTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementTypeCountAggregateInputType | true
    }

  export interface AchievementTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AchievementType'], meta: { name: 'AchievementType' } }
    /**
     * Find zero or one AchievementType that matches the filter.
     * @param {AchievementTypeFindUniqueArgs} args - Arguments to find a AchievementType
     * @example
     * // Get one AchievementType
     * const achievementType = await prisma.achievementType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementTypeFindUniqueArgs>(args: SelectSubset<T, AchievementTypeFindUniqueArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AchievementType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementTypeFindUniqueOrThrowArgs} args - Arguments to find a AchievementType
     * @example
     * // Get one AchievementType
     * const achievementType = await prisma.achievementType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeFindFirstArgs} args - Arguments to find a AchievementType
     * @example
     * // Get one AchievementType
     * const achievementType = await prisma.achievementType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementTypeFindFirstArgs>(args?: SelectSubset<T, AchievementTypeFindFirstArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AchievementType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeFindFirstOrThrowArgs} args - Arguments to find a AchievementType
     * @example
     * // Get one AchievementType
     * const achievementType = await prisma.achievementType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AchievementTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AchievementTypes
     * const achievementTypes = await prisma.achievementType.findMany()
     * 
     * // Get first 10 AchievementTypes
     * const achievementTypes = await prisma.achievementType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementTypeWithIdOnly = await prisma.achievementType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementTypeFindManyArgs>(args?: SelectSubset<T, AchievementTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AchievementType.
     * @param {AchievementTypeCreateArgs} args - Arguments to create a AchievementType.
     * @example
     * // Create one AchievementType
     * const AchievementType = await prisma.achievementType.create({
     *   data: {
     *     // ... data to create a AchievementType
     *   }
     * })
     * 
     */
    create<T extends AchievementTypeCreateArgs>(args: SelectSubset<T, AchievementTypeCreateArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AchievementTypes.
     * @param {AchievementTypeCreateManyArgs} args - Arguments to create many AchievementTypes.
     * @example
     * // Create many AchievementTypes
     * const achievementType = await prisma.achievementType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementTypeCreateManyArgs>(args?: SelectSubset<T, AchievementTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AchievementType.
     * @param {AchievementTypeDeleteArgs} args - Arguments to delete one AchievementType.
     * @example
     * // Delete one AchievementType
     * const AchievementType = await prisma.achievementType.delete({
     *   where: {
     *     // ... filter to delete one AchievementType
     *   }
     * })
     * 
     */
    delete<T extends AchievementTypeDeleteArgs>(args: SelectSubset<T, AchievementTypeDeleteArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AchievementType.
     * @param {AchievementTypeUpdateArgs} args - Arguments to update one AchievementType.
     * @example
     * // Update one AchievementType
     * const achievementType = await prisma.achievementType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementTypeUpdateArgs>(args: SelectSubset<T, AchievementTypeUpdateArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AchievementTypes.
     * @param {AchievementTypeDeleteManyArgs} args - Arguments to filter AchievementTypes to delete.
     * @example
     * // Delete a few AchievementTypes
     * const { count } = await prisma.achievementType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementTypeDeleteManyArgs>(args?: SelectSubset<T, AchievementTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AchievementTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AchievementTypes
     * const achievementType = await prisma.achievementType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementTypeUpdateManyArgs>(args: SelectSubset<T, AchievementTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AchievementType.
     * @param {AchievementTypeUpsertArgs} args - Arguments to update or create a AchievementType.
     * @example
     * // Update or create a AchievementType
     * const achievementType = await prisma.achievementType.upsert({
     *   create: {
     *     // ... data to create a AchievementType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AchievementType we want to update
     *   }
     * })
     */
    upsert<T extends AchievementTypeUpsertArgs>(args: SelectSubset<T, AchievementTypeUpsertArgs<ExtArgs>>): Prisma__AchievementTypeClient<$Result.GetResult<Prisma.$AchievementTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AchievementTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeCountArgs} args - Arguments to filter AchievementTypes to count.
     * @example
     * // Count the number of AchievementTypes
     * const count = await prisma.achievementType.count({
     *   where: {
     *     // ... the filter for the AchievementTypes we want to count
     *   }
     * })
    **/
    count<T extends AchievementTypeCountArgs>(
      args?: Subset<T, AchievementTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AchievementType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementTypeAggregateArgs>(args: Subset<T, AchievementTypeAggregateArgs>): Prisma.PrismaPromise<GetAchievementTypeAggregateType<T>>

    /**
     * Group by AchievementType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementTypeGroupByArgs['orderBy'] }
        : { orderBy?: AchievementTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AchievementType model
   */
  readonly fields: AchievementTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AchievementType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyTree<T extends FamilyTreeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTreeDefaultArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievements<T extends AchievementType$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, AchievementType$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AchievementType model
   */
  interface AchievementTypeFieldRefs {
    readonly id: FieldRef<"AchievementType", 'Int'>
    readonly typeName: FieldRef<"AchievementType", 'String'>
    readonly familyTreeId: FieldRef<"AchievementType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AchievementType findUnique
   */
  export type AchievementTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter, which AchievementType to fetch.
     */
    where: AchievementTypeWhereUniqueInput
  }

  /**
   * AchievementType findUniqueOrThrow
   */
  export type AchievementTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter, which AchievementType to fetch.
     */
    where: AchievementTypeWhereUniqueInput
  }

  /**
   * AchievementType findFirst
   */
  export type AchievementTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter, which AchievementType to fetch.
     */
    where?: AchievementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementTypes to fetch.
     */
    orderBy?: AchievementTypeOrderByWithRelationInput | AchievementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementTypes.
     */
    cursor?: AchievementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementTypes.
     */
    distinct?: AchievementTypeScalarFieldEnum | AchievementTypeScalarFieldEnum[]
  }

  /**
   * AchievementType findFirstOrThrow
   */
  export type AchievementTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter, which AchievementType to fetch.
     */
    where?: AchievementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementTypes to fetch.
     */
    orderBy?: AchievementTypeOrderByWithRelationInput | AchievementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AchievementTypes.
     */
    cursor?: AchievementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AchievementTypes.
     */
    distinct?: AchievementTypeScalarFieldEnum | AchievementTypeScalarFieldEnum[]
  }

  /**
   * AchievementType findMany
   */
  export type AchievementTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter, which AchievementTypes to fetch.
     */
    where?: AchievementTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AchievementTypes to fetch.
     */
    orderBy?: AchievementTypeOrderByWithRelationInput | AchievementTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AchievementTypes.
     */
    cursor?: AchievementTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AchievementTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AchievementTypes.
     */
    skip?: number
    distinct?: AchievementTypeScalarFieldEnum | AchievementTypeScalarFieldEnum[]
  }

  /**
   * AchievementType create
   */
  export type AchievementTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AchievementType.
     */
    data: XOR<AchievementTypeCreateInput, AchievementTypeUncheckedCreateInput>
  }

  /**
   * AchievementType createMany
   */
  export type AchievementTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AchievementTypes.
     */
    data: AchievementTypeCreateManyInput | AchievementTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AchievementType update
   */
  export type AchievementTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AchievementType.
     */
    data: XOR<AchievementTypeUpdateInput, AchievementTypeUncheckedUpdateInput>
    /**
     * Choose, which AchievementType to update.
     */
    where: AchievementTypeWhereUniqueInput
  }

  /**
   * AchievementType updateMany
   */
  export type AchievementTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AchievementTypes.
     */
    data: XOR<AchievementTypeUpdateManyMutationInput, AchievementTypeUncheckedUpdateManyInput>
    /**
     * Filter which AchievementTypes to update
     */
    where?: AchievementTypeWhereInput
    /**
     * Limit how many AchievementTypes to update.
     */
    limit?: number
  }

  /**
   * AchievementType upsert
   */
  export type AchievementTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AchievementType to update in case it exists.
     */
    where: AchievementTypeWhereUniqueInput
    /**
     * In case the AchievementType found by the `where` argument doesn't exist, create a new AchievementType with this data.
     */
    create: XOR<AchievementTypeCreateInput, AchievementTypeUncheckedCreateInput>
    /**
     * In case the AchievementType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementTypeUpdateInput, AchievementTypeUncheckedUpdateInput>
  }

  /**
   * AchievementType delete
   */
  export type AchievementTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
    /**
     * Filter which AchievementType to delete.
     */
    where: AchievementTypeWhereUniqueInput
  }

  /**
   * AchievementType deleteMany
   */
  export type AchievementTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AchievementTypes to delete
     */
    where?: AchievementTypeWhereInput
    /**
     * Limit how many AchievementTypes to delete.
     */
    limit?: number
  }

  /**
   * AchievementType.achievements
   */
  export type AchievementType$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * AchievementType without action
   */
  export type AchievementTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementType
     */
    select?: AchievementTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AchievementType
     */
    omit?: AchievementTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementTypeInclude<ExtArgs> | null
  }


  /**
   * Model PassingRecord
   */

  export type AggregatePassingRecord = {
    _count: PassingRecordCountAggregateOutputType | null
    _avg: PassingRecordAvgAggregateOutputType | null
    _sum: PassingRecordSumAggregateOutputType | null
    _min: PassingRecordMinAggregateOutputType | null
    _max: PassingRecordMaxAggregateOutputType | null
  }

  export type PassingRecordAvgAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
  }

  export type PassingRecordSumAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
  }

  export type PassingRecordMinAggregateOutputType = {
    id: number | null
    dateOfPassing: Date | null
    createdAt: Date | null
    familyMemberId: number | null
  }

  export type PassingRecordMaxAggregateOutputType = {
    id: number | null
    dateOfPassing: Date | null
    createdAt: Date | null
    familyMemberId: number | null
  }

  export type PassingRecordCountAggregateOutputType = {
    id: number
    dateOfPassing: number
    createdAt: number
    familyMemberId: number
    _all: number
  }


  export type PassingRecordAvgAggregateInputType = {
    id?: true
    familyMemberId?: true
  }

  export type PassingRecordSumAggregateInputType = {
    id?: true
    familyMemberId?: true
  }

  export type PassingRecordMinAggregateInputType = {
    id?: true
    dateOfPassing?: true
    createdAt?: true
    familyMemberId?: true
  }

  export type PassingRecordMaxAggregateInputType = {
    id?: true
    dateOfPassing?: true
    createdAt?: true
    familyMemberId?: true
  }

  export type PassingRecordCountAggregateInputType = {
    id?: true
    dateOfPassing?: true
    createdAt?: true
    familyMemberId?: true
    _all?: true
  }

  export type PassingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassingRecord to aggregate.
     */
    where?: PassingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassingRecords to fetch.
     */
    orderBy?: PassingRecordOrderByWithRelationInput | PassingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PassingRecords
    **/
    _count?: true | PassingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassingRecordMaxAggregateInputType
  }

  export type GetPassingRecordAggregateType<T extends PassingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregatePassingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassingRecord[P]>
      : GetScalarType<T[P], AggregatePassingRecord[P]>
  }




  export type PassingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassingRecordWhereInput
    orderBy?: PassingRecordOrderByWithAggregationInput | PassingRecordOrderByWithAggregationInput[]
    by: PassingRecordScalarFieldEnum[] | PassingRecordScalarFieldEnum
    having?: PassingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassingRecordCountAggregateInputType | true
    _avg?: PassingRecordAvgAggregateInputType
    _sum?: PassingRecordSumAggregateInputType
    _min?: PassingRecordMinAggregateInputType
    _max?: PassingRecordMaxAggregateInputType
  }

  export type PassingRecordGroupByOutputType = {
    id: number
    dateOfPassing: Date
    createdAt: Date
    familyMemberId: number
    _count: PassingRecordCountAggregateOutputType | null
    _avg: PassingRecordAvgAggregateOutputType | null
    _sum: PassingRecordSumAggregateOutputType | null
    _min: PassingRecordMinAggregateOutputType | null
    _max: PassingRecordMaxAggregateOutputType | null
  }

  type GetPassingRecordGroupByPayload<T extends PassingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], PassingRecordGroupByOutputType[P]>
        }
      >
    >


  export type PassingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateOfPassing?: boolean
    createdAt?: boolean
    familyMemberId?: boolean
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    causeOfDeath?: boolean | PassingRecord$causeOfDeathArgs<ExtArgs>
    buriedPlaces?: boolean | PassingRecord$buriedPlacesArgs<ExtArgs>
    _count?: boolean | PassingRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passingRecord"]>



  export type PassingRecordSelectScalar = {
    id?: boolean
    dateOfPassing?: boolean
    createdAt?: boolean
    familyMemberId?: boolean
  }

  export type PassingRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateOfPassing" | "createdAt" | "familyMemberId", ExtArgs["result"]["passingRecord"]>
  export type PassingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    causeOfDeath?: boolean | PassingRecord$causeOfDeathArgs<ExtArgs>
    buriedPlaces?: boolean | PassingRecord$buriedPlacesArgs<ExtArgs>
    _count?: boolean | PassingRecordCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PassingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PassingRecord"
    objects: {
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
      causeOfDeath: Prisma.$CauseOfDeathPayload<ExtArgs> | null
      buriedPlaces: Prisma.$BuriedPlacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateOfPassing: Date
      createdAt: Date
      familyMemberId: number
    }, ExtArgs["result"]["passingRecord"]>
    composites: {}
  }

  type PassingRecordGetPayload<S extends boolean | null | undefined | PassingRecordDefaultArgs> = $Result.GetResult<Prisma.$PassingRecordPayload, S>

  type PassingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassingRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassingRecordCountAggregateInputType | true
    }

  export interface PassingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PassingRecord'], meta: { name: 'PassingRecord' } }
    /**
     * Find zero or one PassingRecord that matches the filter.
     * @param {PassingRecordFindUniqueArgs} args - Arguments to find a PassingRecord
     * @example
     * // Get one PassingRecord
     * const passingRecord = await prisma.passingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassingRecordFindUniqueArgs>(args: SelectSubset<T, PassingRecordFindUniqueArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PassingRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassingRecordFindUniqueOrThrowArgs} args - Arguments to find a PassingRecord
     * @example
     * // Get one PassingRecord
     * const passingRecord = await prisma.passingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, PassingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordFindFirstArgs} args - Arguments to find a PassingRecord
     * @example
     * // Get one PassingRecord
     * const passingRecord = await prisma.passingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassingRecordFindFirstArgs>(args?: SelectSubset<T, PassingRecordFindFirstArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordFindFirstOrThrowArgs} args - Arguments to find a PassingRecord
     * @example
     * // Get one PassingRecord
     * const passingRecord = await prisma.passingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, PassingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PassingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PassingRecords
     * const passingRecords = await prisma.passingRecord.findMany()
     * 
     * // Get first 10 PassingRecords
     * const passingRecords = await prisma.passingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passingRecordWithIdOnly = await prisma.passingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassingRecordFindManyArgs>(args?: SelectSubset<T, PassingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PassingRecord.
     * @param {PassingRecordCreateArgs} args - Arguments to create a PassingRecord.
     * @example
     * // Create one PassingRecord
     * const PassingRecord = await prisma.passingRecord.create({
     *   data: {
     *     // ... data to create a PassingRecord
     *   }
     * })
     * 
     */
    create<T extends PassingRecordCreateArgs>(args: SelectSubset<T, PassingRecordCreateArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PassingRecords.
     * @param {PassingRecordCreateManyArgs} args - Arguments to create many PassingRecords.
     * @example
     * // Create many PassingRecords
     * const passingRecord = await prisma.passingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassingRecordCreateManyArgs>(args?: SelectSubset<T, PassingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PassingRecord.
     * @param {PassingRecordDeleteArgs} args - Arguments to delete one PassingRecord.
     * @example
     * // Delete one PassingRecord
     * const PassingRecord = await prisma.passingRecord.delete({
     *   where: {
     *     // ... filter to delete one PassingRecord
     *   }
     * })
     * 
     */
    delete<T extends PassingRecordDeleteArgs>(args: SelectSubset<T, PassingRecordDeleteArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PassingRecord.
     * @param {PassingRecordUpdateArgs} args - Arguments to update one PassingRecord.
     * @example
     * // Update one PassingRecord
     * const passingRecord = await prisma.passingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassingRecordUpdateArgs>(args: SelectSubset<T, PassingRecordUpdateArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PassingRecords.
     * @param {PassingRecordDeleteManyArgs} args - Arguments to filter PassingRecords to delete.
     * @example
     * // Delete a few PassingRecords
     * const { count } = await prisma.passingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassingRecordDeleteManyArgs>(args?: SelectSubset<T, PassingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PassingRecords
     * const passingRecord = await prisma.passingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassingRecordUpdateManyArgs>(args: SelectSubset<T, PassingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PassingRecord.
     * @param {PassingRecordUpsertArgs} args - Arguments to update or create a PassingRecord.
     * @example
     * // Update or create a PassingRecord
     * const passingRecord = await prisma.passingRecord.upsert({
     *   create: {
     *     // ... data to create a PassingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PassingRecord we want to update
     *   }
     * })
     */
    upsert<T extends PassingRecordUpsertArgs>(args: SelectSubset<T, PassingRecordUpsertArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PassingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordCountArgs} args - Arguments to filter PassingRecords to count.
     * @example
     * // Count the number of PassingRecords
     * const count = await prisma.passingRecord.count({
     *   where: {
     *     // ... the filter for the PassingRecords we want to count
     *   }
     * })
    **/
    count<T extends PassingRecordCountArgs>(
      args?: Subset<T, PassingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PassingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassingRecordAggregateArgs>(args: Subset<T, PassingRecordAggregateArgs>): Prisma.PrismaPromise<GetPassingRecordAggregateType<T>>

    /**
     * Group by PassingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassingRecordGroupByArgs['orderBy'] }
        : { orderBy?: PassingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PassingRecord model
   */
  readonly fields: PassingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PassingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    causeOfDeath<T extends PassingRecord$causeOfDeathArgs<ExtArgs> = {}>(args?: Subset<T, PassingRecord$causeOfDeathArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    buriedPlaces<T extends PassingRecord$buriedPlacesArgs<ExtArgs> = {}>(args?: Subset<T, PassingRecord$buriedPlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PassingRecord model
   */
  interface PassingRecordFieldRefs {
    readonly id: FieldRef<"PassingRecord", 'Int'>
    readonly dateOfPassing: FieldRef<"PassingRecord", 'DateTime'>
    readonly createdAt: FieldRef<"PassingRecord", 'DateTime'>
    readonly familyMemberId: FieldRef<"PassingRecord", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PassingRecord findUnique
   */
  export type PassingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter, which PassingRecord to fetch.
     */
    where: PassingRecordWhereUniqueInput
  }

  /**
   * PassingRecord findUniqueOrThrow
   */
  export type PassingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter, which PassingRecord to fetch.
     */
    where: PassingRecordWhereUniqueInput
  }

  /**
   * PassingRecord findFirst
   */
  export type PassingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter, which PassingRecord to fetch.
     */
    where?: PassingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassingRecords to fetch.
     */
    orderBy?: PassingRecordOrderByWithRelationInput | PassingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassingRecords.
     */
    cursor?: PassingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassingRecords.
     */
    distinct?: PassingRecordScalarFieldEnum | PassingRecordScalarFieldEnum[]
  }

  /**
   * PassingRecord findFirstOrThrow
   */
  export type PassingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter, which PassingRecord to fetch.
     */
    where?: PassingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassingRecords to fetch.
     */
    orderBy?: PassingRecordOrderByWithRelationInput | PassingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassingRecords.
     */
    cursor?: PassingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassingRecords.
     */
    distinct?: PassingRecordScalarFieldEnum | PassingRecordScalarFieldEnum[]
  }

  /**
   * PassingRecord findMany
   */
  export type PassingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter, which PassingRecords to fetch.
     */
    where?: PassingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassingRecords to fetch.
     */
    orderBy?: PassingRecordOrderByWithRelationInput | PassingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PassingRecords.
     */
    cursor?: PassingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassingRecords.
     */
    skip?: number
    distinct?: PassingRecordScalarFieldEnum | PassingRecordScalarFieldEnum[]
  }

  /**
   * PassingRecord create
   */
  export type PassingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a PassingRecord.
     */
    data: XOR<PassingRecordCreateInput, PassingRecordUncheckedCreateInput>
  }

  /**
   * PassingRecord createMany
   */
  export type PassingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PassingRecords.
     */
    data: PassingRecordCreateManyInput | PassingRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PassingRecord update
   */
  export type PassingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a PassingRecord.
     */
    data: XOR<PassingRecordUpdateInput, PassingRecordUncheckedUpdateInput>
    /**
     * Choose, which PassingRecord to update.
     */
    where: PassingRecordWhereUniqueInput
  }

  /**
   * PassingRecord updateMany
   */
  export type PassingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PassingRecords.
     */
    data: XOR<PassingRecordUpdateManyMutationInput, PassingRecordUncheckedUpdateManyInput>
    /**
     * Filter which PassingRecords to update
     */
    where?: PassingRecordWhereInput
    /**
     * Limit how many PassingRecords to update.
     */
    limit?: number
  }

  /**
   * PassingRecord upsert
   */
  export type PassingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the PassingRecord to update in case it exists.
     */
    where: PassingRecordWhereUniqueInput
    /**
     * In case the PassingRecord found by the `where` argument doesn't exist, create a new PassingRecord with this data.
     */
    create: XOR<PassingRecordCreateInput, PassingRecordUncheckedCreateInput>
    /**
     * In case the PassingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassingRecordUpdateInput, PassingRecordUncheckedUpdateInput>
  }

  /**
   * PassingRecord delete
   */
  export type PassingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
    /**
     * Filter which PassingRecord to delete.
     */
    where: PassingRecordWhereUniqueInput
  }

  /**
   * PassingRecord deleteMany
   */
  export type PassingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassingRecords to delete
     */
    where?: PassingRecordWhereInput
    /**
     * Limit how many PassingRecords to delete.
     */
    limit?: number
  }

  /**
   * PassingRecord.causeOfDeath
   */
  export type PassingRecord$causeOfDeathArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    where?: CauseOfDeathWhereInput
  }

  /**
   * PassingRecord.buriedPlaces
   */
  export type PassingRecord$buriedPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    where?: BuriedPlaceWhereInput
    orderBy?: BuriedPlaceOrderByWithRelationInput | BuriedPlaceOrderByWithRelationInput[]
    cursor?: BuriedPlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuriedPlaceScalarFieldEnum | BuriedPlaceScalarFieldEnum[]
  }

  /**
   * PassingRecord without action
   */
  export type PassingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassingRecord
     */
    select?: PassingRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassingRecord
     */
    omit?: PassingRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassingRecordInclude<ExtArgs> | null
  }


  /**
   * Model CauseOfDeath
   */

  export type AggregateCauseOfDeath = {
    _count: CauseOfDeathCountAggregateOutputType | null
    _avg: CauseOfDeathAvgAggregateOutputType | null
    _sum: CauseOfDeathSumAggregateOutputType | null
    _min: CauseOfDeathMinAggregateOutputType | null
    _max: CauseOfDeathMaxAggregateOutputType | null
  }

  export type CauseOfDeathAvgAggregateOutputType = {
    id: number | null
    passingRecordId: number | null
    familyMemberId: number | null
  }

  export type CauseOfDeathSumAggregateOutputType = {
    id: number | null
    passingRecordId: number | null
    familyMemberId: number | null
  }

  export type CauseOfDeathMinAggregateOutputType = {
    id: number | null
    causeName: string | null
    passingRecordId: number | null
    familyMemberId: number | null
  }

  export type CauseOfDeathMaxAggregateOutputType = {
    id: number | null
    causeName: string | null
    passingRecordId: number | null
    familyMemberId: number | null
  }

  export type CauseOfDeathCountAggregateOutputType = {
    id: number
    causeName: number
    passingRecordId: number
    familyMemberId: number
    _all: number
  }


  export type CauseOfDeathAvgAggregateInputType = {
    id?: true
    passingRecordId?: true
    familyMemberId?: true
  }

  export type CauseOfDeathSumAggregateInputType = {
    id?: true
    passingRecordId?: true
    familyMemberId?: true
  }

  export type CauseOfDeathMinAggregateInputType = {
    id?: true
    causeName?: true
    passingRecordId?: true
    familyMemberId?: true
  }

  export type CauseOfDeathMaxAggregateInputType = {
    id?: true
    causeName?: true
    passingRecordId?: true
    familyMemberId?: true
  }

  export type CauseOfDeathCountAggregateInputType = {
    id?: true
    causeName?: true
    passingRecordId?: true
    familyMemberId?: true
    _all?: true
  }

  export type CauseOfDeathAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CauseOfDeath to aggregate.
     */
    where?: CauseOfDeathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CauseOfDeaths to fetch.
     */
    orderBy?: CauseOfDeathOrderByWithRelationInput | CauseOfDeathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CauseOfDeathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CauseOfDeaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CauseOfDeaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CauseOfDeaths
    **/
    _count?: true | CauseOfDeathCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CauseOfDeathAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CauseOfDeathSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CauseOfDeathMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CauseOfDeathMaxAggregateInputType
  }

  export type GetCauseOfDeathAggregateType<T extends CauseOfDeathAggregateArgs> = {
        [P in keyof T & keyof AggregateCauseOfDeath]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCauseOfDeath[P]>
      : GetScalarType<T[P], AggregateCauseOfDeath[P]>
  }




  export type CauseOfDeathGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CauseOfDeathWhereInput
    orderBy?: CauseOfDeathOrderByWithAggregationInput | CauseOfDeathOrderByWithAggregationInput[]
    by: CauseOfDeathScalarFieldEnum[] | CauseOfDeathScalarFieldEnum
    having?: CauseOfDeathScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CauseOfDeathCountAggregateInputType | true
    _avg?: CauseOfDeathAvgAggregateInputType
    _sum?: CauseOfDeathSumAggregateInputType
    _min?: CauseOfDeathMinAggregateInputType
    _max?: CauseOfDeathMaxAggregateInputType
  }

  export type CauseOfDeathGroupByOutputType = {
    id: number
    causeName: string
    passingRecordId: number
    familyMemberId: number
    _count: CauseOfDeathCountAggregateOutputType | null
    _avg: CauseOfDeathAvgAggregateOutputType | null
    _sum: CauseOfDeathSumAggregateOutputType | null
    _min: CauseOfDeathMinAggregateOutputType | null
    _max: CauseOfDeathMaxAggregateOutputType | null
  }

  type GetCauseOfDeathGroupByPayload<T extends CauseOfDeathGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CauseOfDeathGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CauseOfDeathGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CauseOfDeathGroupByOutputType[P]>
            : GetScalarType<T[P], CauseOfDeathGroupByOutputType[P]>
        }
      >
    >


  export type CauseOfDeathSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    causeName?: boolean
    passingRecordId?: boolean
    familyMemberId?: boolean
    passingRecord?: boolean | PassingRecordDefaultArgs<ExtArgs>
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["causeOfDeath"]>



  export type CauseOfDeathSelectScalar = {
    id?: boolean
    causeName?: boolean
    passingRecordId?: boolean
    familyMemberId?: boolean
  }

  export type CauseOfDeathOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "causeName" | "passingRecordId" | "familyMemberId", ExtArgs["result"]["causeOfDeath"]>
  export type CauseOfDeathInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passingRecord?: boolean | PassingRecordDefaultArgs<ExtArgs>
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }

  export type $CauseOfDeathPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CauseOfDeath"
    objects: {
      passingRecord: Prisma.$PassingRecordPayload<ExtArgs>
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      causeName: string
      passingRecordId: number
      familyMemberId: number
    }, ExtArgs["result"]["causeOfDeath"]>
    composites: {}
  }

  type CauseOfDeathGetPayload<S extends boolean | null | undefined | CauseOfDeathDefaultArgs> = $Result.GetResult<Prisma.$CauseOfDeathPayload, S>

  type CauseOfDeathCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CauseOfDeathFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CauseOfDeathCountAggregateInputType | true
    }

  export interface CauseOfDeathDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CauseOfDeath'], meta: { name: 'CauseOfDeath' } }
    /**
     * Find zero or one CauseOfDeath that matches the filter.
     * @param {CauseOfDeathFindUniqueArgs} args - Arguments to find a CauseOfDeath
     * @example
     * // Get one CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CauseOfDeathFindUniqueArgs>(args: SelectSubset<T, CauseOfDeathFindUniqueArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CauseOfDeath that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CauseOfDeathFindUniqueOrThrowArgs} args - Arguments to find a CauseOfDeath
     * @example
     * // Get one CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CauseOfDeathFindUniqueOrThrowArgs>(args: SelectSubset<T, CauseOfDeathFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CauseOfDeath that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathFindFirstArgs} args - Arguments to find a CauseOfDeath
     * @example
     * // Get one CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CauseOfDeathFindFirstArgs>(args?: SelectSubset<T, CauseOfDeathFindFirstArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CauseOfDeath that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathFindFirstOrThrowArgs} args - Arguments to find a CauseOfDeath
     * @example
     * // Get one CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CauseOfDeathFindFirstOrThrowArgs>(args?: SelectSubset<T, CauseOfDeathFindFirstOrThrowArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CauseOfDeaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CauseOfDeaths
     * const causeOfDeaths = await prisma.causeOfDeath.findMany()
     * 
     * // Get first 10 CauseOfDeaths
     * const causeOfDeaths = await prisma.causeOfDeath.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const causeOfDeathWithIdOnly = await prisma.causeOfDeath.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CauseOfDeathFindManyArgs>(args?: SelectSubset<T, CauseOfDeathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CauseOfDeath.
     * @param {CauseOfDeathCreateArgs} args - Arguments to create a CauseOfDeath.
     * @example
     * // Create one CauseOfDeath
     * const CauseOfDeath = await prisma.causeOfDeath.create({
     *   data: {
     *     // ... data to create a CauseOfDeath
     *   }
     * })
     * 
     */
    create<T extends CauseOfDeathCreateArgs>(args: SelectSubset<T, CauseOfDeathCreateArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CauseOfDeaths.
     * @param {CauseOfDeathCreateManyArgs} args - Arguments to create many CauseOfDeaths.
     * @example
     * // Create many CauseOfDeaths
     * const causeOfDeath = await prisma.causeOfDeath.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CauseOfDeathCreateManyArgs>(args?: SelectSubset<T, CauseOfDeathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CauseOfDeath.
     * @param {CauseOfDeathDeleteArgs} args - Arguments to delete one CauseOfDeath.
     * @example
     * // Delete one CauseOfDeath
     * const CauseOfDeath = await prisma.causeOfDeath.delete({
     *   where: {
     *     // ... filter to delete one CauseOfDeath
     *   }
     * })
     * 
     */
    delete<T extends CauseOfDeathDeleteArgs>(args: SelectSubset<T, CauseOfDeathDeleteArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CauseOfDeath.
     * @param {CauseOfDeathUpdateArgs} args - Arguments to update one CauseOfDeath.
     * @example
     * // Update one CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CauseOfDeathUpdateArgs>(args: SelectSubset<T, CauseOfDeathUpdateArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CauseOfDeaths.
     * @param {CauseOfDeathDeleteManyArgs} args - Arguments to filter CauseOfDeaths to delete.
     * @example
     * // Delete a few CauseOfDeaths
     * const { count } = await prisma.causeOfDeath.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CauseOfDeathDeleteManyArgs>(args?: SelectSubset<T, CauseOfDeathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CauseOfDeaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CauseOfDeaths
     * const causeOfDeath = await prisma.causeOfDeath.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CauseOfDeathUpdateManyArgs>(args: SelectSubset<T, CauseOfDeathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CauseOfDeath.
     * @param {CauseOfDeathUpsertArgs} args - Arguments to update or create a CauseOfDeath.
     * @example
     * // Update or create a CauseOfDeath
     * const causeOfDeath = await prisma.causeOfDeath.upsert({
     *   create: {
     *     // ... data to create a CauseOfDeath
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CauseOfDeath we want to update
     *   }
     * })
     */
    upsert<T extends CauseOfDeathUpsertArgs>(args: SelectSubset<T, CauseOfDeathUpsertArgs<ExtArgs>>): Prisma__CauseOfDeathClient<$Result.GetResult<Prisma.$CauseOfDeathPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CauseOfDeaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathCountArgs} args - Arguments to filter CauseOfDeaths to count.
     * @example
     * // Count the number of CauseOfDeaths
     * const count = await prisma.causeOfDeath.count({
     *   where: {
     *     // ... the filter for the CauseOfDeaths we want to count
     *   }
     * })
    **/
    count<T extends CauseOfDeathCountArgs>(
      args?: Subset<T, CauseOfDeathCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CauseOfDeathCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CauseOfDeath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CauseOfDeathAggregateArgs>(args: Subset<T, CauseOfDeathAggregateArgs>): Prisma.PrismaPromise<GetCauseOfDeathAggregateType<T>>

    /**
     * Group by CauseOfDeath.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CauseOfDeathGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CauseOfDeathGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CauseOfDeathGroupByArgs['orderBy'] }
        : { orderBy?: CauseOfDeathGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CauseOfDeathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCauseOfDeathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CauseOfDeath model
   */
  readonly fields: CauseOfDeathFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CauseOfDeath.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CauseOfDeathClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passingRecord<T extends PassingRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PassingRecordDefaultArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CauseOfDeath model
   */
  interface CauseOfDeathFieldRefs {
    readonly id: FieldRef<"CauseOfDeath", 'Int'>
    readonly causeName: FieldRef<"CauseOfDeath", 'String'>
    readonly passingRecordId: FieldRef<"CauseOfDeath", 'Int'>
    readonly familyMemberId: FieldRef<"CauseOfDeath", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CauseOfDeath findUnique
   */
  export type CauseOfDeathFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter, which CauseOfDeath to fetch.
     */
    where: CauseOfDeathWhereUniqueInput
  }

  /**
   * CauseOfDeath findUniqueOrThrow
   */
  export type CauseOfDeathFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter, which CauseOfDeath to fetch.
     */
    where: CauseOfDeathWhereUniqueInput
  }

  /**
   * CauseOfDeath findFirst
   */
  export type CauseOfDeathFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter, which CauseOfDeath to fetch.
     */
    where?: CauseOfDeathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CauseOfDeaths to fetch.
     */
    orderBy?: CauseOfDeathOrderByWithRelationInput | CauseOfDeathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CauseOfDeaths.
     */
    cursor?: CauseOfDeathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CauseOfDeaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CauseOfDeaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CauseOfDeaths.
     */
    distinct?: CauseOfDeathScalarFieldEnum | CauseOfDeathScalarFieldEnum[]
  }

  /**
   * CauseOfDeath findFirstOrThrow
   */
  export type CauseOfDeathFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter, which CauseOfDeath to fetch.
     */
    where?: CauseOfDeathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CauseOfDeaths to fetch.
     */
    orderBy?: CauseOfDeathOrderByWithRelationInput | CauseOfDeathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CauseOfDeaths.
     */
    cursor?: CauseOfDeathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CauseOfDeaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CauseOfDeaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CauseOfDeaths.
     */
    distinct?: CauseOfDeathScalarFieldEnum | CauseOfDeathScalarFieldEnum[]
  }

  /**
   * CauseOfDeath findMany
   */
  export type CauseOfDeathFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter, which CauseOfDeaths to fetch.
     */
    where?: CauseOfDeathWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CauseOfDeaths to fetch.
     */
    orderBy?: CauseOfDeathOrderByWithRelationInput | CauseOfDeathOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CauseOfDeaths.
     */
    cursor?: CauseOfDeathWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CauseOfDeaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CauseOfDeaths.
     */
    skip?: number
    distinct?: CauseOfDeathScalarFieldEnum | CauseOfDeathScalarFieldEnum[]
  }

  /**
   * CauseOfDeath create
   */
  export type CauseOfDeathCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * The data needed to create a CauseOfDeath.
     */
    data: XOR<CauseOfDeathCreateInput, CauseOfDeathUncheckedCreateInput>
  }

  /**
   * CauseOfDeath createMany
   */
  export type CauseOfDeathCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CauseOfDeaths.
     */
    data: CauseOfDeathCreateManyInput | CauseOfDeathCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CauseOfDeath update
   */
  export type CauseOfDeathUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * The data needed to update a CauseOfDeath.
     */
    data: XOR<CauseOfDeathUpdateInput, CauseOfDeathUncheckedUpdateInput>
    /**
     * Choose, which CauseOfDeath to update.
     */
    where: CauseOfDeathWhereUniqueInput
  }

  /**
   * CauseOfDeath updateMany
   */
  export type CauseOfDeathUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CauseOfDeaths.
     */
    data: XOR<CauseOfDeathUpdateManyMutationInput, CauseOfDeathUncheckedUpdateManyInput>
    /**
     * Filter which CauseOfDeaths to update
     */
    where?: CauseOfDeathWhereInput
    /**
     * Limit how many CauseOfDeaths to update.
     */
    limit?: number
  }

  /**
   * CauseOfDeath upsert
   */
  export type CauseOfDeathUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * The filter to search for the CauseOfDeath to update in case it exists.
     */
    where: CauseOfDeathWhereUniqueInput
    /**
     * In case the CauseOfDeath found by the `where` argument doesn't exist, create a new CauseOfDeath with this data.
     */
    create: XOR<CauseOfDeathCreateInput, CauseOfDeathUncheckedCreateInput>
    /**
     * In case the CauseOfDeath was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CauseOfDeathUpdateInput, CauseOfDeathUncheckedUpdateInput>
  }

  /**
   * CauseOfDeath delete
   */
  export type CauseOfDeathDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
    /**
     * Filter which CauseOfDeath to delete.
     */
    where: CauseOfDeathWhereUniqueInput
  }

  /**
   * CauseOfDeath deleteMany
   */
  export type CauseOfDeathDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CauseOfDeaths to delete
     */
    where?: CauseOfDeathWhereInput
    /**
     * Limit how many CauseOfDeaths to delete.
     */
    limit?: number
  }

  /**
   * CauseOfDeath without action
   */
  export type CauseOfDeathDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CauseOfDeath
     */
    select?: CauseOfDeathSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CauseOfDeath
     */
    omit?: CauseOfDeathOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CauseOfDeathInclude<ExtArgs> | null
  }


  /**
   * Model BuriedPlace
   */

  export type AggregateBuriedPlace = {
    _count: BuriedPlaceCountAggregateOutputType | null
    _avg: BuriedPlaceAvgAggregateOutputType | null
    _sum: BuriedPlaceSumAggregateOutputType | null
    _min: BuriedPlaceMinAggregateOutputType | null
    _max: BuriedPlaceMaxAggregateOutputType | null
  }

  export type BuriedPlaceAvgAggregateOutputType = {
    id: number | null
    passingRecordId: number | null
  }

  export type BuriedPlaceSumAggregateOutputType = {
    id: number | null
    passingRecordId: number | null
  }

  export type BuriedPlaceMinAggregateOutputType = {
    id: number | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    passingRecordId: number | null
  }

  export type BuriedPlaceMaxAggregateOutputType = {
    id: number | null
    location: string | null
    startDate: Date | null
    endDate: Date | null
    passingRecordId: number | null
  }

  export type BuriedPlaceCountAggregateOutputType = {
    id: number
    location: number
    startDate: number
    endDate: number
    passingRecordId: number
    _all: number
  }


  export type BuriedPlaceAvgAggregateInputType = {
    id?: true
    passingRecordId?: true
  }

  export type BuriedPlaceSumAggregateInputType = {
    id?: true
    passingRecordId?: true
  }

  export type BuriedPlaceMinAggregateInputType = {
    id?: true
    location?: true
    startDate?: true
    endDate?: true
    passingRecordId?: true
  }

  export type BuriedPlaceMaxAggregateInputType = {
    id?: true
    location?: true
    startDate?: true
    endDate?: true
    passingRecordId?: true
  }

  export type BuriedPlaceCountAggregateInputType = {
    id?: true
    location?: true
    startDate?: true
    endDate?: true
    passingRecordId?: true
    _all?: true
  }

  export type BuriedPlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuriedPlace to aggregate.
     */
    where?: BuriedPlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuriedPlaces to fetch.
     */
    orderBy?: BuriedPlaceOrderByWithRelationInput | BuriedPlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuriedPlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuriedPlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuriedPlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuriedPlaces
    **/
    _count?: true | BuriedPlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuriedPlaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuriedPlaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuriedPlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuriedPlaceMaxAggregateInputType
  }

  export type GetBuriedPlaceAggregateType<T extends BuriedPlaceAggregateArgs> = {
        [P in keyof T & keyof AggregateBuriedPlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuriedPlace[P]>
      : GetScalarType<T[P], AggregateBuriedPlace[P]>
  }




  export type BuriedPlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuriedPlaceWhereInput
    orderBy?: BuriedPlaceOrderByWithAggregationInput | BuriedPlaceOrderByWithAggregationInput[]
    by: BuriedPlaceScalarFieldEnum[] | BuriedPlaceScalarFieldEnum
    having?: BuriedPlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuriedPlaceCountAggregateInputType | true
    _avg?: BuriedPlaceAvgAggregateInputType
    _sum?: BuriedPlaceSumAggregateInputType
    _min?: BuriedPlaceMinAggregateInputType
    _max?: BuriedPlaceMaxAggregateInputType
  }

  export type BuriedPlaceGroupByOutputType = {
    id: number
    location: string
    startDate: Date | null
    endDate: Date | null
    passingRecordId: number
    _count: BuriedPlaceCountAggregateOutputType | null
    _avg: BuriedPlaceAvgAggregateOutputType | null
    _sum: BuriedPlaceSumAggregateOutputType | null
    _min: BuriedPlaceMinAggregateOutputType | null
    _max: BuriedPlaceMaxAggregateOutputType | null
  }

  type GetBuriedPlaceGroupByPayload<T extends BuriedPlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuriedPlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuriedPlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuriedPlaceGroupByOutputType[P]>
            : GetScalarType<T[P], BuriedPlaceGroupByOutputType[P]>
        }
      >
    >


  export type BuriedPlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    passingRecordId?: boolean
    passingRecord?: boolean | PassingRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["buriedPlace"]>



  export type BuriedPlaceSelectScalar = {
    id?: boolean
    location?: boolean
    startDate?: boolean
    endDate?: boolean
    passingRecordId?: boolean
  }

  export type BuriedPlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location" | "startDate" | "endDate" | "passingRecordId", ExtArgs["result"]["buriedPlace"]>
  export type BuriedPlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passingRecord?: boolean | PassingRecordDefaultArgs<ExtArgs>
  }

  export type $BuriedPlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuriedPlace"
    objects: {
      passingRecord: Prisma.$PassingRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      location: string
      startDate: Date | null
      endDate: Date | null
      passingRecordId: number
    }, ExtArgs["result"]["buriedPlace"]>
    composites: {}
  }

  type BuriedPlaceGetPayload<S extends boolean | null | undefined | BuriedPlaceDefaultArgs> = $Result.GetResult<Prisma.$BuriedPlacePayload, S>

  type BuriedPlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuriedPlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuriedPlaceCountAggregateInputType | true
    }

  export interface BuriedPlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuriedPlace'], meta: { name: 'BuriedPlace' } }
    /**
     * Find zero or one BuriedPlace that matches the filter.
     * @param {BuriedPlaceFindUniqueArgs} args - Arguments to find a BuriedPlace
     * @example
     * // Get one BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuriedPlaceFindUniqueArgs>(args: SelectSubset<T, BuriedPlaceFindUniqueArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuriedPlace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuriedPlaceFindUniqueOrThrowArgs} args - Arguments to find a BuriedPlace
     * @example
     * // Get one BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuriedPlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, BuriedPlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuriedPlace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceFindFirstArgs} args - Arguments to find a BuriedPlace
     * @example
     * // Get one BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuriedPlaceFindFirstArgs>(args?: SelectSubset<T, BuriedPlaceFindFirstArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuriedPlace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceFindFirstOrThrowArgs} args - Arguments to find a BuriedPlace
     * @example
     * // Get one BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuriedPlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, BuriedPlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuriedPlaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuriedPlaces
     * const buriedPlaces = await prisma.buriedPlace.findMany()
     * 
     * // Get first 10 BuriedPlaces
     * const buriedPlaces = await prisma.buriedPlace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buriedPlaceWithIdOnly = await prisma.buriedPlace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuriedPlaceFindManyArgs>(args?: SelectSubset<T, BuriedPlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuriedPlace.
     * @param {BuriedPlaceCreateArgs} args - Arguments to create a BuriedPlace.
     * @example
     * // Create one BuriedPlace
     * const BuriedPlace = await prisma.buriedPlace.create({
     *   data: {
     *     // ... data to create a BuriedPlace
     *   }
     * })
     * 
     */
    create<T extends BuriedPlaceCreateArgs>(args: SelectSubset<T, BuriedPlaceCreateArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuriedPlaces.
     * @param {BuriedPlaceCreateManyArgs} args - Arguments to create many BuriedPlaces.
     * @example
     * // Create many BuriedPlaces
     * const buriedPlace = await prisma.buriedPlace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuriedPlaceCreateManyArgs>(args?: SelectSubset<T, BuriedPlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuriedPlace.
     * @param {BuriedPlaceDeleteArgs} args - Arguments to delete one BuriedPlace.
     * @example
     * // Delete one BuriedPlace
     * const BuriedPlace = await prisma.buriedPlace.delete({
     *   where: {
     *     // ... filter to delete one BuriedPlace
     *   }
     * })
     * 
     */
    delete<T extends BuriedPlaceDeleteArgs>(args: SelectSubset<T, BuriedPlaceDeleteArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuriedPlace.
     * @param {BuriedPlaceUpdateArgs} args - Arguments to update one BuriedPlace.
     * @example
     * // Update one BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuriedPlaceUpdateArgs>(args: SelectSubset<T, BuriedPlaceUpdateArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuriedPlaces.
     * @param {BuriedPlaceDeleteManyArgs} args - Arguments to filter BuriedPlaces to delete.
     * @example
     * // Delete a few BuriedPlaces
     * const { count } = await prisma.buriedPlace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuriedPlaceDeleteManyArgs>(args?: SelectSubset<T, BuriedPlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuriedPlaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuriedPlaces
     * const buriedPlace = await prisma.buriedPlace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuriedPlaceUpdateManyArgs>(args: SelectSubset<T, BuriedPlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuriedPlace.
     * @param {BuriedPlaceUpsertArgs} args - Arguments to update or create a BuriedPlace.
     * @example
     * // Update or create a BuriedPlace
     * const buriedPlace = await prisma.buriedPlace.upsert({
     *   create: {
     *     // ... data to create a BuriedPlace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuriedPlace we want to update
     *   }
     * })
     */
    upsert<T extends BuriedPlaceUpsertArgs>(args: SelectSubset<T, BuriedPlaceUpsertArgs<ExtArgs>>): Prisma__BuriedPlaceClient<$Result.GetResult<Prisma.$BuriedPlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BuriedPlaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceCountArgs} args - Arguments to filter BuriedPlaces to count.
     * @example
     * // Count the number of BuriedPlaces
     * const count = await prisma.buriedPlace.count({
     *   where: {
     *     // ... the filter for the BuriedPlaces we want to count
     *   }
     * })
    **/
    count<T extends BuriedPlaceCountArgs>(
      args?: Subset<T, BuriedPlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuriedPlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuriedPlace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuriedPlaceAggregateArgs>(args: Subset<T, BuriedPlaceAggregateArgs>): Prisma.PrismaPromise<GetBuriedPlaceAggregateType<T>>

    /**
     * Group by BuriedPlace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuriedPlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuriedPlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuriedPlaceGroupByArgs['orderBy'] }
        : { orderBy?: BuriedPlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuriedPlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuriedPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuriedPlace model
   */
  readonly fields: BuriedPlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuriedPlace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuriedPlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    passingRecord<T extends PassingRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PassingRecordDefaultArgs<ExtArgs>>): Prisma__PassingRecordClient<$Result.GetResult<Prisma.$PassingRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuriedPlace model
   */
  interface BuriedPlaceFieldRefs {
    readonly id: FieldRef<"BuriedPlace", 'Int'>
    readonly location: FieldRef<"BuriedPlace", 'String'>
    readonly startDate: FieldRef<"BuriedPlace", 'DateTime'>
    readonly endDate: FieldRef<"BuriedPlace", 'DateTime'>
    readonly passingRecordId: FieldRef<"BuriedPlace", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BuriedPlace findUnique
   */
  export type BuriedPlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter, which BuriedPlace to fetch.
     */
    where: BuriedPlaceWhereUniqueInput
  }

  /**
   * BuriedPlace findUniqueOrThrow
   */
  export type BuriedPlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter, which BuriedPlace to fetch.
     */
    where: BuriedPlaceWhereUniqueInput
  }

  /**
   * BuriedPlace findFirst
   */
  export type BuriedPlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter, which BuriedPlace to fetch.
     */
    where?: BuriedPlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuriedPlaces to fetch.
     */
    orderBy?: BuriedPlaceOrderByWithRelationInput | BuriedPlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuriedPlaces.
     */
    cursor?: BuriedPlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuriedPlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuriedPlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuriedPlaces.
     */
    distinct?: BuriedPlaceScalarFieldEnum | BuriedPlaceScalarFieldEnum[]
  }

  /**
   * BuriedPlace findFirstOrThrow
   */
  export type BuriedPlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter, which BuriedPlace to fetch.
     */
    where?: BuriedPlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuriedPlaces to fetch.
     */
    orderBy?: BuriedPlaceOrderByWithRelationInput | BuriedPlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuriedPlaces.
     */
    cursor?: BuriedPlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuriedPlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuriedPlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuriedPlaces.
     */
    distinct?: BuriedPlaceScalarFieldEnum | BuriedPlaceScalarFieldEnum[]
  }

  /**
   * BuriedPlace findMany
   */
  export type BuriedPlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter, which BuriedPlaces to fetch.
     */
    where?: BuriedPlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuriedPlaces to fetch.
     */
    orderBy?: BuriedPlaceOrderByWithRelationInput | BuriedPlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuriedPlaces.
     */
    cursor?: BuriedPlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuriedPlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuriedPlaces.
     */
    skip?: number
    distinct?: BuriedPlaceScalarFieldEnum | BuriedPlaceScalarFieldEnum[]
  }

  /**
   * BuriedPlace create
   */
  export type BuriedPlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a BuriedPlace.
     */
    data: XOR<BuriedPlaceCreateInput, BuriedPlaceUncheckedCreateInput>
  }

  /**
   * BuriedPlace createMany
   */
  export type BuriedPlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuriedPlaces.
     */
    data: BuriedPlaceCreateManyInput | BuriedPlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BuriedPlace update
   */
  export type BuriedPlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a BuriedPlace.
     */
    data: XOR<BuriedPlaceUpdateInput, BuriedPlaceUncheckedUpdateInput>
    /**
     * Choose, which BuriedPlace to update.
     */
    where: BuriedPlaceWhereUniqueInput
  }

  /**
   * BuriedPlace updateMany
   */
  export type BuriedPlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuriedPlaces.
     */
    data: XOR<BuriedPlaceUpdateManyMutationInput, BuriedPlaceUncheckedUpdateManyInput>
    /**
     * Filter which BuriedPlaces to update
     */
    where?: BuriedPlaceWhereInput
    /**
     * Limit how many BuriedPlaces to update.
     */
    limit?: number
  }

  /**
   * BuriedPlace upsert
   */
  export type BuriedPlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the BuriedPlace to update in case it exists.
     */
    where: BuriedPlaceWhereUniqueInput
    /**
     * In case the BuriedPlace found by the `where` argument doesn't exist, create a new BuriedPlace with this data.
     */
    create: XOR<BuriedPlaceCreateInput, BuriedPlaceUncheckedCreateInput>
    /**
     * In case the BuriedPlace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuriedPlaceUpdateInput, BuriedPlaceUncheckedUpdateInput>
  }

  /**
   * BuriedPlace delete
   */
  export type BuriedPlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
    /**
     * Filter which BuriedPlace to delete.
     */
    where: BuriedPlaceWhereUniqueInput
  }

  /**
   * BuriedPlace deleteMany
   */
  export type BuriedPlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuriedPlaces to delete
     */
    where?: BuriedPlaceWhereInput
    /**
     * Limit how many BuriedPlaces to delete.
     */
    limit?: number
  }

  /**
   * BuriedPlace without action
   */
  export type BuriedPlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuriedPlace
     */
    select?: BuriedPlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuriedPlace
     */
    omit?: BuriedPlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuriedPlaceInclude<ExtArgs> | null
  }


  /**
   * Model PlaceOfOrigin
   */

  export type AggregatePlaceOfOrigin = {
    _count: PlaceOfOriginCountAggregateOutputType | null
    _avg: PlaceOfOriginAvgAggregateOutputType | null
    _sum: PlaceOfOriginSumAggregateOutputType | null
    _min: PlaceOfOriginMinAggregateOutputType | null
    _max: PlaceOfOriginMaxAggregateOutputType | null
  }

  export type PlaceOfOriginAvgAggregateOutputType = {
    id: number | null
  }

  export type PlaceOfOriginSumAggregateOutputType = {
    id: number | null
  }

  export type PlaceOfOriginMinAggregateOutputType = {
    id: number | null
    location: string | null
  }

  export type PlaceOfOriginMaxAggregateOutputType = {
    id: number | null
    location: string | null
  }

  export type PlaceOfOriginCountAggregateOutputType = {
    id: number
    location: number
    _all: number
  }


  export type PlaceOfOriginAvgAggregateInputType = {
    id?: true
  }

  export type PlaceOfOriginSumAggregateInputType = {
    id?: true
  }

  export type PlaceOfOriginMinAggregateInputType = {
    id?: true
    location?: true
  }

  export type PlaceOfOriginMaxAggregateInputType = {
    id?: true
    location?: true
  }

  export type PlaceOfOriginCountAggregateInputType = {
    id?: true
    location?: true
    _all?: true
  }

  export type PlaceOfOriginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceOfOrigin to aggregate.
     */
    where?: PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceOfOrigins to fetch.
     */
    orderBy?: PlaceOfOriginOrderByWithRelationInput | PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlaceOfOrigins
    **/
    _count?: true | PlaceOfOriginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceOfOriginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceOfOriginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceOfOriginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceOfOriginMaxAggregateInputType
  }

  export type GetPlaceOfOriginAggregateType<T extends PlaceOfOriginAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaceOfOrigin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaceOfOrigin[P]>
      : GetScalarType<T[P], AggregatePlaceOfOrigin[P]>
  }




  export type PlaceOfOriginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceOfOriginWhereInput
    orderBy?: PlaceOfOriginOrderByWithAggregationInput | PlaceOfOriginOrderByWithAggregationInput[]
    by: PlaceOfOriginScalarFieldEnum[] | PlaceOfOriginScalarFieldEnum
    having?: PlaceOfOriginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceOfOriginCountAggregateInputType | true
    _avg?: PlaceOfOriginAvgAggregateInputType
    _sum?: PlaceOfOriginSumAggregateInputType
    _min?: PlaceOfOriginMinAggregateInputType
    _max?: PlaceOfOriginMaxAggregateInputType
  }

  export type PlaceOfOriginGroupByOutputType = {
    id: number
    location: string
    _count: PlaceOfOriginCountAggregateOutputType | null
    _avg: PlaceOfOriginAvgAggregateOutputType | null
    _sum: PlaceOfOriginSumAggregateOutputType | null
    _min: PlaceOfOriginMinAggregateOutputType | null
    _max: PlaceOfOriginMaxAggregateOutputType | null
  }

  type GetPlaceOfOriginGroupByPayload<T extends PlaceOfOriginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceOfOriginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceOfOriginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceOfOriginGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceOfOriginGroupByOutputType[P]>
        }
      >
    >


  export type PlaceOfOriginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    familyMembers?: boolean | PlaceOfOrigin$familyMembersArgs<ExtArgs>
    _count?: boolean | PlaceOfOriginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placeOfOrigin"]>



  export type PlaceOfOriginSelectScalar = {
    id?: boolean
    location?: boolean
  }

  export type PlaceOfOriginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location", ExtArgs["result"]["placeOfOrigin"]>
  export type PlaceOfOriginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMembers?: boolean | PlaceOfOrigin$familyMembersArgs<ExtArgs>
    _count?: boolean | PlaceOfOriginCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlaceOfOriginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlaceOfOrigin"
    objects: {
      familyMembers: Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      location: string
    }, ExtArgs["result"]["placeOfOrigin"]>
    composites: {}
  }

  type PlaceOfOriginGetPayload<S extends boolean | null | undefined | PlaceOfOriginDefaultArgs> = $Result.GetResult<Prisma.$PlaceOfOriginPayload, S>

  type PlaceOfOriginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceOfOriginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceOfOriginCountAggregateInputType | true
    }

  export interface PlaceOfOriginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlaceOfOrigin'], meta: { name: 'PlaceOfOrigin' } }
    /**
     * Find zero or one PlaceOfOrigin that matches the filter.
     * @param {PlaceOfOriginFindUniqueArgs} args - Arguments to find a PlaceOfOrigin
     * @example
     * // Get one PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceOfOriginFindUniqueArgs>(args: SelectSubset<T, PlaceOfOriginFindUniqueArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlaceOfOrigin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceOfOriginFindUniqueOrThrowArgs} args - Arguments to find a PlaceOfOrigin
     * @example
     * // Get one PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceOfOriginFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceOfOrigin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginFindFirstArgs} args - Arguments to find a PlaceOfOrigin
     * @example
     * // Get one PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceOfOriginFindFirstArgs>(args?: SelectSubset<T, PlaceOfOriginFindFirstArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlaceOfOrigin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginFindFirstOrThrowArgs} args - Arguments to find a PlaceOfOrigin
     * @example
     * // Get one PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceOfOriginFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceOfOriginFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlaceOfOrigins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlaceOfOrigins
     * const placeOfOrigins = await prisma.placeOfOrigin.findMany()
     * 
     * // Get first 10 PlaceOfOrigins
     * const placeOfOrigins = await prisma.placeOfOrigin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeOfOriginWithIdOnly = await prisma.placeOfOrigin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceOfOriginFindManyArgs>(args?: SelectSubset<T, PlaceOfOriginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlaceOfOrigin.
     * @param {PlaceOfOriginCreateArgs} args - Arguments to create a PlaceOfOrigin.
     * @example
     * // Create one PlaceOfOrigin
     * const PlaceOfOrigin = await prisma.placeOfOrigin.create({
     *   data: {
     *     // ... data to create a PlaceOfOrigin
     *   }
     * })
     * 
     */
    create<T extends PlaceOfOriginCreateArgs>(args: SelectSubset<T, PlaceOfOriginCreateArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlaceOfOrigins.
     * @param {PlaceOfOriginCreateManyArgs} args - Arguments to create many PlaceOfOrigins.
     * @example
     * // Create many PlaceOfOrigins
     * const placeOfOrigin = await prisma.placeOfOrigin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceOfOriginCreateManyArgs>(args?: SelectSubset<T, PlaceOfOriginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PlaceOfOrigin.
     * @param {PlaceOfOriginDeleteArgs} args - Arguments to delete one PlaceOfOrigin.
     * @example
     * // Delete one PlaceOfOrigin
     * const PlaceOfOrigin = await prisma.placeOfOrigin.delete({
     *   where: {
     *     // ... filter to delete one PlaceOfOrigin
     *   }
     * })
     * 
     */
    delete<T extends PlaceOfOriginDeleteArgs>(args: SelectSubset<T, PlaceOfOriginDeleteArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlaceOfOrigin.
     * @param {PlaceOfOriginUpdateArgs} args - Arguments to update one PlaceOfOrigin.
     * @example
     * // Update one PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceOfOriginUpdateArgs>(args: SelectSubset<T, PlaceOfOriginUpdateArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlaceOfOrigins.
     * @param {PlaceOfOriginDeleteManyArgs} args - Arguments to filter PlaceOfOrigins to delete.
     * @example
     * // Delete a few PlaceOfOrigins
     * const { count } = await prisma.placeOfOrigin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceOfOriginDeleteManyArgs>(args?: SelectSubset<T, PlaceOfOriginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlaceOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlaceOfOrigins
     * const placeOfOrigin = await prisma.placeOfOrigin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceOfOriginUpdateManyArgs>(args: SelectSubset<T, PlaceOfOriginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlaceOfOrigin.
     * @param {PlaceOfOriginUpsertArgs} args - Arguments to update or create a PlaceOfOrigin.
     * @example
     * // Update or create a PlaceOfOrigin
     * const placeOfOrigin = await prisma.placeOfOrigin.upsert({
     *   create: {
     *     // ... data to create a PlaceOfOrigin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlaceOfOrigin we want to update
     *   }
     * })
     */
    upsert<T extends PlaceOfOriginUpsertArgs>(args: SelectSubset<T, PlaceOfOriginUpsertArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlaceOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginCountArgs} args - Arguments to filter PlaceOfOrigins to count.
     * @example
     * // Count the number of PlaceOfOrigins
     * const count = await prisma.placeOfOrigin.count({
     *   where: {
     *     // ... the filter for the PlaceOfOrigins we want to count
     *   }
     * })
    **/
    count<T extends PlaceOfOriginCountArgs>(
      args?: Subset<T, PlaceOfOriginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceOfOriginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlaceOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceOfOriginAggregateArgs>(args: Subset<T, PlaceOfOriginAggregateArgs>): Prisma.PrismaPromise<GetPlaceOfOriginAggregateType<T>>

    /**
     * Group by PlaceOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceOfOriginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceOfOriginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceOfOriginGroupByArgs['orderBy'] }
        : { orderBy?: PlaceOfOriginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceOfOriginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceOfOriginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlaceOfOrigin model
   */
  readonly fields: PlaceOfOriginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlaceOfOrigin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceOfOriginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMembers<T extends PlaceOfOrigin$familyMembersArgs<ExtArgs> = {}>(args?: Subset<T, PlaceOfOrigin$familyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlaceOfOrigin model
   */
  interface PlaceOfOriginFieldRefs {
    readonly id: FieldRef<"PlaceOfOrigin", 'Int'>
    readonly location: FieldRef<"PlaceOfOrigin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PlaceOfOrigin findUnique
   */
  export type PlaceOfOriginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which PlaceOfOrigin to fetch.
     */
    where: PlaceOfOriginWhereUniqueInput
  }

  /**
   * PlaceOfOrigin findUniqueOrThrow
   */
  export type PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which PlaceOfOrigin to fetch.
     */
    where: PlaceOfOriginWhereUniqueInput
  }

  /**
   * PlaceOfOrigin findFirst
   */
  export type PlaceOfOriginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which PlaceOfOrigin to fetch.
     */
    where?: PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceOfOrigins to fetch.
     */
    orderBy?: PlaceOfOriginOrderByWithRelationInput | PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceOfOrigins.
     */
    cursor?: PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceOfOrigins.
     */
    distinct?: PlaceOfOriginScalarFieldEnum | PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * PlaceOfOrigin findFirstOrThrow
   */
  export type PlaceOfOriginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which PlaceOfOrigin to fetch.
     */
    where?: PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceOfOrigins to fetch.
     */
    orderBy?: PlaceOfOriginOrderByWithRelationInput | PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlaceOfOrigins.
     */
    cursor?: PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlaceOfOrigins.
     */
    distinct?: PlaceOfOriginScalarFieldEnum | PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * PlaceOfOrigin findMany
   */
  export type PlaceOfOriginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which PlaceOfOrigins to fetch.
     */
    where?: PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlaceOfOrigins to fetch.
     */
    orderBy?: PlaceOfOriginOrderByWithRelationInput | PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlaceOfOrigins.
     */
    cursor?: PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlaceOfOrigins.
     */
    skip?: number
    distinct?: PlaceOfOriginScalarFieldEnum | PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * PlaceOfOrigin create
   */
  export type PlaceOfOriginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to create a PlaceOfOrigin.
     */
    data: XOR<PlaceOfOriginCreateInput, PlaceOfOriginUncheckedCreateInput>
  }

  /**
   * PlaceOfOrigin createMany
   */
  export type PlaceOfOriginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlaceOfOrigins.
     */
    data: PlaceOfOriginCreateManyInput | PlaceOfOriginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlaceOfOrigin update
   */
  export type PlaceOfOriginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to update a PlaceOfOrigin.
     */
    data: XOR<PlaceOfOriginUpdateInput, PlaceOfOriginUncheckedUpdateInput>
    /**
     * Choose, which PlaceOfOrigin to update.
     */
    where: PlaceOfOriginWhereUniqueInput
  }

  /**
   * PlaceOfOrigin updateMany
   */
  export type PlaceOfOriginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlaceOfOrigins.
     */
    data: XOR<PlaceOfOriginUpdateManyMutationInput, PlaceOfOriginUncheckedUpdateManyInput>
    /**
     * Filter which PlaceOfOrigins to update
     */
    where?: PlaceOfOriginWhereInput
    /**
     * Limit how many PlaceOfOrigins to update.
     */
    limit?: number
  }

  /**
   * PlaceOfOrigin upsert
   */
  export type PlaceOfOriginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The filter to search for the PlaceOfOrigin to update in case it exists.
     */
    where: PlaceOfOriginWhereUniqueInput
    /**
     * In case the PlaceOfOrigin found by the `where` argument doesn't exist, create a new PlaceOfOrigin with this data.
     */
    create: XOR<PlaceOfOriginCreateInput, PlaceOfOriginUncheckedCreateInput>
    /**
     * In case the PlaceOfOrigin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceOfOriginUpdateInput, PlaceOfOriginUncheckedUpdateInput>
  }

  /**
   * PlaceOfOrigin delete
   */
  export type PlaceOfOriginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter which PlaceOfOrigin to delete.
     */
    where: PlaceOfOriginWhereUniqueInput
  }

  /**
   * PlaceOfOrigin deleteMany
   */
  export type PlaceOfOriginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlaceOfOrigins to delete
     */
    where?: PlaceOfOriginWhereInput
    /**
     * Limit how many PlaceOfOrigins to delete.
     */
    limit?: number
  }

  /**
   * PlaceOfOrigin.familyMembers
   */
  export type PlaceOfOrigin$familyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMember_has_PlaceOfOriginScalarFieldEnum | FamilyMember_has_PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * PlaceOfOrigin without action
   */
  export type PlaceOfOriginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceOfOrigin
     */
    select?: PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlaceOfOrigin
     */
    omit?: PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceOfOriginInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMember_has_PlaceOfOrigin
   */

  export type AggregateFamilyMember_has_PlaceOfOrigin = {
    _count: FamilyMember_has_PlaceOfOriginCountAggregateOutputType | null
    _avg: FamilyMember_has_PlaceOfOriginAvgAggregateOutputType | null
    _sum: FamilyMember_has_PlaceOfOriginSumAggregateOutputType | null
    _min: FamilyMember_has_PlaceOfOriginMinAggregateOutputType | null
    _max: FamilyMember_has_PlaceOfOriginMaxAggregateOutputType | null
  }

  export type FamilyMember_has_PlaceOfOriginAvgAggregateOutputType = {
    familyMemberId: number | null
    placeOfOriginId: number | null
  }

  export type FamilyMember_has_PlaceOfOriginSumAggregateOutputType = {
    familyMemberId: number | null
    placeOfOriginId: number | null
  }

  export type FamilyMember_has_PlaceOfOriginMinAggregateOutputType = {
    familyMemberId: number | null
    placeOfOriginId: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type FamilyMember_has_PlaceOfOriginMaxAggregateOutputType = {
    familyMemberId: number | null
    placeOfOriginId: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type FamilyMember_has_PlaceOfOriginCountAggregateOutputType = {
    familyMemberId: number
    placeOfOriginId: number
    startDate: number
    endDate: number
    _all: number
  }


  export type FamilyMember_has_PlaceOfOriginAvgAggregateInputType = {
    familyMemberId?: true
    placeOfOriginId?: true
  }

  export type FamilyMember_has_PlaceOfOriginSumAggregateInputType = {
    familyMemberId?: true
    placeOfOriginId?: true
  }

  export type FamilyMember_has_PlaceOfOriginMinAggregateInputType = {
    familyMemberId?: true
    placeOfOriginId?: true
    startDate?: true
    endDate?: true
  }

  export type FamilyMember_has_PlaceOfOriginMaxAggregateInputType = {
    familyMemberId?: true
    placeOfOriginId?: true
    startDate?: true
    endDate?: true
  }

  export type FamilyMember_has_PlaceOfOriginCountAggregateInputType = {
    familyMemberId?: true
    placeOfOriginId?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type FamilyMember_has_PlaceOfOriginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember_has_PlaceOfOrigin to aggregate.
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMember_has_PlaceOfOrigins to fetch.
     */
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMember_has_PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMember_has_PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMember_has_PlaceOfOrigins
    **/
    _count?: true | FamilyMember_has_PlaceOfOriginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyMember_has_PlaceOfOriginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyMember_has_PlaceOfOriginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMember_has_PlaceOfOriginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMember_has_PlaceOfOriginMaxAggregateInputType
  }

  export type GetFamilyMember_has_PlaceOfOriginAggregateType<T extends FamilyMember_has_PlaceOfOriginAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMember_has_PlaceOfOrigin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMember_has_PlaceOfOrigin[P]>
      : GetScalarType<T[P], AggregateFamilyMember_has_PlaceOfOrigin[P]>
  }




  export type FamilyMember_has_PlaceOfOriginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithAggregationInput | FamilyMember_has_PlaceOfOriginOrderByWithAggregationInput[]
    by: FamilyMember_has_PlaceOfOriginScalarFieldEnum[] | FamilyMember_has_PlaceOfOriginScalarFieldEnum
    having?: FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMember_has_PlaceOfOriginCountAggregateInputType | true
    _avg?: FamilyMember_has_PlaceOfOriginAvgAggregateInputType
    _sum?: FamilyMember_has_PlaceOfOriginSumAggregateInputType
    _min?: FamilyMember_has_PlaceOfOriginMinAggregateInputType
    _max?: FamilyMember_has_PlaceOfOriginMaxAggregateInputType
  }

  export type FamilyMember_has_PlaceOfOriginGroupByOutputType = {
    familyMemberId: number
    placeOfOriginId: number
    startDate: Date | null
    endDate: Date | null
    _count: FamilyMember_has_PlaceOfOriginCountAggregateOutputType | null
    _avg: FamilyMember_has_PlaceOfOriginAvgAggregateOutputType | null
    _sum: FamilyMember_has_PlaceOfOriginSumAggregateOutputType | null
    _min: FamilyMember_has_PlaceOfOriginMinAggregateOutputType | null
    _max: FamilyMember_has_PlaceOfOriginMaxAggregateOutputType | null
  }

  type GetFamilyMember_has_PlaceOfOriginGroupByPayload<T extends FamilyMember_has_PlaceOfOriginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMember_has_PlaceOfOriginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMember_has_PlaceOfOriginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMember_has_PlaceOfOriginGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMember_has_PlaceOfOriginGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMember_has_PlaceOfOriginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    familyMemberId?: boolean
    placeOfOriginId?: boolean
    startDate?: boolean
    endDate?: boolean
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    placeOfOrigin?: boolean | PlaceOfOriginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember_has_PlaceOfOrigin"]>



  export type FamilyMember_has_PlaceOfOriginSelectScalar = {
    familyMemberId?: boolean
    placeOfOriginId?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type FamilyMember_has_PlaceOfOriginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"familyMemberId" | "placeOfOriginId" | "startDate" | "endDate", ExtArgs["result"]["familyMember_has_PlaceOfOrigin"]>
  export type FamilyMember_has_PlaceOfOriginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    placeOfOrigin?: boolean | PlaceOfOriginDefaultArgs<ExtArgs>
  }

  export type $FamilyMember_has_PlaceOfOriginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMember_has_PlaceOfOrigin"
    objects: {
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
      placeOfOrigin: Prisma.$PlaceOfOriginPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      familyMemberId: number
      placeOfOriginId: number
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["familyMember_has_PlaceOfOrigin"]>
    composites: {}
  }

  type FamilyMember_has_PlaceOfOriginGetPayload<S extends boolean | null | undefined | FamilyMember_has_PlaceOfOriginDefaultArgs> = $Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload, S>

  type FamilyMember_has_PlaceOfOriginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMember_has_PlaceOfOriginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMember_has_PlaceOfOriginCountAggregateInputType | true
    }

  export interface FamilyMember_has_PlaceOfOriginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMember_has_PlaceOfOrigin'], meta: { name: 'FamilyMember_has_PlaceOfOrigin' } }
    /**
     * Find zero or one FamilyMember_has_PlaceOfOrigin that matches the filter.
     * @param {FamilyMember_has_PlaceOfOriginFindUniqueArgs} args - Arguments to find a FamilyMember_has_PlaceOfOrigin
     * @example
     * // Get one FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMember_has_PlaceOfOriginFindUniqueArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginFindUniqueArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMember_has_PlaceOfOrigin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMember_has_PlaceOfOriginFindUniqueOrThrowArgs} args - Arguments to find a FamilyMember_has_PlaceOfOrigin
     * @example
     * // Get one FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMember_has_PlaceOfOriginFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember_has_PlaceOfOrigin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginFindFirstArgs} args - Arguments to find a FamilyMember_has_PlaceOfOrigin
     * @example
     * // Get one FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMember_has_PlaceOfOriginFindFirstArgs>(args?: SelectSubset<T, FamilyMember_has_PlaceOfOriginFindFirstArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember_has_PlaceOfOrigin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginFindFirstOrThrowArgs} args - Arguments to find a FamilyMember_has_PlaceOfOrigin
     * @example
     * // Get one FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMember_has_PlaceOfOriginFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMember_has_PlaceOfOriginFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMember_has_PlaceOfOrigins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMember_has_PlaceOfOrigins
     * const familyMember_has_PlaceOfOrigins = await prisma.familyMember_has_PlaceOfOrigin.findMany()
     * 
     * // Get first 10 FamilyMember_has_PlaceOfOrigins
     * const familyMember_has_PlaceOfOrigins = await prisma.familyMember_has_PlaceOfOrigin.findMany({ take: 10 })
     * 
     * // Only select the `familyMemberId`
     * const familyMember_has_PlaceOfOriginWithFamilyMemberIdOnly = await prisma.familyMember_has_PlaceOfOrigin.findMany({ select: { familyMemberId: true } })
     * 
     */
    findMany<T extends FamilyMember_has_PlaceOfOriginFindManyArgs>(args?: SelectSubset<T, FamilyMember_has_PlaceOfOriginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMember_has_PlaceOfOrigin.
     * @param {FamilyMember_has_PlaceOfOriginCreateArgs} args - Arguments to create a FamilyMember_has_PlaceOfOrigin.
     * @example
     * // Create one FamilyMember_has_PlaceOfOrigin
     * const FamilyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.create({
     *   data: {
     *     // ... data to create a FamilyMember_has_PlaceOfOrigin
     *   }
     * })
     * 
     */
    create<T extends FamilyMember_has_PlaceOfOriginCreateArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginCreateArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMember_has_PlaceOfOrigins.
     * @param {FamilyMember_has_PlaceOfOriginCreateManyArgs} args - Arguments to create many FamilyMember_has_PlaceOfOrigins.
     * @example
     * // Create many FamilyMember_has_PlaceOfOrigins
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMember_has_PlaceOfOriginCreateManyArgs>(args?: SelectSubset<T, FamilyMember_has_PlaceOfOriginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyMember_has_PlaceOfOrigin.
     * @param {FamilyMember_has_PlaceOfOriginDeleteArgs} args - Arguments to delete one FamilyMember_has_PlaceOfOrigin.
     * @example
     * // Delete one FamilyMember_has_PlaceOfOrigin
     * const FamilyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.delete({
     *   where: {
     *     // ... filter to delete one FamilyMember_has_PlaceOfOrigin
     *   }
     * })
     * 
     */
    delete<T extends FamilyMember_has_PlaceOfOriginDeleteArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginDeleteArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMember_has_PlaceOfOrigin.
     * @param {FamilyMember_has_PlaceOfOriginUpdateArgs} args - Arguments to update one FamilyMember_has_PlaceOfOrigin.
     * @example
     * // Update one FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMember_has_PlaceOfOriginUpdateArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginUpdateArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMember_has_PlaceOfOrigins.
     * @param {FamilyMember_has_PlaceOfOriginDeleteManyArgs} args - Arguments to filter FamilyMember_has_PlaceOfOrigins to delete.
     * @example
     * // Delete a few FamilyMember_has_PlaceOfOrigins
     * const { count } = await prisma.familyMember_has_PlaceOfOrigin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMember_has_PlaceOfOriginDeleteManyArgs>(args?: SelectSubset<T, FamilyMember_has_PlaceOfOriginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMember_has_PlaceOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMember_has_PlaceOfOrigins
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMember_has_PlaceOfOriginUpdateManyArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyMember_has_PlaceOfOrigin.
     * @param {FamilyMember_has_PlaceOfOriginUpsertArgs} args - Arguments to update or create a FamilyMember_has_PlaceOfOrigin.
     * @example
     * // Update or create a FamilyMember_has_PlaceOfOrigin
     * const familyMember_has_PlaceOfOrigin = await prisma.familyMember_has_PlaceOfOrigin.upsert({
     *   create: {
     *     // ... data to create a FamilyMember_has_PlaceOfOrigin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMember_has_PlaceOfOrigin we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMember_has_PlaceOfOriginUpsertArgs>(args: SelectSubset<T, FamilyMember_has_PlaceOfOriginUpsertArgs<ExtArgs>>): Prisma__FamilyMember_has_PlaceOfOriginClient<$Result.GetResult<Prisma.$FamilyMember_has_PlaceOfOriginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMember_has_PlaceOfOrigins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginCountArgs} args - Arguments to filter FamilyMember_has_PlaceOfOrigins to count.
     * @example
     * // Count the number of FamilyMember_has_PlaceOfOrigins
     * const count = await prisma.familyMember_has_PlaceOfOrigin.count({
     *   where: {
     *     // ... the filter for the FamilyMember_has_PlaceOfOrigins we want to count
     *   }
     * })
    **/
    count<T extends FamilyMember_has_PlaceOfOriginCountArgs>(
      args?: Subset<T, FamilyMember_has_PlaceOfOriginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMember_has_PlaceOfOriginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMember_has_PlaceOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMember_has_PlaceOfOriginAggregateArgs>(args: Subset<T, FamilyMember_has_PlaceOfOriginAggregateArgs>): Prisma.PrismaPromise<GetFamilyMember_has_PlaceOfOriginAggregateType<T>>

    /**
     * Group by FamilyMember_has_PlaceOfOrigin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMember_has_PlaceOfOriginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMember_has_PlaceOfOriginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMember_has_PlaceOfOriginGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMember_has_PlaceOfOriginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMember_has_PlaceOfOriginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMember_has_PlaceOfOriginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMember_has_PlaceOfOrigin model
   */
  readonly fields: FamilyMember_has_PlaceOfOriginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMember_has_PlaceOfOrigin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMember_has_PlaceOfOriginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    placeOfOrigin<T extends PlaceOfOriginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaceOfOriginDefaultArgs<ExtArgs>>): Prisma__PlaceOfOriginClient<$Result.GetResult<Prisma.$PlaceOfOriginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMember_has_PlaceOfOrigin model
   */
  interface FamilyMember_has_PlaceOfOriginFieldRefs {
    readonly familyMemberId: FieldRef<"FamilyMember_has_PlaceOfOrigin", 'Int'>
    readonly placeOfOriginId: FieldRef<"FamilyMember_has_PlaceOfOrigin", 'Int'>
    readonly startDate: FieldRef<"FamilyMember_has_PlaceOfOrigin", 'DateTime'>
    readonly endDate: FieldRef<"FamilyMember_has_PlaceOfOrigin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMember_has_PlaceOfOrigin findUnique
   */
  export type FamilyMember_has_PlaceOfOriginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember_has_PlaceOfOrigin to fetch.
     */
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
  }

  /**
   * FamilyMember_has_PlaceOfOrigin findUniqueOrThrow
   */
  export type FamilyMember_has_PlaceOfOriginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember_has_PlaceOfOrigin to fetch.
     */
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
  }

  /**
   * FamilyMember_has_PlaceOfOrigin findFirst
   */
  export type FamilyMember_has_PlaceOfOriginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember_has_PlaceOfOrigin to fetch.
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMember_has_PlaceOfOrigins to fetch.
     */
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMember_has_PlaceOfOrigins.
     */
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMember_has_PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMember_has_PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMember_has_PlaceOfOrigins.
     */
    distinct?: FamilyMember_has_PlaceOfOriginScalarFieldEnum | FamilyMember_has_PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * FamilyMember_has_PlaceOfOrigin findFirstOrThrow
   */
  export type FamilyMember_has_PlaceOfOriginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember_has_PlaceOfOrigin to fetch.
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMember_has_PlaceOfOrigins to fetch.
     */
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMember_has_PlaceOfOrigins.
     */
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMember_has_PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMember_has_PlaceOfOrigins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMember_has_PlaceOfOrigins.
     */
    distinct?: FamilyMember_has_PlaceOfOriginScalarFieldEnum | FamilyMember_has_PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * FamilyMember_has_PlaceOfOrigin findMany
   */
  export type FamilyMember_has_PlaceOfOriginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember_has_PlaceOfOrigins to fetch.
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMember_has_PlaceOfOrigins to fetch.
     */
    orderBy?: FamilyMember_has_PlaceOfOriginOrderByWithRelationInput | FamilyMember_has_PlaceOfOriginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMember_has_PlaceOfOrigins.
     */
    cursor?: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMember_has_PlaceOfOrigins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMember_has_PlaceOfOrigins.
     */
    skip?: number
    distinct?: FamilyMember_has_PlaceOfOriginScalarFieldEnum | FamilyMember_has_PlaceOfOriginScalarFieldEnum[]
  }

  /**
   * FamilyMember_has_PlaceOfOrigin create
   */
  export type FamilyMember_has_PlaceOfOriginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMember_has_PlaceOfOrigin.
     */
    data: XOR<FamilyMember_has_PlaceOfOriginCreateInput, FamilyMember_has_PlaceOfOriginUncheckedCreateInput>
  }

  /**
   * FamilyMember_has_PlaceOfOrigin createMany
   */
  export type FamilyMember_has_PlaceOfOriginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMember_has_PlaceOfOrigins.
     */
    data: FamilyMember_has_PlaceOfOriginCreateManyInput | FamilyMember_has_PlaceOfOriginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMember_has_PlaceOfOrigin update
   */
  export type FamilyMember_has_PlaceOfOriginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMember_has_PlaceOfOrigin.
     */
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateInput>
    /**
     * Choose, which FamilyMember_has_PlaceOfOrigin to update.
     */
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
  }

  /**
   * FamilyMember_has_PlaceOfOrigin updateMany
   */
  export type FamilyMember_has_PlaceOfOriginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMember_has_PlaceOfOrigins.
     */
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateManyMutationInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMember_has_PlaceOfOrigins to update
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * Limit how many FamilyMember_has_PlaceOfOrigins to update.
     */
    limit?: number
  }

  /**
   * FamilyMember_has_PlaceOfOrigin upsert
   */
  export type FamilyMember_has_PlaceOfOriginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMember_has_PlaceOfOrigin to update in case it exists.
     */
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    /**
     * In case the FamilyMember_has_PlaceOfOrigin found by the `where` argument doesn't exist, create a new FamilyMember_has_PlaceOfOrigin with this data.
     */
    create: XOR<FamilyMember_has_PlaceOfOriginCreateInput, FamilyMember_has_PlaceOfOriginUncheckedCreateInput>
    /**
     * In case the FamilyMember_has_PlaceOfOrigin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMember_has_PlaceOfOriginUpdateInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateInput>
  }

  /**
   * FamilyMember_has_PlaceOfOrigin delete
   */
  export type FamilyMember_has_PlaceOfOriginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
    /**
     * Filter which FamilyMember_has_PlaceOfOrigin to delete.
     */
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
  }

  /**
   * FamilyMember_has_PlaceOfOrigin deleteMany
   */
  export type FamilyMember_has_PlaceOfOriginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember_has_PlaceOfOrigins to delete
     */
    where?: FamilyMember_has_PlaceOfOriginWhereInput
    /**
     * Limit how many FamilyMember_has_PlaceOfOrigins to delete.
     */
    limit?: number
  }

  /**
   * FamilyMember_has_PlaceOfOrigin without action
   */
  export type FamilyMember_has_PlaceOfOriginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember_has_PlaceOfOrigin
     */
    select?: FamilyMember_has_PlaceOfOriginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember_has_PlaceOfOrigin
     */
    omit?: FamilyMember_has_PlaceOfOriginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMember_has_PlaceOfOriginInclude<ExtArgs> | null
  }


  /**
   * Model SpouseRelationship
   */

  export type AggregateSpouseRelationship = {
    _count: SpouseRelationshipCountAggregateOutputType | null
    _avg: SpouseRelationshipAvgAggregateOutputType | null
    _sum: SpouseRelationshipSumAggregateOutputType | null
    _min: SpouseRelationshipMinAggregateOutputType | null
    _max: SpouseRelationshipMaxAggregateOutputType | null
  }

  export type SpouseRelationshipAvgAggregateOutputType = {
    id: number | null
    familyMember1Id: number | null
    familyMember2Id: number | null
  }

  export type SpouseRelationshipSumAggregateOutputType = {
    id: number | null
    familyMember1Id: number | null
    familyMember2Id: number | null
  }

  export type SpouseRelationshipMinAggregateOutputType = {
    id: number | null
    marriageDate: Date | null
    divorceDate: Date | null
    familyMember1Id: number | null
    familyMember2Id: number | null
  }

  export type SpouseRelationshipMaxAggregateOutputType = {
    id: number | null
    marriageDate: Date | null
    divorceDate: Date | null
    familyMember1Id: number | null
    familyMember2Id: number | null
  }

  export type SpouseRelationshipCountAggregateOutputType = {
    id: number
    marriageDate: number
    divorceDate: number
    familyMember1Id: number
    familyMember2Id: number
    _all: number
  }


  export type SpouseRelationshipAvgAggregateInputType = {
    id?: true
    familyMember1Id?: true
    familyMember2Id?: true
  }

  export type SpouseRelationshipSumAggregateInputType = {
    id?: true
    familyMember1Id?: true
    familyMember2Id?: true
  }

  export type SpouseRelationshipMinAggregateInputType = {
    id?: true
    marriageDate?: true
    divorceDate?: true
    familyMember1Id?: true
    familyMember2Id?: true
  }

  export type SpouseRelationshipMaxAggregateInputType = {
    id?: true
    marriageDate?: true
    divorceDate?: true
    familyMember1Id?: true
    familyMember2Id?: true
  }

  export type SpouseRelationshipCountAggregateInputType = {
    id?: true
    marriageDate?: true
    divorceDate?: true
    familyMember1Id?: true
    familyMember2Id?: true
    _all?: true
  }

  export type SpouseRelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpouseRelationship to aggregate.
     */
    where?: SpouseRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpouseRelationships to fetch.
     */
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpouseRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpouseRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpouseRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpouseRelationships
    **/
    _count?: true | SpouseRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpouseRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpouseRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpouseRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpouseRelationshipMaxAggregateInputType
  }

  export type GetSpouseRelationshipAggregateType<T extends SpouseRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateSpouseRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpouseRelationship[P]>
      : GetScalarType<T[P], AggregateSpouseRelationship[P]>
  }




  export type SpouseRelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpouseRelationshipWhereInput
    orderBy?: SpouseRelationshipOrderByWithAggregationInput | SpouseRelationshipOrderByWithAggregationInput[]
    by: SpouseRelationshipScalarFieldEnum[] | SpouseRelationshipScalarFieldEnum
    having?: SpouseRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpouseRelationshipCountAggregateInputType | true
    _avg?: SpouseRelationshipAvgAggregateInputType
    _sum?: SpouseRelationshipSumAggregateInputType
    _min?: SpouseRelationshipMinAggregateInputType
    _max?: SpouseRelationshipMaxAggregateInputType
  }

  export type SpouseRelationshipGroupByOutputType = {
    id: number
    marriageDate: Date
    divorceDate: Date | null
    familyMember1Id: number
    familyMember2Id: number
    _count: SpouseRelationshipCountAggregateOutputType | null
    _avg: SpouseRelationshipAvgAggregateOutputType | null
    _sum: SpouseRelationshipSumAggregateOutputType | null
    _min: SpouseRelationshipMinAggregateOutputType | null
    _max: SpouseRelationshipMaxAggregateOutputType | null
  }

  type GetSpouseRelationshipGroupByPayload<T extends SpouseRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpouseRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpouseRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpouseRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], SpouseRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type SpouseRelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marriageDate?: boolean
    divorceDate?: boolean
    familyMember1Id?: boolean
    familyMember2Id?: boolean
    familyMember1?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    familyMember2?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spouseRelationship"]>



  export type SpouseRelationshipSelectScalar = {
    id?: boolean
    marriageDate?: boolean
    divorceDate?: boolean
    familyMember1Id?: boolean
    familyMember2Id?: boolean
  }

  export type SpouseRelationshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marriageDate" | "divorceDate" | "familyMember1Id" | "familyMember2Id", ExtArgs["result"]["spouseRelationship"]>
  export type SpouseRelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember1?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    familyMember2?: boolean | FamilyMemberDefaultArgs<ExtArgs>
  }

  export type $SpouseRelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpouseRelationship"
    objects: {
      familyMember1: Prisma.$FamilyMemberPayload<ExtArgs>
      familyMember2: Prisma.$FamilyMemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      marriageDate: Date
      divorceDate: Date | null
      familyMember1Id: number
      familyMember2Id: number
    }, ExtArgs["result"]["spouseRelationship"]>
    composites: {}
  }

  type SpouseRelationshipGetPayload<S extends boolean | null | undefined | SpouseRelationshipDefaultArgs> = $Result.GetResult<Prisma.$SpouseRelationshipPayload, S>

  type SpouseRelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpouseRelationshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpouseRelationshipCountAggregateInputType | true
    }

  export interface SpouseRelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpouseRelationship'], meta: { name: 'SpouseRelationship' } }
    /**
     * Find zero or one SpouseRelationship that matches the filter.
     * @param {SpouseRelationshipFindUniqueArgs} args - Arguments to find a SpouseRelationship
     * @example
     * // Get one SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpouseRelationshipFindUniqueArgs>(args: SelectSubset<T, SpouseRelationshipFindUniqueArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpouseRelationship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpouseRelationshipFindUniqueOrThrowArgs} args - Arguments to find a SpouseRelationship
     * @example
     * // Get one SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpouseRelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, SpouseRelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpouseRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipFindFirstArgs} args - Arguments to find a SpouseRelationship
     * @example
     * // Get one SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpouseRelationshipFindFirstArgs>(args?: SelectSubset<T, SpouseRelationshipFindFirstArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpouseRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipFindFirstOrThrowArgs} args - Arguments to find a SpouseRelationship
     * @example
     * // Get one SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpouseRelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, SpouseRelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpouseRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpouseRelationships
     * const spouseRelationships = await prisma.spouseRelationship.findMany()
     * 
     * // Get first 10 SpouseRelationships
     * const spouseRelationships = await prisma.spouseRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spouseRelationshipWithIdOnly = await prisma.spouseRelationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpouseRelationshipFindManyArgs>(args?: SelectSubset<T, SpouseRelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpouseRelationship.
     * @param {SpouseRelationshipCreateArgs} args - Arguments to create a SpouseRelationship.
     * @example
     * // Create one SpouseRelationship
     * const SpouseRelationship = await prisma.spouseRelationship.create({
     *   data: {
     *     // ... data to create a SpouseRelationship
     *   }
     * })
     * 
     */
    create<T extends SpouseRelationshipCreateArgs>(args: SelectSubset<T, SpouseRelationshipCreateArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpouseRelationships.
     * @param {SpouseRelationshipCreateManyArgs} args - Arguments to create many SpouseRelationships.
     * @example
     * // Create many SpouseRelationships
     * const spouseRelationship = await prisma.spouseRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpouseRelationshipCreateManyArgs>(args?: SelectSubset<T, SpouseRelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SpouseRelationship.
     * @param {SpouseRelationshipDeleteArgs} args - Arguments to delete one SpouseRelationship.
     * @example
     * // Delete one SpouseRelationship
     * const SpouseRelationship = await prisma.spouseRelationship.delete({
     *   where: {
     *     // ... filter to delete one SpouseRelationship
     *   }
     * })
     * 
     */
    delete<T extends SpouseRelationshipDeleteArgs>(args: SelectSubset<T, SpouseRelationshipDeleteArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpouseRelationship.
     * @param {SpouseRelationshipUpdateArgs} args - Arguments to update one SpouseRelationship.
     * @example
     * // Update one SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpouseRelationshipUpdateArgs>(args: SelectSubset<T, SpouseRelationshipUpdateArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpouseRelationships.
     * @param {SpouseRelationshipDeleteManyArgs} args - Arguments to filter SpouseRelationships to delete.
     * @example
     * // Delete a few SpouseRelationships
     * const { count } = await prisma.spouseRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpouseRelationshipDeleteManyArgs>(args?: SelectSubset<T, SpouseRelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpouseRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpouseRelationships
     * const spouseRelationship = await prisma.spouseRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpouseRelationshipUpdateManyArgs>(args: SelectSubset<T, SpouseRelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpouseRelationship.
     * @param {SpouseRelationshipUpsertArgs} args - Arguments to update or create a SpouseRelationship.
     * @example
     * // Update or create a SpouseRelationship
     * const spouseRelationship = await prisma.spouseRelationship.upsert({
     *   create: {
     *     // ... data to create a SpouseRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpouseRelationship we want to update
     *   }
     * })
     */
    upsert<T extends SpouseRelationshipUpsertArgs>(args: SelectSubset<T, SpouseRelationshipUpsertArgs<ExtArgs>>): Prisma__SpouseRelationshipClient<$Result.GetResult<Prisma.$SpouseRelationshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpouseRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipCountArgs} args - Arguments to filter SpouseRelationships to count.
     * @example
     * // Count the number of SpouseRelationships
     * const count = await prisma.spouseRelationship.count({
     *   where: {
     *     // ... the filter for the SpouseRelationships we want to count
     *   }
     * })
    **/
    count<T extends SpouseRelationshipCountArgs>(
      args?: Subset<T, SpouseRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpouseRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpouseRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpouseRelationshipAggregateArgs>(args: Subset<T, SpouseRelationshipAggregateArgs>): Prisma.PrismaPromise<GetSpouseRelationshipAggregateType<T>>

    /**
     * Group by SpouseRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpouseRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpouseRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpouseRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: SpouseRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpouseRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpouseRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpouseRelationship model
   */
  readonly fields: SpouseRelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpouseRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpouseRelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember1<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyMember2<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpouseRelationship model
   */
  interface SpouseRelationshipFieldRefs {
    readonly id: FieldRef<"SpouseRelationship", 'Int'>
    readonly marriageDate: FieldRef<"SpouseRelationship", 'DateTime'>
    readonly divorceDate: FieldRef<"SpouseRelationship", 'DateTime'>
    readonly familyMember1Id: FieldRef<"SpouseRelationship", 'Int'>
    readonly familyMember2Id: FieldRef<"SpouseRelationship", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpouseRelationship findUnique
   */
  export type SpouseRelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which SpouseRelationship to fetch.
     */
    where: SpouseRelationshipWhereUniqueInput
  }

  /**
   * SpouseRelationship findUniqueOrThrow
   */
  export type SpouseRelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which SpouseRelationship to fetch.
     */
    where: SpouseRelationshipWhereUniqueInput
  }

  /**
   * SpouseRelationship findFirst
   */
  export type SpouseRelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which SpouseRelationship to fetch.
     */
    where?: SpouseRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpouseRelationships to fetch.
     */
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpouseRelationships.
     */
    cursor?: SpouseRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpouseRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpouseRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpouseRelationships.
     */
    distinct?: SpouseRelationshipScalarFieldEnum | SpouseRelationshipScalarFieldEnum[]
  }

  /**
   * SpouseRelationship findFirstOrThrow
   */
  export type SpouseRelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which SpouseRelationship to fetch.
     */
    where?: SpouseRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpouseRelationships to fetch.
     */
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpouseRelationships.
     */
    cursor?: SpouseRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpouseRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpouseRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpouseRelationships.
     */
    distinct?: SpouseRelationshipScalarFieldEnum | SpouseRelationshipScalarFieldEnum[]
  }

  /**
   * SpouseRelationship findMany
   */
  export type SpouseRelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which SpouseRelationships to fetch.
     */
    where?: SpouseRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpouseRelationships to fetch.
     */
    orderBy?: SpouseRelationshipOrderByWithRelationInput | SpouseRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpouseRelationships.
     */
    cursor?: SpouseRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpouseRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpouseRelationships.
     */
    skip?: number
    distinct?: SpouseRelationshipScalarFieldEnum | SpouseRelationshipScalarFieldEnum[]
  }

  /**
   * SpouseRelationship create
   */
  export type SpouseRelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a SpouseRelationship.
     */
    data: XOR<SpouseRelationshipCreateInput, SpouseRelationshipUncheckedCreateInput>
  }

  /**
   * SpouseRelationship createMany
   */
  export type SpouseRelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpouseRelationships.
     */
    data: SpouseRelationshipCreateManyInput | SpouseRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpouseRelationship update
   */
  export type SpouseRelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a SpouseRelationship.
     */
    data: XOR<SpouseRelationshipUpdateInput, SpouseRelationshipUncheckedUpdateInput>
    /**
     * Choose, which SpouseRelationship to update.
     */
    where: SpouseRelationshipWhereUniqueInput
  }

  /**
   * SpouseRelationship updateMany
   */
  export type SpouseRelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpouseRelationships.
     */
    data: XOR<SpouseRelationshipUpdateManyMutationInput, SpouseRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which SpouseRelationships to update
     */
    where?: SpouseRelationshipWhereInput
    /**
     * Limit how many SpouseRelationships to update.
     */
    limit?: number
  }

  /**
   * SpouseRelationship upsert
   */
  export type SpouseRelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the SpouseRelationship to update in case it exists.
     */
    where: SpouseRelationshipWhereUniqueInput
    /**
     * In case the SpouseRelationship found by the `where` argument doesn't exist, create a new SpouseRelationship with this data.
     */
    create: XOR<SpouseRelationshipCreateInput, SpouseRelationshipUncheckedCreateInput>
    /**
     * In case the SpouseRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpouseRelationshipUpdateInput, SpouseRelationshipUncheckedUpdateInput>
  }

  /**
   * SpouseRelationship delete
   */
  export type SpouseRelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
    /**
     * Filter which SpouseRelationship to delete.
     */
    where: SpouseRelationshipWhereUniqueInput
  }

  /**
   * SpouseRelationship deleteMany
   */
  export type SpouseRelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpouseRelationships to delete
     */
    where?: SpouseRelationshipWhereInput
    /**
     * Limit how many SpouseRelationships to delete.
     */
    limit?: number
  }

  /**
   * SpouseRelationship without action
   */
  export type SpouseRelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpouseRelationship
     */
    select?: SpouseRelationshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpouseRelationship
     */
    omit?: SpouseRelationshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpouseRelationshipInclude<ExtArgs> | null
  }


  /**
   * Model GuestEditor
   */

  export type AggregateGuestEditor = {
    _count: GuestEditorCountAggregateOutputType | null
    _avg: GuestEditorAvgAggregateOutputType | null
    _sum: GuestEditorSumAggregateOutputType | null
    _min: GuestEditorMinAggregateOutputType | null
    _max: GuestEditorMaxAggregateOutputType | null
  }

  export type GuestEditorAvgAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
    familyTreeId: number | null
  }

  export type GuestEditorSumAggregateOutputType = {
    id: number | null
    familyMemberId: number | null
    familyTreeId: number | null
  }

  export type GuestEditorMinAggregateOutputType = {
    id: number | null
    accessCode: string | null
    createDate: Date | null
    familyMemberId: number | null
    familyTreeId: number | null
  }

  export type GuestEditorMaxAggregateOutputType = {
    id: number | null
    accessCode: string | null
    createDate: Date | null
    familyMemberId: number | null
    familyTreeId: number | null
  }

  export type GuestEditorCountAggregateOutputType = {
    id: number
    accessCode: number
    createDate: number
    familyMemberId: number
    familyTreeId: number
    _all: number
  }


  export type GuestEditorAvgAggregateInputType = {
    id?: true
    familyMemberId?: true
    familyTreeId?: true
  }

  export type GuestEditorSumAggregateInputType = {
    id?: true
    familyMemberId?: true
    familyTreeId?: true
  }

  export type GuestEditorMinAggregateInputType = {
    id?: true
    accessCode?: true
    createDate?: true
    familyMemberId?: true
    familyTreeId?: true
  }

  export type GuestEditorMaxAggregateInputType = {
    id?: true
    accessCode?: true
    createDate?: true
    familyMemberId?: true
    familyTreeId?: true
  }

  export type GuestEditorCountAggregateInputType = {
    id?: true
    accessCode?: true
    createDate?: true
    familyMemberId?: true
    familyTreeId?: true
    _all?: true
  }

  export type GuestEditorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuestEditor to aggregate.
     */
    where?: GuestEditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestEditors to fetch.
     */
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GuestEditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GuestEditors
    **/
    _count?: true | GuestEditorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GuestEditorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GuestEditorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestEditorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestEditorMaxAggregateInputType
  }

  export type GetGuestEditorAggregateType<T extends GuestEditorAggregateArgs> = {
        [P in keyof T & keyof AggregateGuestEditor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuestEditor[P]>
      : GetScalarType<T[P], AggregateGuestEditor[P]>
  }




  export type GuestEditorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GuestEditorWhereInput
    orderBy?: GuestEditorOrderByWithAggregationInput | GuestEditorOrderByWithAggregationInput[]
    by: GuestEditorScalarFieldEnum[] | GuestEditorScalarFieldEnum
    having?: GuestEditorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestEditorCountAggregateInputType | true
    _avg?: GuestEditorAvgAggregateInputType
    _sum?: GuestEditorSumAggregateInputType
    _min?: GuestEditorMinAggregateInputType
    _max?: GuestEditorMaxAggregateInputType
  }

  export type GuestEditorGroupByOutputType = {
    id: number
    accessCode: string
    createDate: Date
    familyMemberId: number
    familyTreeId: number
    _count: GuestEditorCountAggregateOutputType | null
    _avg: GuestEditorAvgAggregateOutputType | null
    _sum: GuestEditorSumAggregateOutputType | null
    _min: GuestEditorMinAggregateOutputType | null
    _max: GuestEditorMaxAggregateOutputType | null
  }

  type GetGuestEditorGroupByPayload<T extends GuestEditorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestEditorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestEditorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestEditorGroupByOutputType[P]>
            : GetScalarType<T[P], GuestEditorGroupByOutputType[P]>
        }
      >
    >


  export type GuestEditorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accessCode?: boolean
    createDate?: boolean
    familyMemberId?: boolean
    familyTreeId?: boolean
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guestEditor"]>



  export type GuestEditorSelectScalar = {
    id?: boolean
    accessCode?: boolean
    createDate?: boolean
    familyMemberId?: boolean
    familyTreeId?: boolean
  }

  export type GuestEditorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accessCode" | "createDate" | "familyMemberId" | "familyTreeId", ExtArgs["result"]["guestEditor"]>
  export type GuestEditorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyMember?: boolean | FamilyMemberDefaultArgs<ExtArgs>
    familyTree?: boolean | FamilyTreeDefaultArgs<ExtArgs>
  }

  export type $GuestEditorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GuestEditor"
    objects: {
      familyMember: Prisma.$FamilyMemberPayload<ExtArgs>
      familyTree: Prisma.$FamilyTreePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      accessCode: string
      createDate: Date
      familyMemberId: number
      familyTreeId: number
    }, ExtArgs["result"]["guestEditor"]>
    composites: {}
  }

  type GuestEditorGetPayload<S extends boolean | null | undefined | GuestEditorDefaultArgs> = $Result.GetResult<Prisma.$GuestEditorPayload, S>

  type GuestEditorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GuestEditorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestEditorCountAggregateInputType | true
    }

  export interface GuestEditorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuestEditor'], meta: { name: 'GuestEditor' } }
    /**
     * Find zero or one GuestEditor that matches the filter.
     * @param {GuestEditorFindUniqueArgs} args - Arguments to find a GuestEditor
     * @example
     * // Get one GuestEditor
     * const guestEditor = await prisma.guestEditor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GuestEditorFindUniqueArgs>(args: SelectSubset<T, GuestEditorFindUniqueArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GuestEditor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GuestEditorFindUniqueOrThrowArgs} args - Arguments to find a GuestEditor
     * @example
     * // Get one GuestEditor
     * const guestEditor = await prisma.guestEditor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GuestEditorFindUniqueOrThrowArgs>(args: SelectSubset<T, GuestEditorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuestEditor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorFindFirstArgs} args - Arguments to find a GuestEditor
     * @example
     * // Get one GuestEditor
     * const guestEditor = await prisma.guestEditor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GuestEditorFindFirstArgs>(args?: SelectSubset<T, GuestEditorFindFirstArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GuestEditor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorFindFirstOrThrowArgs} args - Arguments to find a GuestEditor
     * @example
     * // Get one GuestEditor
     * const guestEditor = await prisma.guestEditor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GuestEditorFindFirstOrThrowArgs>(args?: SelectSubset<T, GuestEditorFindFirstOrThrowArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GuestEditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GuestEditors
     * const guestEditors = await prisma.guestEditor.findMany()
     * 
     * // Get first 10 GuestEditors
     * const guestEditors = await prisma.guestEditor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestEditorWithIdOnly = await prisma.guestEditor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GuestEditorFindManyArgs>(args?: SelectSubset<T, GuestEditorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GuestEditor.
     * @param {GuestEditorCreateArgs} args - Arguments to create a GuestEditor.
     * @example
     * // Create one GuestEditor
     * const GuestEditor = await prisma.guestEditor.create({
     *   data: {
     *     // ... data to create a GuestEditor
     *   }
     * })
     * 
     */
    create<T extends GuestEditorCreateArgs>(args: SelectSubset<T, GuestEditorCreateArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GuestEditors.
     * @param {GuestEditorCreateManyArgs} args - Arguments to create many GuestEditors.
     * @example
     * // Create many GuestEditors
     * const guestEditor = await prisma.guestEditor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GuestEditorCreateManyArgs>(args?: SelectSubset<T, GuestEditorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GuestEditor.
     * @param {GuestEditorDeleteArgs} args - Arguments to delete one GuestEditor.
     * @example
     * // Delete one GuestEditor
     * const GuestEditor = await prisma.guestEditor.delete({
     *   where: {
     *     // ... filter to delete one GuestEditor
     *   }
     * })
     * 
     */
    delete<T extends GuestEditorDeleteArgs>(args: SelectSubset<T, GuestEditorDeleteArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GuestEditor.
     * @param {GuestEditorUpdateArgs} args - Arguments to update one GuestEditor.
     * @example
     * // Update one GuestEditor
     * const guestEditor = await prisma.guestEditor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GuestEditorUpdateArgs>(args: SelectSubset<T, GuestEditorUpdateArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GuestEditors.
     * @param {GuestEditorDeleteManyArgs} args - Arguments to filter GuestEditors to delete.
     * @example
     * // Delete a few GuestEditors
     * const { count } = await prisma.guestEditor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GuestEditorDeleteManyArgs>(args?: SelectSubset<T, GuestEditorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GuestEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GuestEditors
     * const guestEditor = await prisma.guestEditor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GuestEditorUpdateManyArgs>(args: SelectSubset<T, GuestEditorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GuestEditor.
     * @param {GuestEditorUpsertArgs} args - Arguments to update or create a GuestEditor.
     * @example
     * // Update or create a GuestEditor
     * const guestEditor = await prisma.guestEditor.upsert({
     *   create: {
     *     // ... data to create a GuestEditor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GuestEditor we want to update
     *   }
     * })
     */
    upsert<T extends GuestEditorUpsertArgs>(args: SelectSubset<T, GuestEditorUpsertArgs<ExtArgs>>): Prisma__GuestEditorClient<$Result.GetResult<Prisma.$GuestEditorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GuestEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorCountArgs} args - Arguments to filter GuestEditors to count.
     * @example
     * // Count the number of GuestEditors
     * const count = await prisma.guestEditor.count({
     *   where: {
     *     // ... the filter for the GuestEditors we want to count
     *   }
     * })
    **/
    count<T extends GuestEditorCountArgs>(
      args?: Subset<T, GuestEditorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestEditorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GuestEditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestEditorAggregateArgs>(args: Subset<T, GuestEditorAggregateArgs>): Prisma.PrismaPromise<GetGuestEditorAggregateType<T>>

    /**
     * Group by GuestEditor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestEditorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GuestEditorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GuestEditorGroupByArgs['orderBy'] }
        : { orderBy?: GuestEditorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GuestEditorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestEditorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GuestEditor model
   */
  readonly fields: GuestEditorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GuestEditor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GuestEditorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyMember<T extends FamilyMemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMemberDefaultArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyTree<T extends FamilyTreeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyTreeDefaultArgs<ExtArgs>>): Prisma__FamilyTreeClient<$Result.GetResult<Prisma.$FamilyTreePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GuestEditor model
   */
  interface GuestEditorFieldRefs {
    readonly id: FieldRef<"GuestEditor", 'Int'>
    readonly accessCode: FieldRef<"GuestEditor", 'String'>
    readonly createDate: FieldRef<"GuestEditor", 'DateTime'>
    readonly familyMemberId: FieldRef<"GuestEditor", 'Int'>
    readonly familyTreeId: FieldRef<"GuestEditor", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GuestEditor findUnique
   */
  export type GuestEditorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter, which GuestEditor to fetch.
     */
    where: GuestEditorWhereUniqueInput
  }

  /**
   * GuestEditor findUniqueOrThrow
   */
  export type GuestEditorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter, which GuestEditor to fetch.
     */
    where: GuestEditorWhereUniqueInput
  }

  /**
   * GuestEditor findFirst
   */
  export type GuestEditorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter, which GuestEditor to fetch.
     */
    where?: GuestEditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestEditors to fetch.
     */
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuestEditors.
     */
    cursor?: GuestEditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuestEditors.
     */
    distinct?: GuestEditorScalarFieldEnum | GuestEditorScalarFieldEnum[]
  }

  /**
   * GuestEditor findFirstOrThrow
   */
  export type GuestEditorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter, which GuestEditor to fetch.
     */
    where?: GuestEditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestEditors to fetch.
     */
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GuestEditors.
     */
    cursor?: GuestEditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GuestEditors.
     */
    distinct?: GuestEditorScalarFieldEnum | GuestEditorScalarFieldEnum[]
  }

  /**
   * GuestEditor findMany
   */
  export type GuestEditorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter, which GuestEditors to fetch.
     */
    where?: GuestEditorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GuestEditors to fetch.
     */
    orderBy?: GuestEditorOrderByWithRelationInput | GuestEditorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GuestEditors.
     */
    cursor?: GuestEditorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GuestEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GuestEditors.
     */
    skip?: number
    distinct?: GuestEditorScalarFieldEnum | GuestEditorScalarFieldEnum[]
  }

  /**
   * GuestEditor create
   */
  export type GuestEditorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * The data needed to create a GuestEditor.
     */
    data: XOR<GuestEditorCreateInput, GuestEditorUncheckedCreateInput>
  }

  /**
   * GuestEditor createMany
   */
  export type GuestEditorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GuestEditors.
     */
    data: GuestEditorCreateManyInput | GuestEditorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GuestEditor update
   */
  export type GuestEditorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * The data needed to update a GuestEditor.
     */
    data: XOR<GuestEditorUpdateInput, GuestEditorUncheckedUpdateInput>
    /**
     * Choose, which GuestEditor to update.
     */
    where: GuestEditorWhereUniqueInput
  }

  /**
   * GuestEditor updateMany
   */
  export type GuestEditorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GuestEditors.
     */
    data: XOR<GuestEditorUpdateManyMutationInput, GuestEditorUncheckedUpdateManyInput>
    /**
     * Filter which GuestEditors to update
     */
    where?: GuestEditorWhereInput
    /**
     * Limit how many GuestEditors to update.
     */
    limit?: number
  }

  /**
   * GuestEditor upsert
   */
  export type GuestEditorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * The filter to search for the GuestEditor to update in case it exists.
     */
    where: GuestEditorWhereUniqueInput
    /**
     * In case the GuestEditor found by the `where` argument doesn't exist, create a new GuestEditor with this data.
     */
    create: XOR<GuestEditorCreateInput, GuestEditorUncheckedCreateInput>
    /**
     * In case the GuestEditor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GuestEditorUpdateInput, GuestEditorUncheckedUpdateInput>
  }

  /**
   * GuestEditor delete
   */
  export type GuestEditorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
    /**
     * Filter which GuestEditor to delete.
     */
    where: GuestEditorWhereUniqueInput
  }

  /**
   * GuestEditor deleteMany
   */
  export type GuestEditorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GuestEditors to delete
     */
    where?: GuestEditorWhereInput
    /**
     * Limit how many GuestEditors to delete.
     */
    limit?: number
  }

  /**
   * GuestEditor without action
   */
  export type GuestEditorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestEditor
     */
    select?: GuestEditorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GuestEditor
     */
    omit?: GuestEditorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GuestEditorInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    treeOwner?: boolean | User$treeOwnerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    treeOwner?: boolean | User$treeOwnerArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      treeOwner: Prisma.$TreeOwnerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treeOwner<T extends User$treeOwnerArgs<ExtArgs> = {}>(args?: Subset<T, User$treeOwnerArgs<ExtArgs>>): Prisma__TreeOwnerClient<$Result.GetResult<Prisma.$TreeOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.treeOwner
   */
  export type User$treeOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreeOwner
     */
    select?: TreeOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreeOwner
     */
    omit?: TreeOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreeOwnerInclude<ExtArgs> | null
    where?: TreeOwnerWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>



  export type VerificationTokenSelectScalar = {
    id?: boolean
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TreeOwnerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type TreeOwnerScalarFieldEnum = (typeof TreeOwnerScalarFieldEnum)[keyof typeof TreeOwnerScalarFieldEnum]


  export const FamilyTreeScalarFieldEnum: {
    id: 'id',
    familyName: 'familyName',
    origin: 'origin',
    establishYear: 'establishYear',
    createdAt: 'createdAt',
    treeOwnerId: 'treeOwnerId',
    rootMemberId: 'rootMemberId'
  };

  export type FamilyTreeScalarFieldEnum = (typeof FamilyTreeScalarFieldEnum)[keyof typeof FamilyTreeScalarFieldEnum]


  export const FamilyMemberScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    gender: 'gender',
    birthday: 'birthday',
    address: 'address',
    profilePicture: 'profilePicture',
    generation: 'generation',
    isRootPerson: 'isRootPerson',
    isAdopted: 'isAdopted',
    familyTreeId: 'familyTreeId',
    parentId: 'parentId'
  };

  export type FamilyMemberScalarFieldEnum = (typeof FamilyMemberScalarFieldEnum)[keyof typeof FamilyMemberScalarFieldEnum]


  export const OccupationScalarFieldEnum: {
    id: 'id',
    jobTitle: 'jobTitle',
    startDate: 'startDate',
    endDate: 'endDate',
    familyMemberId: 'familyMemberId'
  };

  export type OccupationScalarFieldEnum = (typeof OccupationScalarFieldEnum)[keyof typeof OccupationScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    achieveDate: 'achieveDate',
    description: 'description',
    familyMemberId: 'familyMemberId',
    achievementTypeId: 'achievementTypeId'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AchievementTypeScalarFieldEnum: {
    id: 'id',
    typeName: 'typeName',
    familyTreeId: 'familyTreeId'
  };

  export type AchievementTypeScalarFieldEnum = (typeof AchievementTypeScalarFieldEnum)[keyof typeof AchievementTypeScalarFieldEnum]


  export const PassingRecordScalarFieldEnum: {
    id: 'id',
    dateOfPassing: 'dateOfPassing',
    createdAt: 'createdAt',
    familyMemberId: 'familyMemberId'
  };

  export type PassingRecordScalarFieldEnum = (typeof PassingRecordScalarFieldEnum)[keyof typeof PassingRecordScalarFieldEnum]


  export const CauseOfDeathScalarFieldEnum: {
    id: 'id',
    causeName: 'causeName',
    passingRecordId: 'passingRecordId',
    familyMemberId: 'familyMemberId'
  };

  export type CauseOfDeathScalarFieldEnum = (typeof CauseOfDeathScalarFieldEnum)[keyof typeof CauseOfDeathScalarFieldEnum]


  export const BuriedPlaceScalarFieldEnum: {
    id: 'id',
    location: 'location',
    startDate: 'startDate',
    endDate: 'endDate',
    passingRecordId: 'passingRecordId'
  };

  export type BuriedPlaceScalarFieldEnum = (typeof BuriedPlaceScalarFieldEnum)[keyof typeof BuriedPlaceScalarFieldEnum]


  export const PlaceOfOriginScalarFieldEnum: {
    id: 'id',
    location: 'location'
  };

  export type PlaceOfOriginScalarFieldEnum = (typeof PlaceOfOriginScalarFieldEnum)[keyof typeof PlaceOfOriginScalarFieldEnum]


  export const FamilyMember_has_PlaceOfOriginScalarFieldEnum: {
    familyMemberId: 'familyMemberId',
    placeOfOriginId: 'placeOfOriginId',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type FamilyMember_has_PlaceOfOriginScalarFieldEnum = (typeof FamilyMember_has_PlaceOfOriginScalarFieldEnum)[keyof typeof FamilyMember_has_PlaceOfOriginScalarFieldEnum]


  export const SpouseRelationshipScalarFieldEnum: {
    id: 'id',
    marriageDate: 'marriageDate',
    divorceDate: 'divorceDate',
    familyMember1Id: 'familyMember1Id',
    familyMember2Id: 'familyMember2Id'
  };

  export type SpouseRelationshipScalarFieldEnum = (typeof SpouseRelationshipScalarFieldEnum)[keyof typeof SpouseRelationshipScalarFieldEnum]


  export const GuestEditorScalarFieldEnum: {
    id: 'id',
    accessCode: 'accessCode',
    createDate: 'createDate',
    familyMemberId: 'familyMemberId',
    familyTreeId: 'familyTreeId'
  };

  export type GuestEditorScalarFieldEnum = (typeof GuestEditorScalarFieldEnum)[keyof typeof GuestEditorScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const TreeOwnerOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    userId: 'userId'
  };

  export type TreeOwnerOrderByRelevanceFieldEnum = (typeof TreeOwnerOrderByRelevanceFieldEnum)[keyof typeof TreeOwnerOrderByRelevanceFieldEnum]


  export const FamilyTreeOrderByRelevanceFieldEnum: {
    familyName: 'familyName',
    origin: 'origin'
  };

  export type FamilyTreeOrderByRelevanceFieldEnum = (typeof FamilyTreeOrderByRelevanceFieldEnum)[keyof typeof FamilyTreeOrderByRelevanceFieldEnum]


  export const FamilyMemberOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    address: 'address',
    profilePicture: 'profilePicture',
    generation: 'generation'
  };

  export type FamilyMemberOrderByRelevanceFieldEnum = (typeof FamilyMemberOrderByRelevanceFieldEnum)[keyof typeof FamilyMemberOrderByRelevanceFieldEnum]


  export const OccupationOrderByRelevanceFieldEnum: {
    jobTitle: 'jobTitle'
  };

  export type OccupationOrderByRelevanceFieldEnum = (typeof OccupationOrderByRelevanceFieldEnum)[keyof typeof OccupationOrderByRelevanceFieldEnum]


  export const AchievementOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description'
  };

  export type AchievementOrderByRelevanceFieldEnum = (typeof AchievementOrderByRelevanceFieldEnum)[keyof typeof AchievementOrderByRelevanceFieldEnum]


  export const AchievementTypeOrderByRelevanceFieldEnum: {
    typeName: 'typeName'
  };

  export type AchievementTypeOrderByRelevanceFieldEnum = (typeof AchievementTypeOrderByRelevanceFieldEnum)[keyof typeof AchievementTypeOrderByRelevanceFieldEnum]


  export const CauseOfDeathOrderByRelevanceFieldEnum: {
    causeName: 'causeName'
  };

  export type CauseOfDeathOrderByRelevanceFieldEnum = (typeof CauseOfDeathOrderByRelevanceFieldEnum)[keyof typeof CauseOfDeathOrderByRelevanceFieldEnum]


  export const BuriedPlaceOrderByRelevanceFieldEnum: {
    location: 'location'
  };

  export type BuriedPlaceOrderByRelevanceFieldEnum = (typeof BuriedPlaceOrderByRelevanceFieldEnum)[keyof typeof BuriedPlaceOrderByRelevanceFieldEnum]


  export const PlaceOfOriginOrderByRelevanceFieldEnum: {
    location: 'location'
  };

  export type PlaceOfOriginOrderByRelevanceFieldEnum = (typeof PlaceOfOriginOrderByRelevanceFieldEnum)[keyof typeof PlaceOfOriginOrderByRelevanceFieldEnum]


  export const GuestEditorOrderByRelevanceFieldEnum: {
    accessCode: 'accessCode'
  };

  export type GuestEditorOrderByRelevanceFieldEnum = (typeof GuestEditorOrderByRelevanceFieldEnum)[keyof typeof GuestEditorOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const SessionOrderByRelevanceFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId'
  };

  export type SessionOrderByRelevanceFieldEnum = (typeof SessionOrderByRelevanceFieldEnum)[keyof typeof SessionOrderByRelevanceFieldEnum]


  export const VerificationTokenOrderByRelevanceFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    token: 'token'
  };

  export type VerificationTokenOrderByRelevanceFieldEnum = (typeof VerificationTokenOrderByRelevanceFieldEnum)[keyof typeof VerificationTokenOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type TreeOwnerWhereInput = {
    AND?: TreeOwnerWhereInput | TreeOwnerWhereInput[]
    OR?: TreeOwnerWhereInput[]
    NOT?: TreeOwnerWhereInput | TreeOwnerWhereInput[]
    id?: IntFilter<"TreeOwner"> | number
    fullName?: StringFilter<"TreeOwner"> | string
    createdAt?: DateTimeFilter<"TreeOwner"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TreeOwner"> | Date | string | null
    userId?: StringNullableFilter<"TreeOwner"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    familyTrees?: FamilyTreeListRelationFilter
  }

  export type TreeOwnerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    familyTrees?: FamilyTreeOrderByRelationAggregateInput
    _relevance?: TreeOwnerOrderByRelevanceInput
  }

  export type TreeOwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: string
    AND?: TreeOwnerWhereInput | TreeOwnerWhereInput[]
    OR?: TreeOwnerWhereInput[]
    NOT?: TreeOwnerWhereInput | TreeOwnerWhereInput[]
    fullName?: StringFilter<"TreeOwner"> | string
    createdAt?: DateTimeFilter<"TreeOwner"> | Date | string
    updatedAt?: DateTimeNullableFilter<"TreeOwner"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    familyTrees?: FamilyTreeListRelationFilter
  }, "id" | "userId">

  export type TreeOwnerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: TreeOwnerCountOrderByAggregateInput
    _avg?: TreeOwnerAvgOrderByAggregateInput
    _max?: TreeOwnerMaxOrderByAggregateInput
    _min?: TreeOwnerMinOrderByAggregateInput
    _sum?: TreeOwnerSumOrderByAggregateInput
  }

  export type TreeOwnerScalarWhereWithAggregatesInput = {
    AND?: TreeOwnerScalarWhereWithAggregatesInput | TreeOwnerScalarWhereWithAggregatesInput[]
    OR?: TreeOwnerScalarWhereWithAggregatesInput[]
    NOT?: TreeOwnerScalarWhereWithAggregatesInput | TreeOwnerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TreeOwner"> | number
    fullName?: StringWithAggregatesFilter<"TreeOwner"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TreeOwner"> | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"TreeOwner"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"TreeOwner"> | string | null
  }

  export type FamilyTreeWhereInput = {
    AND?: FamilyTreeWhereInput | FamilyTreeWhereInput[]
    OR?: FamilyTreeWhereInput[]
    NOT?: FamilyTreeWhereInput | FamilyTreeWhereInput[]
    id?: IntFilter<"FamilyTree"> | number
    familyName?: StringFilter<"FamilyTree"> | string
    origin?: StringNullableFilter<"FamilyTree"> | string | null
    establishYear?: IntNullableFilter<"FamilyTree"> | number | null
    createdAt?: DateTimeFilter<"FamilyTree"> | Date | string
    treeOwnerId?: IntFilter<"FamilyTree"> | number
    rootMemberId?: IntNullableFilter<"FamilyTree"> | number | null
    treeOwner?: XOR<TreeOwnerScalarRelationFilter, TreeOwnerWhereInput>
    rootMember?: XOR<FamilyMemberNullableScalarRelationFilter, FamilyMemberWhereInput> | null
    familyMembers?: FamilyMemberListRelationFilter
    guestEditors?: GuestEditorListRelationFilter
    achievementTypes?: AchievementTypeListRelationFilter
  }

  export type FamilyTreeOrderByWithRelationInput = {
    id?: SortOrder
    familyName?: SortOrder
    origin?: SortOrderInput | SortOrder
    establishYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrderInput | SortOrder
    treeOwner?: TreeOwnerOrderByWithRelationInput
    rootMember?: FamilyMemberOrderByWithRelationInput
    familyMembers?: FamilyMemberOrderByRelationAggregateInput
    guestEditors?: GuestEditorOrderByRelationAggregateInput
    achievementTypes?: AchievementTypeOrderByRelationAggregateInput
    _relevance?: FamilyTreeOrderByRelevanceInput
  }

  export type FamilyTreeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    rootMemberId?: number
    AND?: FamilyTreeWhereInput | FamilyTreeWhereInput[]
    OR?: FamilyTreeWhereInput[]
    NOT?: FamilyTreeWhereInput | FamilyTreeWhereInput[]
    familyName?: StringFilter<"FamilyTree"> | string
    origin?: StringNullableFilter<"FamilyTree"> | string | null
    establishYear?: IntNullableFilter<"FamilyTree"> | number | null
    createdAt?: DateTimeFilter<"FamilyTree"> | Date | string
    treeOwnerId?: IntFilter<"FamilyTree"> | number
    treeOwner?: XOR<TreeOwnerScalarRelationFilter, TreeOwnerWhereInput>
    rootMember?: XOR<FamilyMemberNullableScalarRelationFilter, FamilyMemberWhereInput> | null
    familyMembers?: FamilyMemberListRelationFilter
    guestEditors?: GuestEditorListRelationFilter
    achievementTypes?: AchievementTypeListRelationFilter
  }, "id" | "rootMemberId">

  export type FamilyTreeOrderByWithAggregationInput = {
    id?: SortOrder
    familyName?: SortOrder
    origin?: SortOrderInput | SortOrder
    establishYear?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrderInput | SortOrder
    _count?: FamilyTreeCountOrderByAggregateInput
    _avg?: FamilyTreeAvgOrderByAggregateInput
    _max?: FamilyTreeMaxOrderByAggregateInput
    _min?: FamilyTreeMinOrderByAggregateInput
    _sum?: FamilyTreeSumOrderByAggregateInput
  }

  export type FamilyTreeScalarWhereWithAggregatesInput = {
    AND?: FamilyTreeScalarWhereWithAggregatesInput | FamilyTreeScalarWhereWithAggregatesInput[]
    OR?: FamilyTreeScalarWhereWithAggregatesInput[]
    NOT?: FamilyTreeScalarWhereWithAggregatesInput | FamilyTreeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FamilyTree"> | number
    familyName?: StringWithAggregatesFilter<"FamilyTree"> | string
    origin?: StringNullableWithAggregatesFilter<"FamilyTree"> | string | null
    establishYear?: IntNullableWithAggregatesFilter<"FamilyTree"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"FamilyTree"> | Date | string
    treeOwnerId?: IntWithAggregatesFilter<"FamilyTree"> | number
    rootMemberId?: IntNullableWithAggregatesFilter<"FamilyTree"> | number | null
  }

  export type FamilyMemberWhereInput = {
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    id?: IntFilter<"FamilyMember"> | number
    fullName?: StringFilter<"FamilyMember"> | string
    gender?: EnumGenderNullableFilter<"FamilyMember"> | $Enums.Gender | null
    birthday?: DateTimeNullableFilter<"FamilyMember"> | Date | string | null
    address?: StringNullableFilter<"FamilyMember"> | string | null
    profilePicture?: StringNullableFilter<"FamilyMember"> | string | null
    generation?: StringNullableFilter<"FamilyMember"> | string | null
    isRootPerson?: BoolNullableFilter<"FamilyMember"> | boolean | null
    isAdopted?: BoolNullableFilter<"FamilyMember"> | boolean | null
    familyTreeId?: IntFilter<"FamilyMember"> | number
    parentId?: IntNullableFilter<"FamilyMember"> | number | null
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
    parent?: XOR<FamilyMemberNullableScalarRelationFilter, FamilyMemberWhereInput> | null
    children?: FamilyMemberListRelationFilter
    achievements?: AchievementListRelationFilter
    passingRecords?: PassingRecordListRelationFilter
    causesOfDeath?: CauseOfDeathListRelationFilter
    occupations?: OccupationListRelationFilter
    birthPlaces?: FamilyMember_has_PlaceOfOriginListRelationFilter
    spouse1?: SpouseRelationshipListRelationFilter
    spouse2?: SpouseRelationshipListRelationFilter
    guestEditors?: GuestEditorListRelationFilter
    rootFor?: XOR<FamilyTreeNullableScalarRelationFilter, FamilyTreeWhereInput> | null
  }

  export type FamilyMemberOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    isRootPerson?: SortOrderInput | SortOrder
    isAdopted?: SortOrderInput | SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    familyTree?: FamilyTreeOrderByWithRelationInput
    parent?: FamilyMemberOrderByWithRelationInput
    children?: FamilyMemberOrderByRelationAggregateInput
    achievements?: AchievementOrderByRelationAggregateInput
    passingRecords?: PassingRecordOrderByRelationAggregateInput
    causesOfDeath?: CauseOfDeathOrderByRelationAggregateInput
    occupations?: OccupationOrderByRelationAggregateInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginOrderByRelationAggregateInput
    spouse1?: SpouseRelationshipOrderByRelationAggregateInput
    spouse2?: SpouseRelationshipOrderByRelationAggregateInput
    guestEditors?: GuestEditorOrderByRelationAggregateInput
    rootFor?: FamilyTreeOrderByWithRelationInput
    _relevance?: FamilyMemberOrderByRelevanceInput
  }

  export type FamilyMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    fullName?: StringFilter<"FamilyMember"> | string
    gender?: EnumGenderNullableFilter<"FamilyMember"> | $Enums.Gender | null
    birthday?: DateTimeNullableFilter<"FamilyMember"> | Date | string | null
    address?: StringNullableFilter<"FamilyMember"> | string | null
    profilePicture?: StringNullableFilter<"FamilyMember"> | string | null
    generation?: StringNullableFilter<"FamilyMember"> | string | null
    isRootPerson?: BoolNullableFilter<"FamilyMember"> | boolean | null
    isAdopted?: BoolNullableFilter<"FamilyMember"> | boolean | null
    familyTreeId?: IntFilter<"FamilyMember"> | number
    parentId?: IntNullableFilter<"FamilyMember"> | number | null
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
    parent?: XOR<FamilyMemberNullableScalarRelationFilter, FamilyMemberWhereInput> | null
    children?: FamilyMemberListRelationFilter
    achievements?: AchievementListRelationFilter
    passingRecords?: PassingRecordListRelationFilter
    causesOfDeath?: CauseOfDeathListRelationFilter
    occupations?: OccupationListRelationFilter
    birthPlaces?: FamilyMember_has_PlaceOfOriginListRelationFilter
    spouse1?: SpouseRelationshipListRelationFilter
    spouse2?: SpouseRelationshipListRelationFilter
    guestEditors?: GuestEditorListRelationFilter
    rootFor?: XOR<FamilyTreeNullableScalarRelationFilter, FamilyTreeWhereInput> | null
  }, "id">

  export type FamilyMemberOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    isRootPerson?: SortOrderInput | SortOrder
    isAdopted?: SortOrderInput | SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: FamilyMemberCountOrderByAggregateInput
    _avg?: FamilyMemberAvgOrderByAggregateInput
    _max?: FamilyMemberMaxOrderByAggregateInput
    _min?: FamilyMemberMinOrderByAggregateInput
    _sum?: FamilyMemberSumOrderByAggregateInput
  }

  export type FamilyMemberScalarWhereWithAggregatesInput = {
    AND?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    OR?: FamilyMemberScalarWhereWithAggregatesInput[]
    NOT?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FamilyMember"> | number
    fullName?: StringWithAggregatesFilter<"FamilyMember"> | string
    gender?: EnumGenderNullableWithAggregatesFilter<"FamilyMember"> | $Enums.Gender | null
    birthday?: DateTimeNullableWithAggregatesFilter<"FamilyMember"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    generation?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    isRootPerson?: BoolNullableWithAggregatesFilter<"FamilyMember"> | boolean | null
    isAdopted?: BoolNullableWithAggregatesFilter<"FamilyMember"> | boolean | null
    familyTreeId?: IntWithAggregatesFilter<"FamilyMember"> | number
    parentId?: IntNullableWithAggregatesFilter<"FamilyMember"> | number | null
  }

  export type OccupationWhereInput = {
    AND?: OccupationWhereInput | OccupationWhereInput[]
    OR?: OccupationWhereInput[]
    NOT?: OccupationWhereInput | OccupationWhereInput[]
    id?: IntFilter<"Occupation"> | number
    jobTitle?: StringFilter<"Occupation"> | string
    startDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    familyMemberId?: IntFilter<"Occupation"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }

  export type OccupationOrderByWithRelationInput = {
    id?: SortOrder
    jobTitle?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    familyMemberId?: SortOrder
    familyMember?: FamilyMemberOrderByWithRelationInput
    _relevance?: OccupationOrderByRelevanceInput
  }

  export type OccupationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OccupationWhereInput | OccupationWhereInput[]
    OR?: OccupationWhereInput[]
    NOT?: OccupationWhereInput | OccupationWhereInput[]
    jobTitle?: StringFilter<"Occupation"> | string
    startDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    familyMemberId?: IntFilter<"Occupation"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }, "id">

  export type OccupationOrderByWithAggregationInput = {
    id?: SortOrder
    jobTitle?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    familyMemberId?: SortOrder
    _count?: OccupationCountOrderByAggregateInput
    _avg?: OccupationAvgOrderByAggregateInput
    _max?: OccupationMaxOrderByAggregateInput
    _min?: OccupationMinOrderByAggregateInput
    _sum?: OccupationSumOrderByAggregateInput
  }

  export type OccupationScalarWhereWithAggregatesInput = {
    AND?: OccupationScalarWhereWithAggregatesInput | OccupationScalarWhereWithAggregatesInput[]
    OR?: OccupationScalarWhereWithAggregatesInput[]
    NOT?: OccupationScalarWhereWithAggregatesInput | OccupationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Occupation"> | number
    jobTitle?: StringWithAggregatesFilter<"Occupation"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Occupation"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Occupation"> | Date | string | null
    familyMemberId?: IntWithAggregatesFilter<"Occupation"> | number
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: IntFilter<"Achievement"> | number
    title?: StringFilter<"Achievement"> | string
    achieveDate?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    description?: StringNullableFilter<"Achievement"> | string | null
    familyMemberId?: IntFilter<"Achievement"> | number
    achievementTypeId?: IntFilter<"Achievement"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    achievementType?: XOR<AchievementTypeScalarRelationFilter, AchievementTypeWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    achieveDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
    familyMember?: FamilyMemberOrderByWithRelationInput
    achievementType?: AchievementTypeOrderByWithRelationInput
    _relevance?: AchievementOrderByRelevanceInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    achieveDate?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    description?: StringNullableFilter<"Achievement"> | string | null
    familyMemberId?: IntFilter<"Achievement"> | number
    achievementTypeId?: IntFilter<"Achievement"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    achievementType?: XOR<AchievementTypeScalarRelationFilter, AchievementTypeWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    achieveDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achievement"> | number
    title?: StringWithAggregatesFilter<"Achievement"> | string
    achieveDate?: DateTimeNullableWithAggregatesFilter<"Achievement"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Achievement"> | string | null
    familyMemberId?: IntWithAggregatesFilter<"Achievement"> | number
    achievementTypeId?: IntWithAggregatesFilter<"Achievement"> | number
  }

  export type AchievementTypeWhereInput = {
    AND?: AchievementTypeWhereInput | AchievementTypeWhereInput[]
    OR?: AchievementTypeWhereInput[]
    NOT?: AchievementTypeWhereInput | AchievementTypeWhereInput[]
    id?: IntFilter<"AchievementType"> | number
    typeName?: StringFilter<"AchievementType"> | string
    familyTreeId?: IntFilter<"AchievementType"> | number
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
    achievements?: AchievementListRelationFilter
  }

  export type AchievementTypeOrderByWithRelationInput = {
    id?: SortOrder
    typeName?: SortOrder
    familyTreeId?: SortOrder
    familyTree?: FamilyTreeOrderByWithRelationInput
    achievements?: AchievementOrderByRelationAggregateInput
    _relevance?: AchievementTypeOrderByRelevanceInput
  }

  export type AchievementTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchievementTypeWhereInput | AchievementTypeWhereInput[]
    OR?: AchievementTypeWhereInput[]
    NOT?: AchievementTypeWhereInput | AchievementTypeWhereInput[]
    typeName?: StringFilter<"AchievementType"> | string
    familyTreeId?: IntFilter<"AchievementType"> | number
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
    achievements?: AchievementListRelationFilter
  }, "id">

  export type AchievementTypeOrderByWithAggregationInput = {
    id?: SortOrder
    typeName?: SortOrder
    familyTreeId?: SortOrder
    _count?: AchievementTypeCountOrderByAggregateInput
    _avg?: AchievementTypeAvgOrderByAggregateInput
    _max?: AchievementTypeMaxOrderByAggregateInput
    _min?: AchievementTypeMinOrderByAggregateInput
    _sum?: AchievementTypeSumOrderByAggregateInput
  }

  export type AchievementTypeScalarWhereWithAggregatesInput = {
    AND?: AchievementTypeScalarWhereWithAggregatesInput | AchievementTypeScalarWhereWithAggregatesInput[]
    OR?: AchievementTypeScalarWhereWithAggregatesInput[]
    NOT?: AchievementTypeScalarWhereWithAggregatesInput | AchievementTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AchievementType"> | number
    typeName?: StringWithAggregatesFilter<"AchievementType"> | string
    familyTreeId?: IntWithAggregatesFilter<"AchievementType"> | number
  }

  export type PassingRecordWhereInput = {
    AND?: PassingRecordWhereInput | PassingRecordWhereInput[]
    OR?: PassingRecordWhereInput[]
    NOT?: PassingRecordWhereInput | PassingRecordWhereInput[]
    id?: IntFilter<"PassingRecord"> | number
    dateOfPassing?: DateTimeFilter<"PassingRecord"> | Date | string
    createdAt?: DateTimeFilter<"PassingRecord"> | Date | string
    familyMemberId?: IntFilter<"PassingRecord"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    causeOfDeath?: XOR<CauseOfDeathNullableScalarRelationFilter, CauseOfDeathWhereInput> | null
    buriedPlaces?: BuriedPlaceListRelationFilter
  }

  export type PassingRecordOrderByWithRelationInput = {
    id?: SortOrder
    dateOfPassing?: SortOrder
    createdAt?: SortOrder
    familyMemberId?: SortOrder
    familyMember?: FamilyMemberOrderByWithRelationInput
    causeOfDeath?: CauseOfDeathOrderByWithRelationInput
    buriedPlaces?: BuriedPlaceOrderByRelationAggregateInput
  }

  export type PassingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PassingRecordWhereInput | PassingRecordWhereInput[]
    OR?: PassingRecordWhereInput[]
    NOT?: PassingRecordWhereInput | PassingRecordWhereInput[]
    dateOfPassing?: DateTimeFilter<"PassingRecord"> | Date | string
    createdAt?: DateTimeFilter<"PassingRecord"> | Date | string
    familyMemberId?: IntFilter<"PassingRecord"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    causeOfDeath?: XOR<CauseOfDeathNullableScalarRelationFilter, CauseOfDeathWhereInput> | null
    buriedPlaces?: BuriedPlaceListRelationFilter
  }, "id">

  export type PassingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    dateOfPassing?: SortOrder
    createdAt?: SortOrder
    familyMemberId?: SortOrder
    _count?: PassingRecordCountOrderByAggregateInput
    _avg?: PassingRecordAvgOrderByAggregateInput
    _max?: PassingRecordMaxOrderByAggregateInput
    _min?: PassingRecordMinOrderByAggregateInput
    _sum?: PassingRecordSumOrderByAggregateInput
  }

  export type PassingRecordScalarWhereWithAggregatesInput = {
    AND?: PassingRecordScalarWhereWithAggregatesInput | PassingRecordScalarWhereWithAggregatesInput[]
    OR?: PassingRecordScalarWhereWithAggregatesInput[]
    NOT?: PassingRecordScalarWhereWithAggregatesInput | PassingRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PassingRecord"> | number
    dateOfPassing?: DateTimeWithAggregatesFilter<"PassingRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"PassingRecord"> | Date | string
    familyMemberId?: IntWithAggregatesFilter<"PassingRecord"> | number
  }

  export type CauseOfDeathWhereInput = {
    AND?: CauseOfDeathWhereInput | CauseOfDeathWhereInput[]
    OR?: CauseOfDeathWhereInput[]
    NOT?: CauseOfDeathWhereInput | CauseOfDeathWhereInput[]
    id?: IntFilter<"CauseOfDeath"> | number
    causeName?: StringFilter<"CauseOfDeath"> | string
    passingRecordId?: IntFilter<"CauseOfDeath"> | number
    familyMemberId?: IntFilter<"CauseOfDeath"> | number
    passingRecord?: XOR<PassingRecordScalarRelationFilter, PassingRecordWhereInput>
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }

  export type CauseOfDeathOrderByWithRelationInput = {
    id?: SortOrder
    causeName?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
    passingRecord?: PassingRecordOrderByWithRelationInput
    familyMember?: FamilyMemberOrderByWithRelationInput
    _relevance?: CauseOfDeathOrderByRelevanceInput
  }

  export type CauseOfDeathWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    passingRecordId?: number
    AND?: CauseOfDeathWhereInput | CauseOfDeathWhereInput[]
    OR?: CauseOfDeathWhereInput[]
    NOT?: CauseOfDeathWhereInput | CauseOfDeathWhereInput[]
    causeName?: StringFilter<"CauseOfDeath"> | string
    familyMemberId?: IntFilter<"CauseOfDeath"> | number
    passingRecord?: XOR<PassingRecordScalarRelationFilter, PassingRecordWhereInput>
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }, "id" | "passingRecordId">

  export type CauseOfDeathOrderByWithAggregationInput = {
    id?: SortOrder
    causeName?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
    _count?: CauseOfDeathCountOrderByAggregateInput
    _avg?: CauseOfDeathAvgOrderByAggregateInput
    _max?: CauseOfDeathMaxOrderByAggregateInput
    _min?: CauseOfDeathMinOrderByAggregateInput
    _sum?: CauseOfDeathSumOrderByAggregateInput
  }

  export type CauseOfDeathScalarWhereWithAggregatesInput = {
    AND?: CauseOfDeathScalarWhereWithAggregatesInput | CauseOfDeathScalarWhereWithAggregatesInput[]
    OR?: CauseOfDeathScalarWhereWithAggregatesInput[]
    NOT?: CauseOfDeathScalarWhereWithAggregatesInput | CauseOfDeathScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CauseOfDeath"> | number
    causeName?: StringWithAggregatesFilter<"CauseOfDeath"> | string
    passingRecordId?: IntWithAggregatesFilter<"CauseOfDeath"> | number
    familyMemberId?: IntWithAggregatesFilter<"CauseOfDeath"> | number
  }

  export type BuriedPlaceWhereInput = {
    AND?: BuriedPlaceWhereInput | BuriedPlaceWhereInput[]
    OR?: BuriedPlaceWhereInput[]
    NOT?: BuriedPlaceWhereInput | BuriedPlaceWhereInput[]
    id?: IntFilter<"BuriedPlace"> | number
    location?: StringFilter<"BuriedPlace"> | string
    startDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    passingRecordId?: IntFilter<"BuriedPlace"> | number
    passingRecord?: XOR<PassingRecordScalarRelationFilter, PassingRecordWhereInput>
  }

  export type BuriedPlaceOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    passingRecordId?: SortOrder
    passingRecord?: PassingRecordOrderByWithRelationInput
    _relevance?: BuriedPlaceOrderByRelevanceInput
  }

  export type BuriedPlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BuriedPlaceWhereInput | BuriedPlaceWhereInput[]
    OR?: BuriedPlaceWhereInput[]
    NOT?: BuriedPlaceWhereInput | BuriedPlaceWhereInput[]
    location?: StringFilter<"BuriedPlace"> | string
    startDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    passingRecordId?: IntFilter<"BuriedPlace"> | number
    passingRecord?: XOR<PassingRecordScalarRelationFilter, PassingRecordWhereInput>
  }, "id">

  export type BuriedPlaceOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    passingRecordId?: SortOrder
    _count?: BuriedPlaceCountOrderByAggregateInput
    _avg?: BuriedPlaceAvgOrderByAggregateInput
    _max?: BuriedPlaceMaxOrderByAggregateInput
    _min?: BuriedPlaceMinOrderByAggregateInput
    _sum?: BuriedPlaceSumOrderByAggregateInput
  }

  export type BuriedPlaceScalarWhereWithAggregatesInput = {
    AND?: BuriedPlaceScalarWhereWithAggregatesInput | BuriedPlaceScalarWhereWithAggregatesInput[]
    OR?: BuriedPlaceScalarWhereWithAggregatesInput[]
    NOT?: BuriedPlaceScalarWhereWithAggregatesInput | BuriedPlaceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BuriedPlace"> | number
    location?: StringWithAggregatesFilter<"BuriedPlace"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"BuriedPlace"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"BuriedPlace"> | Date | string | null
    passingRecordId?: IntWithAggregatesFilter<"BuriedPlace"> | number
  }

  export type PlaceOfOriginWhereInput = {
    AND?: PlaceOfOriginWhereInput | PlaceOfOriginWhereInput[]
    OR?: PlaceOfOriginWhereInput[]
    NOT?: PlaceOfOriginWhereInput | PlaceOfOriginWhereInput[]
    id?: IntFilter<"PlaceOfOrigin"> | number
    location?: StringFilter<"PlaceOfOrigin"> | string
    familyMembers?: FamilyMember_has_PlaceOfOriginListRelationFilter
  }

  export type PlaceOfOriginOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    familyMembers?: FamilyMember_has_PlaceOfOriginOrderByRelationAggregateInput
    _relevance?: PlaceOfOriginOrderByRelevanceInput
  }

  export type PlaceOfOriginWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlaceOfOriginWhereInput | PlaceOfOriginWhereInput[]
    OR?: PlaceOfOriginWhereInput[]
    NOT?: PlaceOfOriginWhereInput | PlaceOfOriginWhereInput[]
    location?: StringFilter<"PlaceOfOrigin"> | string
    familyMembers?: FamilyMember_has_PlaceOfOriginListRelationFilter
  }, "id">

  export type PlaceOfOriginOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    _count?: PlaceOfOriginCountOrderByAggregateInput
    _avg?: PlaceOfOriginAvgOrderByAggregateInput
    _max?: PlaceOfOriginMaxOrderByAggregateInput
    _min?: PlaceOfOriginMinOrderByAggregateInput
    _sum?: PlaceOfOriginSumOrderByAggregateInput
  }

  export type PlaceOfOriginScalarWhereWithAggregatesInput = {
    AND?: PlaceOfOriginScalarWhereWithAggregatesInput | PlaceOfOriginScalarWhereWithAggregatesInput[]
    OR?: PlaceOfOriginScalarWhereWithAggregatesInput[]
    NOT?: PlaceOfOriginScalarWhereWithAggregatesInput | PlaceOfOriginScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PlaceOfOrigin"> | number
    location?: StringWithAggregatesFilter<"PlaceOfOrigin"> | string
  }

  export type FamilyMember_has_PlaceOfOriginWhereInput = {
    AND?: FamilyMember_has_PlaceOfOriginWhereInput | FamilyMember_has_PlaceOfOriginWhereInput[]
    OR?: FamilyMember_has_PlaceOfOriginWhereInput[]
    NOT?: FamilyMember_has_PlaceOfOriginWhereInput | FamilyMember_has_PlaceOfOriginWhereInput[]
    familyMemberId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    placeOfOriginId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    startDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    endDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    placeOfOrigin?: XOR<PlaceOfOriginScalarRelationFilter, PlaceOfOriginWhereInput>
  }

  export type FamilyMember_has_PlaceOfOriginOrderByWithRelationInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    familyMember?: FamilyMemberOrderByWithRelationInput
    placeOfOrigin?: PlaceOfOriginOrderByWithRelationInput
  }

  export type FamilyMember_has_PlaceOfOriginWhereUniqueInput = Prisma.AtLeast<{
    familyMemberId_placeOfOriginId?: FamilyMember_has_PlaceOfOriginFamilyMemberIdPlaceOfOriginIdCompoundUniqueInput
    AND?: FamilyMember_has_PlaceOfOriginWhereInput | FamilyMember_has_PlaceOfOriginWhereInput[]
    OR?: FamilyMember_has_PlaceOfOriginWhereInput[]
    NOT?: FamilyMember_has_PlaceOfOriginWhereInput | FamilyMember_has_PlaceOfOriginWhereInput[]
    familyMemberId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    placeOfOriginId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    startDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    endDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    placeOfOrigin?: XOR<PlaceOfOriginScalarRelationFilter, PlaceOfOriginWhereInput>
  }, "familyMemberId_placeOfOriginId">

  export type FamilyMember_has_PlaceOfOriginOrderByWithAggregationInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: FamilyMember_has_PlaceOfOriginCountOrderByAggregateInput
    _avg?: FamilyMember_has_PlaceOfOriginAvgOrderByAggregateInput
    _max?: FamilyMember_has_PlaceOfOriginMaxOrderByAggregateInput
    _min?: FamilyMember_has_PlaceOfOriginMinOrderByAggregateInput
    _sum?: FamilyMember_has_PlaceOfOriginSumOrderByAggregateInput
  }

  export type FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput = {
    AND?: FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput | FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput[]
    OR?: FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput[]
    NOT?: FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput | FamilyMember_has_PlaceOfOriginScalarWhereWithAggregatesInput[]
    familyMemberId?: IntWithAggregatesFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    placeOfOriginId?: IntWithAggregatesFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
  }

  export type SpouseRelationshipWhereInput = {
    AND?: SpouseRelationshipWhereInput | SpouseRelationshipWhereInput[]
    OR?: SpouseRelationshipWhereInput[]
    NOT?: SpouseRelationshipWhereInput | SpouseRelationshipWhereInput[]
    id?: IntFilter<"SpouseRelationship"> | number
    marriageDate?: DateTimeFilter<"SpouseRelationship"> | Date | string
    divorceDate?: DateTimeNullableFilter<"SpouseRelationship"> | Date | string | null
    familyMember1Id?: IntFilter<"SpouseRelationship"> | number
    familyMember2Id?: IntFilter<"SpouseRelationship"> | number
    familyMember1?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    familyMember2?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }

  export type SpouseRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    marriageDate?: SortOrder
    divorceDate?: SortOrderInput | SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
    familyMember1?: FamilyMemberOrderByWithRelationInput
    familyMember2?: FamilyMemberOrderByWithRelationInput
  }

  export type SpouseRelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SpouseRelationshipWhereInput | SpouseRelationshipWhereInput[]
    OR?: SpouseRelationshipWhereInput[]
    NOT?: SpouseRelationshipWhereInput | SpouseRelationshipWhereInput[]
    marriageDate?: DateTimeFilter<"SpouseRelationship"> | Date | string
    divorceDate?: DateTimeNullableFilter<"SpouseRelationship"> | Date | string | null
    familyMember1Id?: IntFilter<"SpouseRelationship"> | number
    familyMember2Id?: IntFilter<"SpouseRelationship"> | number
    familyMember1?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    familyMember2?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
  }, "id">

  export type SpouseRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    marriageDate?: SortOrder
    divorceDate?: SortOrderInput | SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
    _count?: SpouseRelationshipCountOrderByAggregateInput
    _avg?: SpouseRelationshipAvgOrderByAggregateInput
    _max?: SpouseRelationshipMaxOrderByAggregateInput
    _min?: SpouseRelationshipMinOrderByAggregateInput
    _sum?: SpouseRelationshipSumOrderByAggregateInput
  }

  export type SpouseRelationshipScalarWhereWithAggregatesInput = {
    AND?: SpouseRelationshipScalarWhereWithAggregatesInput | SpouseRelationshipScalarWhereWithAggregatesInput[]
    OR?: SpouseRelationshipScalarWhereWithAggregatesInput[]
    NOT?: SpouseRelationshipScalarWhereWithAggregatesInput | SpouseRelationshipScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SpouseRelationship"> | number
    marriageDate?: DateTimeWithAggregatesFilter<"SpouseRelationship"> | Date | string
    divorceDate?: DateTimeNullableWithAggregatesFilter<"SpouseRelationship"> | Date | string | null
    familyMember1Id?: IntWithAggregatesFilter<"SpouseRelationship"> | number
    familyMember2Id?: IntWithAggregatesFilter<"SpouseRelationship"> | number
  }

  export type GuestEditorWhereInput = {
    AND?: GuestEditorWhereInput | GuestEditorWhereInput[]
    OR?: GuestEditorWhereInput[]
    NOT?: GuestEditorWhereInput | GuestEditorWhereInput[]
    id?: IntFilter<"GuestEditor"> | number
    accessCode?: StringFilter<"GuestEditor"> | string
    createDate?: DateTimeFilter<"GuestEditor"> | Date | string
    familyMemberId?: IntFilter<"GuestEditor"> | number
    familyTreeId?: IntFilter<"GuestEditor"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
  }

  export type GuestEditorOrderByWithRelationInput = {
    id?: SortOrder
    accessCode?: SortOrder
    createDate?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
    familyMember?: FamilyMemberOrderByWithRelationInput
    familyTree?: FamilyTreeOrderByWithRelationInput
    _relevance?: GuestEditorOrderByRelevanceInput
  }

  export type GuestEditorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GuestEditorWhereInput | GuestEditorWhereInput[]
    OR?: GuestEditorWhereInput[]
    NOT?: GuestEditorWhereInput | GuestEditorWhereInput[]
    accessCode?: StringFilter<"GuestEditor"> | string
    createDate?: DateTimeFilter<"GuestEditor"> | Date | string
    familyMemberId?: IntFilter<"GuestEditor"> | number
    familyTreeId?: IntFilter<"GuestEditor"> | number
    familyMember?: XOR<FamilyMemberScalarRelationFilter, FamilyMemberWhereInput>
    familyTree?: XOR<FamilyTreeScalarRelationFilter, FamilyTreeWhereInput>
  }, "id">

  export type GuestEditorOrderByWithAggregationInput = {
    id?: SortOrder
    accessCode?: SortOrder
    createDate?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
    _count?: GuestEditorCountOrderByAggregateInput
    _avg?: GuestEditorAvgOrderByAggregateInput
    _max?: GuestEditorMaxOrderByAggregateInput
    _min?: GuestEditorMinOrderByAggregateInput
    _sum?: GuestEditorSumOrderByAggregateInput
  }

  export type GuestEditorScalarWhereWithAggregatesInput = {
    AND?: GuestEditorScalarWhereWithAggregatesInput | GuestEditorScalarWhereWithAggregatesInput[]
    OR?: GuestEditorScalarWhereWithAggregatesInput[]
    NOT?: GuestEditorScalarWhereWithAggregatesInput | GuestEditorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GuestEditor"> | number
    accessCode?: StringWithAggregatesFilter<"GuestEditor"> | string
    createDate?: DateTimeWithAggregatesFilter<"GuestEditor"> | Date | string
    familyMemberId?: IntWithAggregatesFilter<"GuestEditor"> | number
    familyTreeId?: IntWithAggregatesFilter<"GuestEditor"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    treeOwner?: XOR<TreeOwnerNullableScalarRelationFilter, TreeOwnerWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    treeOwner?: TreeOwnerOrderByWithRelationInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    treeOwner?: XOR<TreeOwnerNullableScalarRelationFilter, TreeOwnerWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SessionOrderByRelevanceInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _relevance?: VerificationTokenOrderByRelevanceInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type TreeOwnerCreateInput = {
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutTreeOwnerInput
    familyTrees?: FamilyTreeCreateNestedManyWithoutTreeOwnerInput
  }

  export type TreeOwnerUncheckedCreateInput = {
    id?: number
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId?: string | null
    familyTrees?: FamilyTreeUncheckedCreateNestedManyWithoutTreeOwnerInput
  }

  export type TreeOwnerUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutTreeOwnerNestedInput
    familyTrees?: FamilyTreeUpdateManyWithoutTreeOwnerNestedInput
  }

  export type TreeOwnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    familyTrees?: FamilyTreeUncheckedUpdateManyWithoutTreeOwnerNestedInput
  }

  export type TreeOwnerCreateManyInput = {
    id?: number
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId?: string | null
  }

  export type TreeOwnerUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TreeOwnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyTreeCreateInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwner: TreeOwnerCreateNestedOneWithoutFamilyTreesInput
    rootMember?: FamilyMemberCreateNestedOneWithoutRootForInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    rootMemberId?: number | null
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUpdateInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwner?: TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput
    rootMember?: FamilyMemberUpdateOneWithoutRootForNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeCreateManyInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    rootMemberId?: number | null
  }

  export type FamilyTreeUpdateManyMutationInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyTreeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FamilyMemberCreateInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberCreateManyInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
  }

  export type FamilyMemberUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FamilyMemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OccupationCreateInput = {
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    familyMember: FamilyMemberCreateNestedOneWithoutOccupationsInput
  }

  export type OccupationUncheckedCreateInput = {
    id?: number
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    familyMemberId: number
  }

  export type OccupationUpdateInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember?: FamilyMemberUpdateOneRequiredWithoutOccupationsNestedInput
  }

  export type OccupationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type OccupationCreateManyInput = {
    id?: number
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    familyMemberId: number
  }

  export type OccupationUpdateManyMutationInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OccupationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementCreateInput = {
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMember: FamilyMemberCreateNestedOneWithoutAchievementsInput
    achievementType: AchievementTypeCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMemberId: number
    achievementTypeId: number
  }

  export type AchievementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMember?: FamilyMemberUpdateOneRequiredWithoutAchievementsNestedInput
    achievementType?: AchievementTypeUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
    achievementTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementCreateManyInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMemberId: number
    achievementTypeId: number
  }

  export type AchievementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
    achievementTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementTypeCreateInput = {
    typeName: string
    familyTree: FamilyTreeCreateNestedOneWithoutAchievementTypesInput
    achievements?: AchievementCreateNestedManyWithoutAchievementTypeInput
  }

  export type AchievementTypeUncheckedCreateInput = {
    id?: number
    typeName: string
    familyTreeId: number
    achievements?: AchievementUncheckedCreateNestedManyWithoutAchievementTypeInput
  }

  export type AchievementTypeUpdateInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    familyTree?: FamilyTreeUpdateOneRequiredWithoutAchievementTypesNestedInput
    achievements?: AchievementUpdateManyWithoutAchievementTypeNestedInput
  }

  export type AchievementTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    familyTreeId?: IntFieldUpdateOperationsInput | number
    achievements?: AchievementUncheckedUpdateManyWithoutAchievementTypeNestedInput
  }

  export type AchievementTypeCreateManyInput = {
    id?: number
    typeName: string
    familyTreeId: number
  }

  export type AchievementTypeUpdateManyMutationInput = {
    typeName?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type PassingRecordCreateInput = {
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMember: FamilyMemberCreateNestedOneWithoutPassingRecordsInput
    causeOfDeath?: CauseOfDeathCreateNestedOneWithoutPassingRecordInput
    buriedPlaces?: BuriedPlaceCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordUncheckedCreateInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMemberId: number
    causeOfDeath?: CauseOfDeathUncheckedCreateNestedOneWithoutPassingRecordInput
    buriedPlaces?: BuriedPlaceUncheckedCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordUpdateInput = {
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutPassingRecordsNestedInput
    causeOfDeath?: CauseOfDeathUpdateOneWithoutPassingRecordNestedInput
    buriedPlaces?: BuriedPlaceUpdateManyWithoutPassingRecordNestedInput
  }

  export type PassingRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
    causeOfDeath?: CauseOfDeathUncheckedUpdateOneWithoutPassingRecordNestedInput
    buriedPlaces?: BuriedPlaceUncheckedUpdateManyWithoutPassingRecordNestedInput
  }

  export type PassingRecordCreateManyInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMemberId: number
  }

  export type PassingRecordUpdateManyMutationInput = {
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassingRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type CauseOfDeathCreateInput = {
    causeName: string
    passingRecord: PassingRecordCreateNestedOneWithoutCauseOfDeathInput
    familyMember: FamilyMemberCreateNestedOneWithoutCausesOfDeathInput
  }

  export type CauseOfDeathUncheckedCreateInput = {
    id?: number
    causeName: string
    passingRecordId: number
    familyMemberId: number
  }

  export type CauseOfDeathUpdateInput = {
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecord?: PassingRecordUpdateOneRequiredWithoutCauseOfDeathNestedInput
    familyMember?: FamilyMemberUpdateOneRequiredWithoutCausesOfDeathNestedInput
  }

  export type CauseOfDeathUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecordId?: IntFieldUpdateOperationsInput | number
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type CauseOfDeathCreateManyInput = {
    id?: number
    causeName: string
    passingRecordId: number
    familyMemberId: number
  }

  export type CauseOfDeathUpdateManyMutationInput = {
    causeName?: StringFieldUpdateOperationsInput | string
  }

  export type CauseOfDeathUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecordId?: IntFieldUpdateOperationsInput | number
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type BuriedPlaceCreateInput = {
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    passingRecord: PassingRecordCreateNestedOneWithoutBuriedPlacesInput
  }

  export type BuriedPlaceUncheckedCreateInput = {
    id?: number
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    passingRecordId: number
  }

  export type BuriedPlaceUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passingRecord?: PassingRecordUpdateOneRequiredWithoutBuriedPlacesNestedInput
  }

  export type BuriedPlaceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passingRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type BuriedPlaceCreateManyInput = {
    id?: number
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    passingRecordId: number
  }

  export type BuriedPlaceUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BuriedPlaceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passingRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type PlaceOfOriginCreateInput = {
    location: string
    familyMembers?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutPlaceOfOriginInput
  }

  export type PlaceOfOriginUncheckedCreateInput = {
    id?: number
    location: string
    familyMembers?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutPlaceOfOriginInput
  }

  export type PlaceOfOriginUpdateInput = {
    location?: StringFieldUpdateOperationsInput | string
    familyMembers?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutPlaceOfOriginNestedInput
  }

  export type PlaceOfOriginUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    familyMembers?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutPlaceOfOriginNestedInput
  }

  export type PlaceOfOriginCreateManyInput = {
    id?: number
    location: string
  }

  export type PlaceOfOriginUpdateManyMutationInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceOfOriginUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMember_has_PlaceOfOriginCreateInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    familyMember: FamilyMemberCreateNestedOneWithoutBirthPlacesInput
    placeOfOrigin: PlaceOfOriginCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedCreateInput = {
    familyMemberId: number
    placeOfOriginId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUpdateInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember?: FamilyMemberUpdateOneRequiredWithoutBirthPlacesNestedInput
    placeOfOrigin?: PlaceOfOriginUpdateOneRequiredWithoutFamilyMembersNestedInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateInput = {
    familyMemberId?: IntFieldUpdateOperationsInput | number
    placeOfOriginId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginCreateManyInput = {
    familyMemberId: number
    placeOfOriginId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUpdateManyMutationInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateManyInput = {
    familyMemberId?: IntFieldUpdateOperationsInput | number
    placeOfOriginId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpouseRelationshipCreateInput = {
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1: FamilyMemberCreateNestedOneWithoutSpouse1Input
    familyMember2: FamilyMemberCreateNestedOneWithoutSpouse2Input
  }

  export type SpouseRelationshipUncheckedCreateInput = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1Id: number
    familyMember2Id: number
  }

  export type SpouseRelationshipUpdateInput = {
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1?: FamilyMemberUpdateOneRequiredWithoutSpouse1NestedInput
    familyMember2?: FamilyMemberUpdateOneRequiredWithoutSpouse2NestedInput
  }

  export type SpouseRelationshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1Id?: IntFieldUpdateOperationsInput | number
    familyMember2Id?: IntFieldUpdateOperationsInput | number
  }

  export type SpouseRelationshipCreateManyInput = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1Id: number
    familyMember2Id: number
  }

  export type SpouseRelationshipUpdateManyMutationInput = {
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpouseRelationshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1Id?: IntFieldUpdateOperationsInput | number
    familyMember2Id?: IntFieldUpdateOperationsInput | number
  }

  export type GuestEditorCreateInput = {
    accessCode: string
    createDate?: Date | string
    familyMember: FamilyMemberCreateNestedOneWithoutGuestEditorsInput
    familyTree: FamilyTreeCreateNestedOneWithoutGuestEditorsInput
  }

  export type GuestEditorUncheckedCreateInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyMemberId: number
    familyTreeId: number
  }

  export type GuestEditorUpdateInput = {
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutGuestEditorsNestedInput
    familyTree?: FamilyTreeUpdateOneRequiredWithoutGuestEditorsNestedInput
  }

  export type GuestEditorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type GuestEditorCreateManyInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyMemberId: number
    familyTreeId: number
  }

  export type GuestEditorUpdateManyMutationInput = {
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GuestEditorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FamilyTreeListRelationFilter = {
    every?: FamilyTreeWhereInput
    some?: FamilyTreeWhereInput
    none?: FamilyTreeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FamilyTreeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreeOwnerOrderByRelevanceInput = {
    fields: TreeOwnerOrderByRelevanceFieldEnum | TreeOwnerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TreeOwnerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TreeOwnerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TreeOwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TreeOwnerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type TreeOwnerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TreeOwnerScalarRelationFilter = {
    is?: TreeOwnerWhereInput
    isNot?: TreeOwnerWhereInput
  }

  export type FamilyMemberNullableScalarRelationFilter = {
    is?: FamilyMemberWhereInput | null
    isNot?: FamilyMemberWhereInput | null
  }

  export type FamilyMemberListRelationFilter = {
    every?: FamilyMemberWhereInput
    some?: FamilyMemberWhereInput
    none?: FamilyMemberWhereInput
  }

  export type GuestEditorListRelationFilter = {
    every?: GuestEditorWhereInput
    some?: GuestEditorWhereInput
    none?: GuestEditorWhereInput
  }

  export type AchievementTypeListRelationFilter = {
    every?: AchievementTypeWhereInput
    some?: AchievementTypeWhereInput
    none?: AchievementTypeWhereInput
  }

  export type FamilyMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GuestEditorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyTreeOrderByRelevanceInput = {
    fields: FamilyTreeOrderByRelevanceFieldEnum | FamilyTreeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FamilyTreeCountOrderByAggregateInput = {
    id?: SortOrder
    familyName?: SortOrder
    origin?: SortOrder
    establishYear?: SortOrder
    createdAt?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrder
  }

  export type FamilyTreeAvgOrderByAggregateInput = {
    id?: SortOrder
    establishYear?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrder
  }

  export type FamilyTreeMaxOrderByAggregateInput = {
    id?: SortOrder
    familyName?: SortOrder
    origin?: SortOrder
    establishYear?: SortOrder
    createdAt?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrder
  }

  export type FamilyTreeMinOrderByAggregateInput = {
    id?: SortOrder
    familyName?: SortOrder
    origin?: SortOrder
    establishYear?: SortOrder
    createdAt?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrder
  }

  export type FamilyTreeSumOrderByAggregateInput = {
    id?: SortOrder
    establishYear?: SortOrder
    treeOwnerId?: SortOrder
    rootMemberId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FamilyTreeScalarRelationFilter = {
    is?: FamilyTreeWhereInput
    isNot?: FamilyTreeWhereInput
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type PassingRecordListRelationFilter = {
    every?: PassingRecordWhereInput
    some?: PassingRecordWhereInput
    none?: PassingRecordWhereInput
  }

  export type CauseOfDeathListRelationFilter = {
    every?: CauseOfDeathWhereInput
    some?: CauseOfDeathWhereInput
    none?: CauseOfDeathWhereInput
  }

  export type OccupationListRelationFilter = {
    every?: OccupationWhereInput
    some?: OccupationWhereInput
    none?: OccupationWhereInput
  }

  export type FamilyMember_has_PlaceOfOriginListRelationFilter = {
    every?: FamilyMember_has_PlaceOfOriginWhereInput
    some?: FamilyMember_has_PlaceOfOriginWhereInput
    none?: FamilyMember_has_PlaceOfOriginWhereInput
  }

  export type SpouseRelationshipListRelationFilter = {
    every?: SpouseRelationshipWhereInput
    some?: SpouseRelationshipWhereInput
    none?: SpouseRelationshipWhereInput
  }

  export type FamilyTreeNullableScalarRelationFilter = {
    is?: FamilyTreeWhereInput | null
    isNot?: FamilyTreeWhereInput | null
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CauseOfDeathOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OccupationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMember_has_PlaceOfOriginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpouseRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMemberOrderByRelevanceInput = {
    fields: FamilyMemberOrderByRelevanceFieldEnum | FamilyMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FamilyMemberCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    address?: SortOrder
    profilePicture?: SortOrder
    generation?: SortOrder
    isRootPerson?: SortOrder
    isAdopted?: SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrder
  }

  export type FamilyMemberAvgOrderByAggregateInput = {
    id?: SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrder
  }

  export type FamilyMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    address?: SortOrder
    profilePicture?: SortOrder
    generation?: SortOrder
    isRootPerson?: SortOrder
    isAdopted?: SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrder
  }

  export type FamilyMemberMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    birthday?: SortOrder
    address?: SortOrder
    profilePicture?: SortOrder
    generation?: SortOrder
    isRootPerson?: SortOrder
    isAdopted?: SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrder
  }

  export type FamilyMemberSumOrderByAggregateInput = {
    id?: SortOrder
    familyTreeId?: SortOrder
    parentId?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FamilyMemberScalarRelationFilter = {
    is?: FamilyMemberWhereInput
    isNot?: FamilyMemberWhereInput
  }

  export type OccupationOrderByRelevanceInput = {
    fields: OccupationOrderByRelevanceFieldEnum | OccupationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OccupationCountOrderByAggregateInput = {
    id?: SortOrder
    jobTitle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    familyMemberId?: SortOrder
  }

  export type OccupationAvgOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
  }

  export type OccupationMaxOrderByAggregateInput = {
    id?: SortOrder
    jobTitle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    familyMemberId?: SortOrder
  }

  export type OccupationMinOrderByAggregateInput = {
    id?: SortOrder
    jobTitle?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    familyMemberId?: SortOrder
  }

  export type OccupationSumOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
  }

  export type AchievementTypeScalarRelationFilter = {
    is?: AchievementTypeWhereInput
    isNot?: AchievementTypeWhereInput
  }

  export type AchievementOrderByRelevanceInput = {
    fields: AchievementOrderByRelevanceFieldEnum | AchievementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    achieveDate?: SortOrder
    description?: SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    achieveDate?: SortOrder
    description?: SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    achieveDate?: SortOrder
    description?: SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
    achievementTypeId?: SortOrder
  }

  export type AchievementTypeOrderByRelevanceInput = {
    fields: AchievementTypeOrderByRelevanceFieldEnum | AchievementTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AchievementTypeCountOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    familyTreeId?: SortOrder
  }

  export type AchievementTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    familyTreeId?: SortOrder
  }

  export type AchievementTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    familyTreeId?: SortOrder
  }

  export type AchievementTypeMinOrderByAggregateInput = {
    id?: SortOrder
    typeName?: SortOrder
    familyTreeId?: SortOrder
  }

  export type AchievementTypeSumOrderByAggregateInput = {
    id?: SortOrder
    familyTreeId?: SortOrder
  }

  export type CauseOfDeathNullableScalarRelationFilter = {
    is?: CauseOfDeathWhereInput | null
    isNot?: CauseOfDeathWhereInput | null
  }

  export type BuriedPlaceListRelationFilter = {
    every?: BuriedPlaceWhereInput
    some?: BuriedPlaceWhereInput
    none?: BuriedPlaceWhereInput
  }

  export type BuriedPlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    dateOfPassing?: SortOrder
    createdAt?: SortOrder
    familyMemberId?: SortOrder
  }

  export type PassingRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
  }

  export type PassingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    dateOfPassing?: SortOrder
    createdAt?: SortOrder
    familyMemberId?: SortOrder
  }

  export type PassingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    dateOfPassing?: SortOrder
    createdAt?: SortOrder
    familyMemberId?: SortOrder
  }

  export type PassingRecordSumOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
  }

  export type PassingRecordScalarRelationFilter = {
    is?: PassingRecordWhereInput
    isNot?: PassingRecordWhereInput
  }

  export type CauseOfDeathOrderByRelevanceInput = {
    fields: CauseOfDeathOrderByRelevanceFieldEnum | CauseOfDeathOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CauseOfDeathCountOrderByAggregateInput = {
    id?: SortOrder
    causeName?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
  }

  export type CauseOfDeathAvgOrderByAggregateInput = {
    id?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
  }

  export type CauseOfDeathMaxOrderByAggregateInput = {
    id?: SortOrder
    causeName?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
  }

  export type CauseOfDeathMinOrderByAggregateInput = {
    id?: SortOrder
    causeName?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
  }

  export type CauseOfDeathSumOrderByAggregateInput = {
    id?: SortOrder
    passingRecordId?: SortOrder
    familyMemberId?: SortOrder
  }

  export type BuriedPlaceOrderByRelevanceInput = {
    fields: BuriedPlaceOrderByRelevanceFieldEnum | BuriedPlaceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BuriedPlaceCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    passingRecordId?: SortOrder
  }

  export type BuriedPlaceAvgOrderByAggregateInput = {
    id?: SortOrder
    passingRecordId?: SortOrder
  }

  export type BuriedPlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    passingRecordId?: SortOrder
  }

  export type BuriedPlaceMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    passingRecordId?: SortOrder
  }

  export type BuriedPlaceSumOrderByAggregateInput = {
    id?: SortOrder
    passingRecordId?: SortOrder
  }

  export type PlaceOfOriginOrderByRelevanceInput = {
    fields: PlaceOfOriginOrderByRelevanceFieldEnum | PlaceOfOriginOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PlaceOfOriginCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
  }

  export type PlaceOfOriginAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlaceOfOriginMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
  }

  export type PlaceOfOriginMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
  }

  export type PlaceOfOriginSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlaceOfOriginScalarRelationFilter = {
    is?: PlaceOfOriginWhereInput
    isNot?: PlaceOfOriginWhereInput
  }

  export type FamilyMember_has_PlaceOfOriginFamilyMemberIdPlaceOfOriginIdCompoundUniqueInput = {
    familyMemberId: number
    placeOfOriginId: number
  }

  export type FamilyMember_has_PlaceOfOriginCountOrderByAggregateInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type FamilyMember_has_PlaceOfOriginAvgOrderByAggregateInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
  }

  export type FamilyMember_has_PlaceOfOriginMaxOrderByAggregateInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type FamilyMember_has_PlaceOfOriginMinOrderByAggregateInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type FamilyMember_has_PlaceOfOriginSumOrderByAggregateInput = {
    familyMemberId?: SortOrder
    placeOfOriginId?: SortOrder
  }

  export type SpouseRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    marriageDate?: SortOrder
    divorceDate?: SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
  }

  export type SpouseRelationshipAvgOrderByAggregateInput = {
    id?: SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
  }

  export type SpouseRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    marriageDate?: SortOrder
    divorceDate?: SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
  }

  export type SpouseRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    marriageDate?: SortOrder
    divorceDate?: SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
  }

  export type SpouseRelationshipSumOrderByAggregateInput = {
    id?: SortOrder
    familyMember1Id?: SortOrder
    familyMember2Id?: SortOrder
  }

  export type GuestEditorOrderByRelevanceInput = {
    fields: GuestEditorOrderByRelevanceFieldEnum | GuestEditorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GuestEditorCountOrderByAggregateInput = {
    id?: SortOrder
    accessCode?: SortOrder
    createDate?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
  }

  export type GuestEditorAvgOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
  }

  export type GuestEditorMaxOrderByAggregateInput = {
    id?: SortOrder
    accessCode?: SortOrder
    createDate?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
  }

  export type GuestEditorMinOrderByAggregateInput = {
    id?: SortOrder
    accessCode?: SortOrder
    createDate?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
  }

  export type GuestEditorSumOrderByAggregateInput = {
    id?: SortOrder
    familyMemberId?: SortOrder
    familyTreeId?: SortOrder
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TreeOwnerNullableScalarRelationFilter = {
    is?: TreeOwnerWhereInput | null
    isNot?: TreeOwnerWhereInput | null
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type SessionOrderByRelevanceInput = {
    fields: SessionOrderByRelevanceFieldEnum | SessionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenOrderByRelevanceInput = {
    fields: VerificationTokenOrderByRelevanceFieldEnum | VerificationTokenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type UserCreateNestedOneWithoutTreeOwnerInput = {
    create?: XOR<UserCreateWithoutTreeOwnerInput, UserUncheckedCreateWithoutTreeOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTreeOwnerInput
    connect?: UserWhereUniqueInput
  }

  export type FamilyTreeCreateNestedManyWithoutTreeOwnerInput = {
    create?: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput> | FamilyTreeCreateWithoutTreeOwnerInput[] | FamilyTreeUncheckedCreateWithoutTreeOwnerInput[]
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutTreeOwnerInput | FamilyTreeCreateOrConnectWithoutTreeOwnerInput[]
    createMany?: FamilyTreeCreateManyTreeOwnerInputEnvelope
    connect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
  }

  export type FamilyTreeUncheckedCreateNestedManyWithoutTreeOwnerInput = {
    create?: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput> | FamilyTreeCreateWithoutTreeOwnerInput[] | FamilyTreeUncheckedCreateWithoutTreeOwnerInput[]
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutTreeOwnerInput | FamilyTreeCreateOrConnectWithoutTreeOwnerInput[]
    createMany?: FamilyTreeCreateManyTreeOwnerInputEnvelope
    connect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutTreeOwnerNestedInput = {
    create?: XOR<UserCreateWithoutTreeOwnerInput, UserUncheckedCreateWithoutTreeOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutTreeOwnerInput
    upsert?: UserUpsertWithoutTreeOwnerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTreeOwnerInput, UserUpdateWithoutTreeOwnerInput>, UserUncheckedUpdateWithoutTreeOwnerInput>
  }

  export type FamilyTreeUpdateManyWithoutTreeOwnerNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput> | FamilyTreeCreateWithoutTreeOwnerInput[] | FamilyTreeUncheckedCreateWithoutTreeOwnerInput[]
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutTreeOwnerInput | FamilyTreeCreateOrConnectWithoutTreeOwnerInput[]
    upsert?: FamilyTreeUpsertWithWhereUniqueWithoutTreeOwnerInput | FamilyTreeUpsertWithWhereUniqueWithoutTreeOwnerInput[]
    createMany?: FamilyTreeCreateManyTreeOwnerInputEnvelope
    set?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    disconnect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    delete?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    connect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    update?: FamilyTreeUpdateWithWhereUniqueWithoutTreeOwnerInput | FamilyTreeUpdateWithWhereUniqueWithoutTreeOwnerInput[]
    updateMany?: FamilyTreeUpdateManyWithWhereWithoutTreeOwnerInput | FamilyTreeUpdateManyWithWhereWithoutTreeOwnerInput[]
    deleteMany?: FamilyTreeScalarWhereInput | FamilyTreeScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FamilyTreeUncheckedUpdateManyWithoutTreeOwnerNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput> | FamilyTreeCreateWithoutTreeOwnerInput[] | FamilyTreeUncheckedCreateWithoutTreeOwnerInput[]
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutTreeOwnerInput | FamilyTreeCreateOrConnectWithoutTreeOwnerInput[]
    upsert?: FamilyTreeUpsertWithWhereUniqueWithoutTreeOwnerInput | FamilyTreeUpsertWithWhereUniqueWithoutTreeOwnerInput[]
    createMany?: FamilyTreeCreateManyTreeOwnerInputEnvelope
    set?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    disconnect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    delete?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    connect?: FamilyTreeWhereUniqueInput | FamilyTreeWhereUniqueInput[]
    update?: FamilyTreeUpdateWithWhereUniqueWithoutTreeOwnerInput | FamilyTreeUpdateWithWhereUniqueWithoutTreeOwnerInput[]
    updateMany?: FamilyTreeUpdateManyWithWhereWithoutTreeOwnerInput | FamilyTreeUpdateManyWithWhereWithoutTreeOwnerInput[]
    deleteMany?: FamilyTreeScalarWhereInput | FamilyTreeScalarWhereInput[]
  }

  export type TreeOwnerCreateNestedOneWithoutFamilyTreesInput = {
    create?: XOR<TreeOwnerCreateWithoutFamilyTreesInput, TreeOwnerUncheckedCreateWithoutFamilyTreesInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutFamilyTreesInput
    connect?: TreeOwnerWhereUniqueInput
  }

  export type FamilyMemberCreateNestedOneWithoutRootForInput = {
    create?: XOR<FamilyMemberCreateWithoutRootForInput, FamilyMemberUncheckedCreateWithoutRootForInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutRootForInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyMemberCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput> | FamilyMemberCreateWithoutFamilyTreeInput[] | FamilyMemberUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyTreeInput | FamilyMemberCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: FamilyMemberCreateManyFamilyTreeInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type GuestEditorCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput> | GuestEditorCreateWithoutFamilyTreeInput[] | GuestEditorUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyTreeInput | GuestEditorCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: GuestEditorCreateManyFamilyTreeInputEnvelope
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
  }

  export type AchievementTypeCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput> | AchievementTypeCreateWithoutFamilyTreeInput[] | AchievementTypeUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutFamilyTreeInput | AchievementTypeCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: AchievementTypeCreateManyFamilyTreeInputEnvelope
    connect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput> | FamilyMemberCreateWithoutFamilyTreeInput[] | FamilyMemberUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyTreeInput | FamilyMemberCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: FamilyMemberCreateManyFamilyTreeInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput> | GuestEditorCreateWithoutFamilyTreeInput[] | GuestEditorUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyTreeInput | GuestEditorCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: GuestEditorCreateManyFamilyTreeInputEnvelope
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
  }

  export type AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput = {
    create?: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput> | AchievementTypeCreateWithoutFamilyTreeInput[] | AchievementTypeUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutFamilyTreeInput | AchievementTypeCreateOrConnectWithoutFamilyTreeInput[]
    createMany?: AchievementTypeCreateManyFamilyTreeInputEnvelope
    connect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput = {
    create?: XOR<TreeOwnerCreateWithoutFamilyTreesInput, TreeOwnerUncheckedCreateWithoutFamilyTreesInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutFamilyTreesInput
    upsert?: TreeOwnerUpsertWithoutFamilyTreesInput
    connect?: TreeOwnerWhereUniqueInput
    update?: XOR<XOR<TreeOwnerUpdateToOneWithWhereWithoutFamilyTreesInput, TreeOwnerUpdateWithoutFamilyTreesInput>, TreeOwnerUncheckedUpdateWithoutFamilyTreesInput>
  }

  export type FamilyMemberUpdateOneWithoutRootForNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutRootForInput, FamilyMemberUncheckedCreateWithoutRootForInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutRootForInput
    upsert?: FamilyMemberUpsertWithoutRootForInput
    disconnect?: FamilyMemberWhereInput | boolean
    delete?: FamilyMemberWhereInput | boolean
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutRootForInput, FamilyMemberUpdateWithoutRootForInput>, FamilyMemberUncheckedUpdateWithoutRootForInput>
  }

  export type FamilyMemberUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput> | FamilyMemberCreateWithoutFamilyTreeInput[] | FamilyMemberUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyTreeInput | FamilyMemberCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutFamilyTreeInput | FamilyMemberUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: FamilyMemberCreateManyFamilyTreeInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutFamilyTreeInput | FamilyMemberUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutFamilyTreeInput | FamilyMemberUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type GuestEditorUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput> | GuestEditorCreateWithoutFamilyTreeInput[] | GuestEditorUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyTreeInput | GuestEditorCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: GuestEditorUpsertWithWhereUniqueWithoutFamilyTreeInput | GuestEditorUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: GuestEditorCreateManyFamilyTreeInputEnvelope
    set?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    disconnect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    delete?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    update?: GuestEditorUpdateWithWhereUniqueWithoutFamilyTreeInput | GuestEditorUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: GuestEditorUpdateManyWithWhereWithoutFamilyTreeInput | GuestEditorUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
  }

  export type AchievementTypeUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput> | AchievementTypeCreateWithoutFamilyTreeInput[] | AchievementTypeUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutFamilyTreeInput | AchievementTypeCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: AchievementTypeUpsertWithWhereUniqueWithoutFamilyTreeInput | AchievementTypeUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: AchievementTypeCreateManyFamilyTreeInputEnvelope
    set?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    disconnect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    delete?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    connect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    update?: AchievementTypeUpdateWithWhereUniqueWithoutFamilyTreeInput | AchievementTypeUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: AchievementTypeUpdateManyWithWhereWithoutFamilyTreeInput | AchievementTypeUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: AchievementTypeScalarWhereInput | AchievementTypeScalarWhereInput[]
  }

  export type FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput> | FamilyMemberCreateWithoutFamilyTreeInput[] | FamilyMemberUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyTreeInput | FamilyMemberCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutFamilyTreeInput | FamilyMemberUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: FamilyMemberCreateManyFamilyTreeInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutFamilyTreeInput | FamilyMemberUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutFamilyTreeInput | FamilyMemberUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput> | GuestEditorCreateWithoutFamilyTreeInput[] | GuestEditorUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyTreeInput | GuestEditorCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: GuestEditorUpsertWithWhereUniqueWithoutFamilyTreeInput | GuestEditorUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: GuestEditorCreateManyFamilyTreeInputEnvelope
    set?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    disconnect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    delete?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    update?: GuestEditorUpdateWithWhereUniqueWithoutFamilyTreeInput | GuestEditorUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: GuestEditorUpdateManyWithWhereWithoutFamilyTreeInput | GuestEditorUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
  }

  export type AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput = {
    create?: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput> | AchievementTypeCreateWithoutFamilyTreeInput[] | AchievementTypeUncheckedCreateWithoutFamilyTreeInput[]
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutFamilyTreeInput | AchievementTypeCreateOrConnectWithoutFamilyTreeInput[]
    upsert?: AchievementTypeUpsertWithWhereUniqueWithoutFamilyTreeInput | AchievementTypeUpsertWithWhereUniqueWithoutFamilyTreeInput[]
    createMany?: AchievementTypeCreateManyFamilyTreeInputEnvelope
    set?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    disconnect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    delete?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    connect?: AchievementTypeWhereUniqueInput | AchievementTypeWhereUniqueInput[]
    update?: AchievementTypeUpdateWithWhereUniqueWithoutFamilyTreeInput | AchievementTypeUpdateWithWhereUniqueWithoutFamilyTreeInput[]
    updateMany?: AchievementTypeUpdateManyWithWhereWithoutFamilyTreeInput | AchievementTypeUpdateManyWithWhereWithoutFamilyTreeInput[]
    deleteMany?: AchievementTypeScalarWhereInput | AchievementTypeScalarWhereInput[]
  }

  export type FamilyTreeCreateNestedOneWithoutFamilyMembersInput = {
    create?: XOR<FamilyTreeCreateWithoutFamilyMembersInput, FamilyTreeUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutFamilyMembersInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type FamilyMemberCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FamilyMemberCreateWithoutChildrenInput, FamilyMemberUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutChildrenInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyMemberCreateNestedManyWithoutParentInput = {
    create?: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput> | FamilyMemberCreateWithoutParentInput[] | FamilyMemberUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutParentInput | FamilyMemberCreateOrConnectWithoutParentInput[]
    createMany?: FamilyMemberCreateManyParentInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type AchievementCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput> | AchievementCreateWithoutFamilyMemberInput[] | AchievementUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutFamilyMemberInput | AchievementCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: AchievementCreateManyFamilyMemberInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type PassingRecordCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput> | PassingRecordCreateWithoutFamilyMemberInput[] | PassingRecordUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: PassingRecordCreateOrConnectWithoutFamilyMemberInput | PassingRecordCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: PassingRecordCreateManyFamilyMemberInputEnvelope
    connect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
  }

  export type CauseOfDeathCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput> | CauseOfDeathCreateWithoutFamilyMemberInput[] | CauseOfDeathUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutFamilyMemberInput | CauseOfDeathCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: CauseOfDeathCreateManyFamilyMemberInputEnvelope
    connect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
  }

  export type OccupationCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput> | OccupationCreateWithoutFamilyMemberInput[] | OccupationUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: OccupationCreateOrConnectWithoutFamilyMemberInput | OccupationCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: OccupationCreateManyFamilyMemberInputEnvelope
    connect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
  }

  export type FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput> | FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInputEnvelope
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
  }

  export type SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input> | SpouseRelationshipCreateWithoutFamilyMember1Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember1InputEnvelope
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
  }

  export type SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input> | SpouseRelationshipCreateWithoutFamilyMember2Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember2InputEnvelope
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
  }

  export type GuestEditorCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput> | GuestEditorCreateWithoutFamilyMemberInput[] | GuestEditorUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyMemberInput | GuestEditorCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: GuestEditorCreateManyFamilyMemberInputEnvelope
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
  }

  export type FamilyTreeCreateNestedOneWithoutRootMemberInput = {
    create?: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutRootMemberInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput> | FamilyMemberCreateWithoutParentInput[] | FamilyMemberUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutParentInput | FamilyMemberCreateOrConnectWithoutParentInput[]
    createMany?: FamilyMemberCreateManyParentInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput> | AchievementCreateWithoutFamilyMemberInput[] | AchievementUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutFamilyMemberInput | AchievementCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: AchievementCreateManyFamilyMemberInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput> | PassingRecordCreateWithoutFamilyMemberInput[] | PassingRecordUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: PassingRecordCreateOrConnectWithoutFamilyMemberInput | PassingRecordCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: PassingRecordCreateManyFamilyMemberInputEnvelope
    connect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
  }

  export type CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput> | CauseOfDeathCreateWithoutFamilyMemberInput[] | CauseOfDeathUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutFamilyMemberInput | CauseOfDeathCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: CauseOfDeathCreateManyFamilyMemberInputEnvelope
    connect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
  }

  export type OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput> | OccupationCreateWithoutFamilyMemberInput[] | OccupationUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: OccupationCreateOrConnectWithoutFamilyMemberInput | OccupationCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: OccupationCreateManyFamilyMemberInputEnvelope
    connect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput> | FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInputEnvelope
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
  }

  export type SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input> | SpouseRelationshipCreateWithoutFamilyMember1Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember1InputEnvelope
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
  }

  export type SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input> | SpouseRelationshipCreateWithoutFamilyMember2Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember2InputEnvelope
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
  }

  export type GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput> | GuestEditorCreateWithoutFamilyMemberInput[] | GuestEditorUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyMemberInput | GuestEditorCreateOrConnectWithoutFamilyMemberInput[]
    createMany?: GuestEditorCreateManyFamilyMemberInputEnvelope
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
  }

  export type FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput = {
    create?: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutRootMemberInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutFamilyMembersInput, FamilyTreeUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutFamilyMembersInput
    upsert?: FamilyTreeUpsertWithoutFamilyMembersInput
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<XOR<FamilyTreeUpdateToOneWithWhereWithoutFamilyMembersInput, FamilyTreeUpdateWithoutFamilyMembersInput>, FamilyTreeUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type FamilyMemberUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutChildrenInput, FamilyMemberUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutChildrenInput
    upsert?: FamilyMemberUpsertWithoutChildrenInput
    disconnect?: FamilyMemberWhereInput | boolean
    delete?: FamilyMemberWhereInput | boolean
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutChildrenInput, FamilyMemberUpdateWithoutChildrenInput>, FamilyMemberUncheckedUpdateWithoutChildrenInput>
  }

  export type FamilyMemberUpdateManyWithoutParentNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput> | FamilyMemberCreateWithoutParentInput[] | FamilyMemberUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutParentInput | FamilyMemberCreateOrConnectWithoutParentInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutParentInput | FamilyMemberUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FamilyMemberCreateManyParentInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutParentInput | FamilyMemberUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutParentInput | FamilyMemberUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type AchievementUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput> | AchievementCreateWithoutFamilyMemberInput[] | AchievementUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutFamilyMemberInput | AchievementCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutFamilyMemberInput | AchievementUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: AchievementCreateManyFamilyMemberInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutFamilyMemberInput | AchievementUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutFamilyMemberInput | AchievementUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type PassingRecordUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput> | PassingRecordCreateWithoutFamilyMemberInput[] | PassingRecordUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: PassingRecordCreateOrConnectWithoutFamilyMemberInput | PassingRecordCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: PassingRecordUpsertWithWhereUniqueWithoutFamilyMemberInput | PassingRecordUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: PassingRecordCreateManyFamilyMemberInputEnvelope
    set?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    disconnect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    delete?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    connect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    update?: PassingRecordUpdateWithWhereUniqueWithoutFamilyMemberInput | PassingRecordUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: PassingRecordUpdateManyWithWhereWithoutFamilyMemberInput | PassingRecordUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: PassingRecordScalarWhereInput | PassingRecordScalarWhereInput[]
  }

  export type CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput> | CauseOfDeathCreateWithoutFamilyMemberInput[] | CauseOfDeathUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutFamilyMemberInput | CauseOfDeathCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: CauseOfDeathUpsertWithWhereUniqueWithoutFamilyMemberInput | CauseOfDeathUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: CauseOfDeathCreateManyFamilyMemberInputEnvelope
    set?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    disconnect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    delete?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    connect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    update?: CauseOfDeathUpdateWithWhereUniqueWithoutFamilyMemberInput | CauseOfDeathUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: CauseOfDeathUpdateManyWithWhereWithoutFamilyMemberInput | CauseOfDeathUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: CauseOfDeathScalarWhereInput | CauseOfDeathScalarWhereInput[]
  }

  export type OccupationUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput> | OccupationCreateWithoutFamilyMemberInput[] | OccupationUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: OccupationCreateOrConnectWithoutFamilyMemberInput | OccupationCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: OccupationUpsertWithWhereUniqueWithoutFamilyMemberInput | OccupationUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: OccupationCreateManyFamilyMemberInputEnvelope
    set?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    disconnect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    delete?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    connect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    update?: OccupationUpdateWithWhereUniqueWithoutFamilyMemberInput | OccupationUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: OccupationUpdateManyWithWhereWithoutFamilyMemberInput | OccupationUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: OccupationScalarWhereInput | OccupationScalarWhereInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput> | FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInputEnvelope
    set?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    disconnect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    delete?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    update?: FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
  }

  export type SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input> | SpouseRelationshipCreateWithoutFamilyMember1Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input[]
    upsert?: SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember1Input | SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember1Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember1InputEnvelope
    set?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    disconnect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    delete?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    update?: SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember1Input | SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember1Input[]
    updateMany?: SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember1Input | SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember1Input[]
    deleteMany?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
  }

  export type SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input> | SpouseRelationshipCreateWithoutFamilyMember2Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input[]
    upsert?: SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember2Input | SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember2Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember2InputEnvelope
    set?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    disconnect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    delete?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    update?: SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember2Input | SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember2Input[]
    updateMany?: SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember2Input | SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember2Input[]
    deleteMany?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
  }

  export type GuestEditorUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput> | GuestEditorCreateWithoutFamilyMemberInput[] | GuestEditorUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyMemberInput | GuestEditorCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: GuestEditorUpsertWithWhereUniqueWithoutFamilyMemberInput | GuestEditorUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: GuestEditorCreateManyFamilyMemberInputEnvelope
    set?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    disconnect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    delete?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    update?: GuestEditorUpdateWithWhereUniqueWithoutFamilyMemberInput | GuestEditorUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: GuestEditorUpdateManyWithWhereWithoutFamilyMemberInput | GuestEditorUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
  }

  export type FamilyTreeUpdateOneWithoutRootMemberNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutRootMemberInput
    upsert?: FamilyTreeUpsertWithoutRootMemberInput
    disconnect?: FamilyTreeWhereInput | boolean
    delete?: FamilyTreeWhereInput | boolean
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<XOR<FamilyTreeUpdateToOneWithWhereWithoutRootMemberInput, FamilyTreeUpdateWithoutRootMemberInput>, FamilyTreeUncheckedUpdateWithoutRootMemberInput>
  }

  export type FamilyMemberUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput> | FamilyMemberCreateWithoutParentInput[] | FamilyMemberUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutParentInput | FamilyMemberCreateOrConnectWithoutParentInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutParentInput | FamilyMemberUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FamilyMemberCreateManyParentInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutParentInput | FamilyMemberUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutParentInput | FamilyMemberUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput> | AchievementCreateWithoutFamilyMemberInput[] | AchievementUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutFamilyMemberInput | AchievementCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutFamilyMemberInput | AchievementUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: AchievementCreateManyFamilyMemberInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutFamilyMemberInput | AchievementUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutFamilyMemberInput | AchievementUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput> | PassingRecordCreateWithoutFamilyMemberInput[] | PassingRecordUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: PassingRecordCreateOrConnectWithoutFamilyMemberInput | PassingRecordCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: PassingRecordUpsertWithWhereUniqueWithoutFamilyMemberInput | PassingRecordUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: PassingRecordCreateManyFamilyMemberInputEnvelope
    set?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    disconnect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    delete?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    connect?: PassingRecordWhereUniqueInput | PassingRecordWhereUniqueInput[]
    update?: PassingRecordUpdateWithWhereUniqueWithoutFamilyMemberInput | PassingRecordUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: PassingRecordUpdateManyWithWhereWithoutFamilyMemberInput | PassingRecordUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: PassingRecordScalarWhereInput | PassingRecordScalarWhereInput[]
  }

  export type CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput> | CauseOfDeathCreateWithoutFamilyMemberInput[] | CauseOfDeathUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutFamilyMemberInput | CauseOfDeathCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: CauseOfDeathUpsertWithWhereUniqueWithoutFamilyMemberInput | CauseOfDeathUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: CauseOfDeathCreateManyFamilyMemberInputEnvelope
    set?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    disconnect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    delete?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    connect?: CauseOfDeathWhereUniqueInput | CauseOfDeathWhereUniqueInput[]
    update?: CauseOfDeathUpdateWithWhereUniqueWithoutFamilyMemberInput | CauseOfDeathUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: CauseOfDeathUpdateManyWithWhereWithoutFamilyMemberInput | CauseOfDeathUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: CauseOfDeathScalarWhereInput | CauseOfDeathScalarWhereInput[]
  }

  export type OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput> | OccupationCreateWithoutFamilyMemberInput[] | OccupationUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: OccupationCreateOrConnectWithoutFamilyMemberInput | OccupationCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: OccupationUpsertWithWhereUniqueWithoutFamilyMemberInput | OccupationUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: OccupationCreateManyFamilyMemberInputEnvelope
    set?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    disconnect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    delete?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    connect?: OccupationWhereUniqueInput | OccupationWhereUniqueInput[]
    update?: OccupationUpdateWithWhereUniqueWithoutFamilyMemberInput | OccupationUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: OccupationUpdateManyWithWhereWithoutFamilyMemberInput | OccupationUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: OccupationScalarWhereInput | OccupationScalarWhereInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput> | FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInputEnvelope
    set?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    disconnect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    delete?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    update?: FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutFamilyMemberInput | FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
  }

  export type SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input> | SpouseRelationshipCreateWithoutFamilyMember1Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input[]
    upsert?: SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember1Input | SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember1Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember1InputEnvelope
    set?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    disconnect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    delete?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    update?: SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember1Input | SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember1Input[]
    updateMany?: SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember1Input | SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember1Input[]
    deleteMany?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
  }

  export type SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput = {
    create?: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input> | SpouseRelationshipCreateWithoutFamilyMember2Input[] | SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input[]
    connectOrCreate?: SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input | SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input[]
    upsert?: SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember2Input | SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember2Input[]
    createMany?: SpouseRelationshipCreateManyFamilyMember2InputEnvelope
    set?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    disconnect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    delete?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    connect?: SpouseRelationshipWhereUniqueInput | SpouseRelationshipWhereUniqueInput[]
    update?: SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember2Input | SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember2Input[]
    updateMany?: SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember2Input | SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember2Input[]
    deleteMany?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
  }

  export type GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput = {
    create?: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput> | GuestEditorCreateWithoutFamilyMemberInput[] | GuestEditorUncheckedCreateWithoutFamilyMemberInput[]
    connectOrCreate?: GuestEditorCreateOrConnectWithoutFamilyMemberInput | GuestEditorCreateOrConnectWithoutFamilyMemberInput[]
    upsert?: GuestEditorUpsertWithWhereUniqueWithoutFamilyMemberInput | GuestEditorUpsertWithWhereUniqueWithoutFamilyMemberInput[]
    createMany?: GuestEditorCreateManyFamilyMemberInputEnvelope
    set?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    disconnect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    delete?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    connect?: GuestEditorWhereUniqueInput | GuestEditorWhereUniqueInput[]
    update?: GuestEditorUpdateWithWhereUniqueWithoutFamilyMemberInput | GuestEditorUpdateWithWhereUniqueWithoutFamilyMemberInput[]
    updateMany?: GuestEditorUpdateManyWithWhereWithoutFamilyMemberInput | GuestEditorUpdateManyWithWhereWithoutFamilyMemberInput[]
    deleteMany?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
  }

  export type FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutRootMemberInput
    upsert?: FamilyTreeUpsertWithoutRootMemberInput
    disconnect?: FamilyTreeWhereInput | boolean
    delete?: FamilyTreeWhereInput | boolean
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<XOR<FamilyTreeUpdateToOneWithWhereWithoutRootMemberInput, FamilyTreeUpdateWithoutRootMemberInput>, FamilyTreeUncheckedUpdateWithoutRootMemberInput>
  }

  export type FamilyMemberCreateNestedOneWithoutOccupationsInput = {
    create?: XOR<FamilyMemberCreateWithoutOccupationsInput, FamilyMemberUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutOccupationsInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyMemberUpdateOneRequiredWithoutOccupationsNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutOccupationsInput, FamilyMemberUncheckedCreateWithoutOccupationsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutOccupationsInput
    upsert?: FamilyMemberUpsertWithoutOccupationsInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutOccupationsInput, FamilyMemberUpdateWithoutOccupationsInput>, FamilyMemberUncheckedUpdateWithoutOccupationsInput>
  }

  export type FamilyMemberCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<FamilyMemberCreateWithoutAchievementsInput, FamilyMemberUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutAchievementsInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type AchievementTypeCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<AchievementTypeCreateWithoutAchievementsInput, AchievementTypeUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutAchievementsInput
    connect?: AchievementTypeWhereUniqueInput
  }

  export type FamilyMemberUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutAchievementsInput, FamilyMemberUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutAchievementsInput
    upsert?: FamilyMemberUpsertWithoutAchievementsInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutAchievementsInput, FamilyMemberUpdateWithoutAchievementsInput>, FamilyMemberUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementTypeUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<AchievementTypeCreateWithoutAchievementsInput, AchievementTypeUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: AchievementTypeCreateOrConnectWithoutAchievementsInput
    upsert?: AchievementTypeUpsertWithoutAchievementsInput
    connect?: AchievementTypeWhereUniqueInput
    update?: XOR<XOR<AchievementTypeUpdateToOneWithWhereWithoutAchievementsInput, AchievementTypeUpdateWithoutAchievementsInput>, AchievementTypeUncheckedUpdateWithoutAchievementsInput>
  }

  export type FamilyTreeCreateNestedOneWithoutAchievementTypesInput = {
    create?: XOR<FamilyTreeCreateWithoutAchievementTypesInput, FamilyTreeUncheckedCreateWithoutAchievementTypesInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutAchievementTypesInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type AchievementCreateNestedManyWithoutAchievementTypeInput = {
    create?: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput> | AchievementCreateWithoutAchievementTypeInput[] | AchievementUncheckedCreateWithoutAchievementTypeInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutAchievementTypeInput | AchievementCreateOrConnectWithoutAchievementTypeInput[]
    createMany?: AchievementCreateManyAchievementTypeInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutAchievementTypeInput = {
    create?: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput> | AchievementCreateWithoutAchievementTypeInput[] | AchievementUncheckedCreateWithoutAchievementTypeInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutAchievementTypeInput | AchievementCreateOrConnectWithoutAchievementTypeInput[]
    createMany?: AchievementCreateManyAchievementTypeInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type FamilyTreeUpdateOneRequiredWithoutAchievementTypesNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutAchievementTypesInput, FamilyTreeUncheckedCreateWithoutAchievementTypesInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutAchievementTypesInput
    upsert?: FamilyTreeUpsertWithoutAchievementTypesInput
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<XOR<FamilyTreeUpdateToOneWithWhereWithoutAchievementTypesInput, FamilyTreeUpdateWithoutAchievementTypesInput>, FamilyTreeUncheckedUpdateWithoutAchievementTypesInput>
  }

  export type AchievementUpdateManyWithoutAchievementTypeNestedInput = {
    create?: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput> | AchievementCreateWithoutAchievementTypeInput[] | AchievementUncheckedCreateWithoutAchievementTypeInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutAchievementTypeInput | AchievementCreateOrConnectWithoutAchievementTypeInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutAchievementTypeInput | AchievementUpsertWithWhereUniqueWithoutAchievementTypeInput[]
    createMany?: AchievementCreateManyAchievementTypeInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutAchievementTypeInput | AchievementUpdateWithWhereUniqueWithoutAchievementTypeInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutAchievementTypeInput | AchievementUpdateManyWithWhereWithoutAchievementTypeInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutAchievementTypeNestedInput = {
    create?: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput> | AchievementCreateWithoutAchievementTypeInput[] | AchievementUncheckedCreateWithoutAchievementTypeInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutAchievementTypeInput | AchievementCreateOrConnectWithoutAchievementTypeInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutAchievementTypeInput | AchievementUpsertWithWhereUniqueWithoutAchievementTypeInput[]
    createMany?: AchievementCreateManyAchievementTypeInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutAchievementTypeInput | AchievementUpdateWithWhereUniqueWithoutAchievementTypeInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutAchievementTypeInput | AchievementUpdateManyWithWhereWithoutAchievementTypeInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type FamilyMemberCreateNestedOneWithoutPassingRecordsInput = {
    create?: XOR<FamilyMemberCreateWithoutPassingRecordsInput, FamilyMemberUncheckedCreateWithoutPassingRecordsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutPassingRecordsInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type CauseOfDeathCreateNestedOneWithoutPassingRecordInput = {
    create?: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutPassingRecordInput
    connect?: CauseOfDeathWhereUniqueInput
  }

  export type BuriedPlaceCreateNestedManyWithoutPassingRecordInput = {
    create?: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput> | BuriedPlaceCreateWithoutPassingRecordInput[] | BuriedPlaceUncheckedCreateWithoutPassingRecordInput[]
    connectOrCreate?: BuriedPlaceCreateOrConnectWithoutPassingRecordInput | BuriedPlaceCreateOrConnectWithoutPassingRecordInput[]
    createMany?: BuriedPlaceCreateManyPassingRecordInputEnvelope
    connect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
  }

  export type CauseOfDeathUncheckedCreateNestedOneWithoutPassingRecordInput = {
    create?: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutPassingRecordInput
    connect?: CauseOfDeathWhereUniqueInput
  }

  export type BuriedPlaceUncheckedCreateNestedManyWithoutPassingRecordInput = {
    create?: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput> | BuriedPlaceCreateWithoutPassingRecordInput[] | BuriedPlaceUncheckedCreateWithoutPassingRecordInput[]
    connectOrCreate?: BuriedPlaceCreateOrConnectWithoutPassingRecordInput | BuriedPlaceCreateOrConnectWithoutPassingRecordInput[]
    createMany?: BuriedPlaceCreateManyPassingRecordInputEnvelope
    connect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
  }

  export type FamilyMemberUpdateOneRequiredWithoutPassingRecordsNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutPassingRecordsInput, FamilyMemberUncheckedCreateWithoutPassingRecordsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutPassingRecordsInput
    upsert?: FamilyMemberUpsertWithoutPassingRecordsInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutPassingRecordsInput, FamilyMemberUpdateWithoutPassingRecordsInput>, FamilyMemberUncheckedUpdateWithoutPassingRecordsInput>
  }

  export type CauseOfDeathUpdateOneWithoutPassingRecordNestedInput = {
    create?: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutPassingRecordInput
    upsert?: CauseOfDeathUpsertWithoutPassingRecordInput
    disconnect?: CauseOfDeathWhereInput | boolean
    delete?: CauseOfDeathWhereInput | boolean
    connect?: CauseOfDeathWhereUniqueInput
    update?: XOR<XOR<CauseOfDeathUpdateToOneWithWhereWithoutPassingRecordInput, CauseOfDeathUpdateWithoutPassingRecordInput>, CauseOfDeathUncheckedUpdateWithoutPassingRecordInput>
  }

  export type BuriedPlaceUpdateManyWithoutPassingRecordNestedInput = {
    create?: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput> | BuriedPlaceCreateWithoutPassingRecordInput[] | BuriedPlaceUncheckedCreateWithoutPassingRecordInput[]
    connectOrCreate?: BuriedPlaceCreateOrConnectWithoutPassingRecordInput | BuriedPlaceCreateOrConnectWithoutPassingRecordInput[]
    upsert?: BuriedPlaceUpsertWithWhereUniqueWithoutPassingRecordInput | BuriedPlaceUpsertWithWhereUniqueWithoutPassingRecordInput[]
    createMany?: BuriedPlaceCreateManyPassingRecordInputEnvelope
    set?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    disconnect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    delete?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    connect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    update?: BuriedPlaceUpdateWithWhereUniqueWithoutPassingRecordInput | BuriedPlaceUpdateWithWhereUniqueWithoutPassingRecordInput[]
    updateMany?: BuriedPlaceUpdateManyWithWhereWithoutPassingRecordInput | BuriedPlaceUpdateManyWithWhereWithoutPassingRecordInput[]
    deleteMany?: BuriedPlaceScalarWhereInput | BuriedPlaceScalarWhereInput[]
  }

  export type CauseOfDeathUncheckedUpdateOneWithoutPassingRecordNestedInput = {
    create?: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
    connectOrCreate?: CauseOfDeathCreateOrConnectWithoutPassingRecordInput
    upsert?: CauseOfDeathUpsertWithoutPassingRecordInput
    disconnect?: CauseOfDeathWhereInput | boolean
    delete?: CauseOfDeathWhereInput | boolean
    connect?: CauseOfDeathWhereUniqueInput
    update?: XOR<XOR<CauseOfDeathUpdateToOneWithWhereWithoutPassingRecordInput, CauseOfDeathUpdateWithoutPassingRecordInput>, CauseOfDeathUncheckedUpdateWithoutPassingRecordInput>
  }

  export type BuriedPlaceUncheckedUpdateManyWithoutPassingRecordNestedInput = {
    create?: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput> | BuriedPlaceCreateWithoutPassingRecordInput[] | BuriedPlaceUncheckedCreateWithoutPassingRecordInput[]
    connectOrCreate?: BuriedPlaceCreateOrConnectWithoutPassingRecordInput | BuriedPlaceCreateOrConnectWithoutPassingRecordInput[]
    upsert?: BuriedPlaceUpsertWithWhereUniqueWithoutPassingRecordInput | BuriedPlaceUpsertWithWhereUniqueWithoutPassingRecordInput[]
    createMany?: BuriedPlaceCreateManyPassingRecordInputEnvelope
    set?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    disconnect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    delete?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    connect?: BuriedPlaceWhereUniqueInput | BuriedPlaceWhereUniqueInput[]
    update?: BuriedPlaceUpdateWithWhereUniqueWithoutPassingRecordInput | BuriedPlaceUpdateWithWhereUniqueWithoutPassingRecordInput[]
    updateMany?: BuriedPlaceUpdateManyWithWhereWithoutPassingRecordInput | BuriedPlaceUpdateManyWithWhereWithoutPassingRecordInput[]
    deleteMany?: BuriedPlaceScalarWhereInput | BuriedPlaceScalarWhereInput[]
  }

  export type PassingRecordCreateNestedOneWithoutCauseOfDeathInput = {
    create?: XOR<PassingRecordCreateWithoutCauseOfDeathInput, PassingRecordUncheckedCreateWithoutCauseOfDeathInput>
    connectOrCreate?: PassingRecordCreateOrConnectWithoutCauseOfDeathInput
    connect?: PassingRecordWhereUniqueInput
  }

  export type FamilyMemberCreateNestedOneWithoutCausesOfDeathInput = {
    create?: XOR<FamilyMemberCreateWithoutCausesOfDeathInput, FamilyMemberUncheckedCreateWithoutCausesOfDeathInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutCausesOfDeathInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type PassingRecordUpdateOneRequiredWithoutCauseOfDeathNestedInput = {
    create?: XOR<PassingRecordCreateWithoutCauseOfDeathInput, PassingRecordUncheckedCreateWithoutCauseOfDeathInput>
    connectOrCreate?: PassingRecordCreateOrConnectWithoutCauseOfDeathInput
    upsert?: PassingRecordUpsertWithoutCauseOfDeathInput
    connect?: PassingRecordWhereUniqueInput
    update?: XOR<XOR<PassingRecordUpdateToOneWithWhereWithoutCauseOfDeathInput, PassingRecordUpdateWithoutCauseOfDeathInput>, PassingRecordUncheckedUpdateWithoutCauseOfDeathInput>
  }

  export type FamilyMemberUpdateOneRequiredWithoutCausesOfDeathNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutCausesOfDeathInput, FamilyMemberUncheckedCreateWithoutCausesOfDeathInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutCausesOfDeathInput
    upsert?: FamilyMemberUpsertWithoutCausesOfDeathInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutCausesOfDeathInput, FamilyMemberUpdateWithoutCausesOfDeathInput>, FamilyMemberUncheckedUpdateWithoutCausesOfDeathInput>
  }

  export type PassingRecordCreateNestedOneWithoutBuriedPlacesInput = {
    create?: XOR<PassingRecordCreateWithoutBuriedPlacesInput, PassingRecordUncheckedCreateWithoutBuriedPlacesInput>
    connectOrCreate?: PassingRecordCreateOrConnectWithoutBuriedPlacesInput
    connect?: PassingRecordWhereUniqueInput
  }

  export type PassingRecordUpdateOneRequiredWithoutBuriedPlacesNestedInput = {
    create?: XOR<PassingRecordCreateWithoutBuriedPlacesInput, PassingRecordUncheckedCreateWithoutBuriedPlacesInput>
    connectOrCreate?: PassingRecordCreateOrConnectWithoutBuriedPlacesInput
    upsert?: PassingRecordUpsertWithoutBuriedPlacesInput
    connect?: PassingRecordWhereUniqueInput
    update?: XOR<XOR<PassingRecordUpdateToOneWithWhereWithoutBuriedPlacesInput, PassingRecordUpdateWithoutBuriedPlacesInput>, PassingRecordUncheckedUpdateWithoutBuriedPlacesInput>
  }

  export type FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutPlaceOfOriginInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput> | FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInputEnvelope
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutPlaceOfOriginInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput> | FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInputEnvelope
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUpdateManyWithoutPlaceOfOriginNestedInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput> | FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput[]
    upsert?: FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutPlaceOfOriginInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInputEnvelope
    set?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    disconnect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    delete?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    update?: FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutPlaceOfOriginInput[]
    updateMany?: FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutPlaceOfOriginInput[]
    deleteMany?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutPlaceOfOriginNestedInput = {
    create?: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput> | FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput[] | FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput[]
    connectOrCreate?: FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput[]
    upsert?: FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutPlaceOfOriginInput[]
    createMany?: FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInputEnvelope
    set?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    disconnect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    delete?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    connect?: FamilyMember_has_PlaceOfOriginWhereUniqueInput | FamilyMember_has_PlaceOfOriginWhereUniqueInput[]
    update?: FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutPlaceOfOriginInput[]
    updateMany?: FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutPlaceOfOriginInput[]
    deleteMany?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
  }

  export type FamilyMemberCreateNestedOneWithoutBirthPlacesInput = {
    create?: XOR<FamilyMemberCreateWithoutBirthPlacesInput, FamilyMemberUncheckedCreateWithoutBirthPlacesInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutBirthPlacesInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type PlaceOfOriginCreateNestedOneWithoutFamilyMembersInput = {
    create?: XOR<PlaceOfOriginCreateWithoutFamilyMembersInput, PlaceOfOriginUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: PlaceOfOriginCreateOrConnectWithoutFamilyMembersInput
    connect?: PlaceOfOriginWhereUniqueInput
  }

  export type FamilyMemberUpdateOneRequiredWithoutBirthPlacesNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutBirthPlacesInput, FamilyMemberUncheckedCreateWithoutBirthPlacesInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutBirthPlacesInput
    upsert?: FamilyMemberUpsertWithoutBirthPlacesInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutBirthPlacesInput, FamilyMemberUpdateWithoutBirthPlacesInput>, FamilyMemberUncheckedUpdateWithoutBirthPlacesInput>
  }

  export type PlaceOfOriginUpdateOneRequiredWithoutFamilyMembersNestedInput = {
    create?: XOR<PlaceOfOriginCreateWithoutFamilyMembersInput, PlaceOfOriginUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: PlaceOfOriginCreateOrConnectWithoutFamilyMembersInput
    upsert?: PlaceOfOriginUpsertWithoutFamilyMembersInput
    connect?: PlaceOfOriginWhereUniqueInput
    update?: XOR<XOR<PlaceOfOriginUpdateToOneWithWhereWithoutFamilyMembersInput, PlaceOfOriginUpdateWithoutFamilyMembersInput>, PlaceOfOriginUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type FamilyMemberCreateNestedOneWithoutSpouse1Input = {
    create?: XOR<FamilyMemberCreateWithoutSpouse1Input, FamilyMemberUncheckedCreateWithoutSpouse1Input>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutSpouse1Input
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyMemberCreateNestedOneWithoutSpouse2Input = {
    create?: XOR<FamilyMemberCreateWithoutSpouse2Input, FamilyMemberUncheckedCreateWithoutSpouse2Input>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutSpouse2Input
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyMemberUpdateOneRequiredWithoutSpouse1NestedInput = {
    create?: XOR<FamilyMemberCreateWithoutSpouse1Input, FamilyMemberUncheckedCreateWithoutSpouse1Input>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutSpouse1Input
    upsert?: FamilyMemberUpsertWithoutSpouse1Input
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutSpouse1Input, FamilyMemberUpdateWithoutSpouse1Input>, FamilyMemberUncheckedUpdateWithoutSpouse1Input>
  }

  export type FamilyMemberUpdateOneRequiredWithoutSpouse2NestedInput = {
    create?: XOR<FamilyMemberCreateWithoutSpouse2Input, FamilyMemberUncheckedCreateWithoutSpouse2Input>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutSpouse2Input
    upsert?: FamilyMemberUpsertWithoutSpouse2Input
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutSpouse2Input, FamilyMemberUpdateWithoutSpouse2Input>, FamilyMemberUncheckedUpdateWithoutSpouse2Input>
  }

  export type FamilyMemberCreateNestedOneWithoutGuestEditorsInput = {
    create?: XOR<FamilyMemberCreateWithoutGuestEditorsInput, FamilyMemberUncheckedCreateWithoutGuestEditorsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutGuestEditorsInput
    connect?: FamilyMemberWhereUniqueInput
  }

  export type FamilyTreeCreateNestedOneWithoutGuestEditorsInput = {
    create?: XOR<FamilyTreeCreateWithoutGuestEditorsInput, FamilyTreeUncheckedCreateWithoutGuestEditorsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutGuestEditorsInput
    connect?: FamilyTreeWhereUniqueInput
  }

  export type FamilyMemberUpdateOneRequiredWithoutGuestEditorsNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutGuestEditorsInput, FamilyMemberUncheckedCreateWithoutGuestEditorsInput>
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutGuestEditorsInput
    upsert?: FamilyMemberUpsertWithoutGuestEditorsInput
    connect?: FamilyMemberWhereUniqueInput
    update?: XOR<XOR<FamilyMemberUpdateToOneWithWhereWithoutGuestEditorsInput, FamilyMemberUpdateWithoutGuestEditorsInput>, FamilyMemberUncheckedUpdateWithoutGuestEditorsInput>
  }

  export type FamilyTreeUpdateOneRequiredWithoutGuestEditorsNestedInput = {
    create?: XOR<FamilyTreeCreateWithoutGuestEditorsInput, FamilyTreeUncheckedCreateWithoutGuestEditorsInput>
    connectOrCreate?: FamilyTreeCreateOrConnectWithoutGuestEditorsInput
    upsert?: FamilyTreeUpsertWithoutGuestEditorsInput
    connect?: FamilyTreeWhereUniqueInput
    update?: XOR<XOR<FamilyTreeUpdateToOneWithWhereWithoutGuestEditorsInput, FamilyTreeUpdateWithoutGuestEditorsInput>, FamilyTreeUncheckedUpdateWithoutGuestEditorsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TreeOwnerCreateNestedOneWithoutUserInput = {
    create?: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutUserInput
    connect?: TreeOwnerWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TreeOwnerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutUserInput
    connect?: TreeOwnerWhereUniqueInput
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TreeOwnerUpdateOneWithoutUserNestedInput = {
    create?: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutUserInput
    upsert?: TreeOwnerUpsertWithoutUserInput
    disconnect?: TreeOwnerWhereInput | boolean
    delete?: TreeOwnerWhereInput | boolean
    connect?: TreeOwnerWhereUniqueInput
    update?: XOR<XOR<TreeOwnerUpdateToOneWithWhereWithoutUserInput, TreeOwnerUpdateWithoutUserInput>, TreeOwnerUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TreeOwnerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
    connectOrCreate?: TreeOwnerCreateOrConnectWithoutUserInput
    upsert?: TreeOwnerUpsertWithoutUserInput
    disconnect?: TreeOwnerWhereInput | boolean
    delete?: TreeOwnerWhereInput | boolean
    connect?: TreeOwnerWhereUniqueInput
    update?: XOR<XOR<TreeOwnerUpdateToOneWithWhereWithoutUserInput, TreeOwnerUpdateWithoutUserInput>, TreeOwnerUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | null
    notIn?: $Enums.Gender[] | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutTreeOwnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTreeOwnerInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTreeOwnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTreeOwnerInput, UserUncheckedCreateWithoutTreeOwnerInput>
  }

  export type FamilyTreeCreateWithoutTreeOwnerInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    rootMember?: FamilyMemberCreateNestedOneWithoutRootForInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateWithoutTreeOwnerInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    rootMemberId?: number | null
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeCreateOrConnectWithoutTreeOwnerInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput>
  }

  export type FamilyTreeCreateManyTreeOwnerInputEnvelope = {
    data: FamilyTreeCreateManyTreeOwnerInput | FamilyTreeCreateManyTreeOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTreeOwnerInput = {
    update: XOR<UserUpdateWithoutTreeOwnerInput, UserUncheckedUpdateWithoutTreeOwnerInput>
    create: XOR<UserCreateWithoutTreeOwnerInput, UserUncheckedCreateWithoutTreeOwnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTreeOwnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTreeOwnerInput, UserUncheckedUpdateWithoutTreeOwnerInput>
  }

  export type UserUpdateWithoutTreeOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTreeOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FamilyTreeUpsertWithWhereUniqueWithoutTreeOwnerInput = {
    where: FamilyTreeWhereUniqueInput
    update: XOR<FamilyTreeUpdateWithoutTreeOwnerInput, FamilyTreeUncheckedUpdateWithoutTreeOwnerInput>
    create: XOR<FamilyTreeCreateWithoutTreeOwnerInput, FamilyTreeUncheckedCreateWithoutTreeOwnerInput>
  }

  export type FamilyTreeUpdateWithWhereUniqueWithoutTreeOwnerInput = {
    where: FamilyTreeWhereUniqueInput
    data: XOR<FamilyTreeUpdateWithoutTreeOwnerInput, FamilyTreeUncheckedUpdateWithoutTreeOwnerInput>
  }

  export type FamilyTreeUpdateManyWithWhereWithoutTreeOwnerInput = {
    where: FamilyTreeScalarWhereInput
    data: XOR<FamilyTreeUpdateManyMutationInput, FamilyTreeUncheckedUpdateManyWithoutTreeOwnerInput>
  }

  export type FamilyTreeScalarWhereInput = {
    AND?: FamilyTreeScalarWhereInput | FamilyTreeScalarWhereInput[]
    OR?: FamilyTreeScalarWhereInput[]
    NOT?: FamilyTreeScalarWhereInput | FamilyTreeScalarWhereInput[]
    id?: IntFilter<"FamilyTree"> | number
    familyName?: StringFilter<"FamilyTree"> | string
    origin?: StringNullableFilter<"FamilyTree"> | string | null
    establishYear?: IntNullableFilter<"FamilyTree"> | number | null
    createdAt?: DateTimeFilter<"FamilyTree"> | Date | string
    treeOwnerId?: IntFilter<"FamilyTree"> | number
    rootMemberId?: IntNullableFilter<"FamilyTree"> | number | null
  }

  export type TreeOwnerCreateWithoutFamilyTreesInput = {
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutTreeOwnerInput
  }

  export type TreeOwnerUncheckedCreateWithoutFamilyTreesInput = {
    id?: number
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    userId?: string | null
  }

  export type TreeOwnerCreateOrConnectWithoutFamilyTreesInput = {
    where: TreeOwnerWhereUniqueInput
    create: XOR<TreeOwnerCreateWithoutFamilyTreesInput, TreeOwnerUncheckedCreateWithoutFamilyTreesInput>
  }

  export type FamilyMemberCreateWithoutRootForInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutRootForInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutRootForInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutRootForInput, FamilyMemberUncheckedCreateWithoutRootForInput>
  }

  export type FamilyMemberCreateWithoutFamilyTreeInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutFamilyTreeInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutFamilyTreeInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput>
  }

  export type FamilyMemberCreateManyFamilyTreeInputEnvelope = {
    data: FamilyMemberCreateManyFamilyTreeInput | FamilyMemberCreateManyFamilyTreeInput[]
    skipDuplicates?: boolean
  }

  export type GuestEditorCreateWithoutFamilyTreeInput = {
    accessCode: string
    createDate?: Date | string
    familyMember: FamilyMemberCreateNestedOneWithoutGuestEditorsInput
  }

  export type GuestEditorUncheckedCreateWithoutFamilyTreeInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyMemberId: number
  }

  export type GuestEditorCreateOrConnectWithoutFamilyTreeInput = {
    where: GuestEditorWhereUniqueInput
    create: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput>
  }

  export type GuestEditorCreateManyFamilyTreeInputEnvelope = {
    data: GuestEditorCreateManyFamilyTreeInput | GuestEditorCreateManyFamilyTreeInput[]
    skipDuplicates?: boolean
  }

  export type AchievementTypeCreateWithoutFamilyTreeInput = {
    typeName: string
    achievements?: AchievementCreateNestedManyWithoutAchievementTypeInput
  }

  export type AchievementTypeUncheckedCreateWithoutFamilyTreeInput = {
    id?: number
    typeName: string
    achievements?: AchievementUncheckedCreateNestedManyWithoutAchievementTypeInput
  }

  export type AchievementTypeCreateOrConnectWithoutFamilyTreeInput = {
    where: AchievementTypeWhereUniqueInput
    create: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput>
  }

  export type AchievementTypeCreateManyFamilyTreeInputEnvelope = {
    data: AchievementTypeCreateManyFamilyTreeInput | AchievementTypeCreateManyFamilyTreeInput[]
    skipDuplicates?: boolean
  }

  export type TreeOwnerUpsertWithoutFamilyTreesInput = {
    update: XOR<TreeOwnerUpdateWithoutFamilyTreesInput, TreeOwnerUncheckedUpdateWithoutFamilyTreesInput>
    create: XOR<TreeOwnerCreateWithoutFamilyTreesInput, TreeOwnerUncheckedCreateWithoutFamilyTreesInput>
    where?: TreeOwnerWhereInput
  }

  export type TreeOwnerUpdateToOneWithWhereWithoutFamilyTreesInput = {
    where?: TreeOwnerWhereInput
    data: XOR<TreeOwnerUpdateWithoutFamilyTreesInput, TreeOwnerUncheckedUpdateWithoutFamilyTreesInput>
  }

  export type TreeOwnerUpdateWithoutFamilyTreesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutTreeOwnerNestedInput
  }

  export type TreeOwnerUncheckedUpdateWithoutFamilyTreesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FamilyMemberUpsertWithoutRootForInput = {
    update: XOR<FamilyMemberUpdateWithoutRootForInput, FamilyMemberUncheckedUpdateWithoutRootForInput>
    create: XOR<FamilyMemberCreateWithoutRootForInput, FamilyMemberUncheckedCreateWithoutRootForInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutRootForInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutRootForInput, FamilyMemberUncheckedUpdateWithoutRootForInput>
  }

  export type FamilyMemberUpdateWithoutRootForInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutRootForInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutFamilyTreeInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutFamilyTreeInput, FamilyMemberUncheckedUpdateWithoutFamilyTreeInput>
    create: XOR<FamilyMemberCreateWithoutFamilyTreeInput, FamilyMemberUncheckedCreateWithoutFamilyTreeInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutFamilyTreeInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutFamilyTreeInput, FamilyMemberUncheckedUpdateWithoutFamilyTreeInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutFamilyTreeInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutFamilyTreeInput>
  }

  export type FamilyMemberScalarWhereInput = {
    AND?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    OR?: FamilyMemberScalarWhereInput[]
    NOT?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    id?: IntFilter<"FamilyMember"> | number
    fullName?: StringFilter<"FamilyMember"> | string
    gender?: EnumGenderNullableFilter<"FamilyMember"> | $Enums.Gender | null
    birthday?: DateTimeNullableFilter<"FamilyMember"> | Date | string | null
    address?: StringNullableFilter<"FamilyMember"> | string | null
    profilePicture?: StringNullableFilter<"FamilyMember"> | string | null
    generation?: StringNullableFilter<"FamilyMember"> | string | null
    isRootPerson?: BoolNullableFilter<"FamilyMember"> | boolean | null
    isAdopted?: BoolNullableFilter<"FamilyMember"> | boolean | null
    familyTreeId?: IntFilter<"FamilyMember"> | number
    parentId?: IntNullableFilter<"FamilyMember"> | number | null
  }

  export type GuestEditorUpsertWithWhereUniqueWithoutFamilyTreeInput = {
    where: GuestEditorWhereUniqueInput
    update: XOR<GuestEditorUpdateWithoutFamilyTreeInput, GuestEditorUncheckedUpdateWithoutFamilyTreeInput>
    create: XOR<GuestEditorCreateWithoutFamilyTreeInput, GuestEditorUncheckedCreateWithoutFamilyTreeInput>
  }

  export type GuestEditorUpdateWithWhereUniqueWithoutFamilyTreeInput = {
    where: GuestEditorWhereUniqueInput
    data: XOR<GuestEditorUpdateWithoutFamilyTreeInput, GuestEditorUncheckedUpdateWithoutFamilyTreeInput>
  }

  export type GuestEditorUpdateManyWithWhereWithoutFamilyTreeInput = {
    where: GuestEditorScalarWhereInput
    data: XOR<GuestEditorUpdateManyMutationInput, GuestEditorUncheckedUpdateManyWithoutFamilyTreeInput>
  }

  export type GuestEditorScalarWhereInput = {
    AND?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
    OR?: GuestEditorScalarWhereInput[]
    NOT?: GuestEditorScalarWhereInput | GuestEditorScalarWhereInput[]
    id?: IntFilter<"GuestEditor"> | number
    accessCode?: StringFilter<"GuestEditor"> | string
    createDate?: DateTimeFilter<"GuestEditor"> | Date | string
    familyMemberId?: IntFilter<"GuestEditor"> | number
    familyTreeId?: IntFilter<"GuestEditor"> | number
  }

  export type AchievementTypeUpsertWithWhereUniqueWithoutFamilyTreeInput = {
    where: AchievementTypeWhereUniqueInput
    update: XOR<AchievementTypeUpdateWithoutFamilyTreeInput, AchievementTypeUncheckedUpdateWithoutFamilyTreeInput>
    create: XOR<AchievementTypeCreateWithoutFamilyTreeInput, AchievementTypeUncheckedCreateWithoutFamilyTreeInput>
  }

  export type AchievementTypeUpdateWithWhereUniqueWithoutFamilyTreeInput = {
    where: AchievementTypeWhereUniqueInput
    data: XOR<AchievementTypeUpdateWithoutFamilyTreeInput, AchievementTypeUncheckedUpdateWithoutFamilyTreeInput>
  }

  export type AchievementTypeUpdateManyWithWhereWithoutFamilyTreeInput = {
    where: AchievementTypeScalarWhereInput
    data: XOR<AchievementTypeUpdateManyMutationInput, AchievementTypeUncheckedUpdateManyWithoutFamilyTreeInput>
  }

  export type AchievementTypeScalarWhereInput = {
    AND?: AchievementTypeScalarWhereInput | AchievementTypeScalarWhereInput[]
    OR?: AchievementTypeScalarWhereInput[]
    NOT?: AchievementTypeScalarWhereInput | AchievementTypeScalarWhereInput[]
    id?: IntFilter<"AchievementType"> | number
    typeName?: StringFilter<"AchievementType"> | string
    familyTreeId?: IntFilter<"AchievementType"> | number
  }

  export type FamilyTreeCreateWithoutFamilyMembersInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwner: TreeOwnerCreateNestedOneWithoutFamilyTreesInput
    rootMember?: FamilyMemberCreateNestedOneWithoutRootForInput
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateWithoutFamilyMembersInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    rootMemberId?: number | null
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeCreateOrConnectWithoutFamilyMembersInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutFamilyMembersInput, FamilyTreeUncheckedCreateWithoutFamilyMembersInput>
  }

  export type FamilyMemberCreateWithoutChildrenInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutChildrenInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutChildrenInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutChildrenInput, FamilyMemberUncheckedCreateWithoutChildrenInput>
  }

  export type FamilyMemberCreateWithoutParentInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutParentInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutParentInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput>
  }

  export type FamilyMemberCreateManyParentInputEnvelope = {
    data: FamilyMemberCreateManyParentInput | FamilyMemberCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type AchievementCreateWithoutFamilyMemberInput = {
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    achievementType: AchievementTypeCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateWithoutFamilyMemberInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    achievementTypeId: number
  }

  export type AchievementCreateOrConnectWithoutFamilyMemberInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput>
  }

  export type AchievementCreateManyFamilyMemberInputEnvelope = {
    data: AchievementCreateManyFamilyMemberInput | AchievementCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type PassingRecordCreateWithoutFamilyMemberInput = {
    dateOfPassing: Date | string
    createdAt?: Date | string
    causeOfDeath?: CauseOfDeathCreateNestedOneWithoutPassingRecordInput
    buriedPlaces?: BuriedPlaceCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordUncheckedCreateWithoutFamilyMemberInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
    causeOfDeath?: CauseOfDeathUncheckedCreateNestedOneWithoutPassingRecordInput
    buriedPlaces?: BuriedPlaceUncheckedCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordCreateOrConnectWithoutFamilyMemberInput = {
    where: PassingRecordWhereUniqueInput
    create: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput>
  }

  export type PassingRecordCreateManyFamilyMemberInputEnvelope = {
    data: PassingRecordCreateManyFamilyMemberInput | PassingRecordCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type CauseOfDeathCreateWithoutFamilyMemberInput = {
    causeName: string
    passingRecord: PassingRecordCreateNestedOneWithoutCauseOfDeathInput
  }

  export type CauseOfDeathUncheckedCreateWithoutFamilyMemberInput = {
    id?: number
    causeName: string
    passingRecordId: number
  }

  export type CauseOfDeathCreateOrConnectWithoutFamilyMemberInput = {
    where: CauseOfDeathWhereUniqueInput
    create: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput>
  }

  export type CauseOfDeathCreateManyFamilyMemberInputEnvelope = {
    data: CauseOfDeathCreateManyFamilyMemberInput | CauseOfDeathCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type OccupationCreateWithoutFamilyMemberInput = {
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type OccupationUncheckedCreateWithoutFamilyMemberInput = {
    id?: number
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type OccupationCreateOrConnectWithoutFamilyMemberInput = {
    where: OccupationWhereUniqueInput
    create: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput>
  }

  export type OccupationCreateManyFamilyMemberInputEnvelope = {
    data: OccupationCreateManyFamilyMemberInput | OccupationCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    placeOfOrigin: PlaceOfOriginCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput = {
    placeOfOriginId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutFamilyMemberInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    create: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput>
  }

  export type FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInputEnvelope = {
    data: FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInput | FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type SpouseRelationshipCreateWithoutFamilyMember1Input = {
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember2: FamilyMemberCreateNestedOneWithoutSpouse2Input
  }

  export type SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember2Id: number
  }

  export type SpouseRelationshipCreateOrConnectWithoutFamilyMember1Input = {
    where: SpouseRelationshipWhereUniqueInput
    create: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input>
  }

  export type SpouseRelationshipCreateManyFamilyMember1InputEnvelope = {
    data: SpouseRelationshipCreateManyFamilyMember1Input | SpouseRelationshipCreateManyFamilyMember1Input[]
    skipDuplicates?: boolean
  }

  export type SpouseRelationshipCreateWithoutFamilyMember2Input = {
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1: FamilyMemberCreateNestedOneWithoutSpouse1Input
  }

  export type SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1Id: number
  }

  export type SpouseRelationshipCreateOrConnectWithoutFamilyMember2Input = {
    where: SpouseRelationshipWhereUniqueInput
    create: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input>
  }

  export type SpouseRelationshipCreateManyFamilyMember2InputEnvelope = {
    data: SpouseRelationshipCreateManyFamilyMember2Input | SpouseRelationshipCreateManyFamilyMember2Input[]
    skipDuplicates?: boolean
  }

  export type GuestEditorCreateWithoutFamilyMemberInput = {
    accessCode: string
    createDate?: Date | string
    familyTree: FamilyTreeCreateNestedOneWithoutGuestEditorsInput
  }

  export type GuestEditorUncheckedCreateWithoutFamilyMemberInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyTreeId: number
  }

  export type GuestEditorCreateOrConnectWithoutFamilyMemberInput = {
    where: GuestEditorWhereUniqueInput
    create: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput>
  }

  export type GuestEditorCreateManyFamilyMemberInputEnvelope = {
    data: GuestEditorCreateManyFamilyMemberInput | GuestEditorCreateManyFamilyMemberInput[]
    skipDuplicates?: boolean
  }

  export type FamilyTreeCreateWithoutRootMemberInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwner: TreeOwnerCreateNestedOneWithoutFamilyTreesInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateWithoutRootMemberInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeCreateOrConnectWithoutRootMemberInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
  }

  export type FamilyTreeUpsertWithoutFamilyMembersInput = {
    update: XOR<FamilyTreeUpdateWithoutFamilyMembersInput, FamilyTreeUncheckedUpdateWithoutFamilyMembersInput>
    create: XOR<FamilyTreeCreateWithoutFamilyMembersInput, FamilyTreeUncheckedCreateWithoutFamilyMembersInput>
    where?: FamilyTreeWhereInput
  }

  export type FamilyTreeUpdateToOneWithWhereWithoutFamilyMembersInput = {
    where?: FamilyTreeWhereInput
    data: XOR<FamilyTreeUpdateWithoutFamilyMembersInput, FamilyTreeUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type FamilyTreeUpdateWithoutFamilyMembersInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwner?: TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput
    rootMember?: FamilyMemberUpdateOneWithoutRootForNestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutFamilyMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyMemberUpsertWithoutChildrenInput = {
    update: XOR<FamilyMemberUpdateWithoutChildrenInput, FamilyMemberUncheckedUpdateWithoutChildrenInput>
    create: XOR<FamilyMemberCreateWithoutChildrenInput, FamilyMemberUncheckedCreateWithoutChildrenInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutChildrenInput, FamilyMemberUncheckedUpdateWithoutChildrenInput>
  }

  export type FamilyMemberUpdateWithoutChildrenInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutParentInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutParentInput, FamilyMemberUncheckedUpdateWithoutParentInput>
    create: XOR<FamilyMemberCreateWithoutParentInput, FamilyMemberUncheckedCreateWithoutParentInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutParentInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutParentInput, FamilyMemberUncheckedUpdateWithoutParentInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutParentInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutParentInput>
  }

  export type AchievementUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutFamilyMemberInput, AchievementUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<AchievementCreateWithoutFamilyMemberInput, AchievementUncheckedCreateWithoutFamilyMemberInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutFamilyMemberInput, AchievementUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type AchievementUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: IntFilter<"Achievement"> | number
    title?: StringFilter<"Achievement"> | string
    achieveDate?: DateTimeNullableFilter<"Achievement"> | Date | string | null
    description?: StringNullableFilter<"Achievement"> | string | null
    familyMemberId?: IntFilter<"Achievement"> | number
    achievementTypeId?: IntFilter<"Achievement"> | number
  }

  export type PassingRecordUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: PassingRecordWhereUniqueInput
    update: XOR<PassingRecordUpdateWithoutFamilyMemberInput, PassingRecordUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<PassingRecordCreateWithoutFamilyMemberInput, PassingRecordUncheckedCreateWithoutFamilyMemberInput>
  }

  export type PassingRecordUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: PassingRecordWhereUniqueInput
    data: XOR<PassingRecordUpdateWithoutFamilyMemberInput, PassingRecordUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type PassingRecordUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: PassingRecordScalarWhereInput
    data: XOR<PassingRecordUpdateManyMutationInput, PassingRecordUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type PassingRecordScalarWhereInput = {
    AND?: PassingRecordScalarWhereInput | PassingRecordScalarWhereInput[]
    OR?: PassingRecordScalarWhereInput[]
    NOT?: PassingRecordScalarWhereInput | PassingRecordScalarWhereInput[]
    id?: IntFilter<"PassingRecord"> | number
    dateOfPassing?: DateTimeFilter<"PassingRecord"> | Date | string
    createdAt?: DateTimeFilter<"PassingRecord"> | Date | string
    familyMemberId?: IntFilter<"PassingRecord"> | number
  }

  export type CauseOfDeathUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: CauseOfDeathWhereUniqueInput
    update: XOR<CauseOfDeathUpdateWithoutFamilyMemberInput, CauseOfDeathUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<CauseOfDeathCreateWithoutFamilyMemberInput, CauseOfDeathUncheckedCreateWithoutFamilyMemberInput>
  }

  export type CauseOfDeathUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: CauseOfDeathWhereUniqueInput
    data: XOR<CauseOfDeathUpdateWithoutFamilyMemberInput, CauseOfDeathUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type CauseOfDeathUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: CauseOfDeathScalarWhereInput
    data: XOR<CauseOfDeathUpdateManyMutationInput, CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type CauseOfDeathScalarWhereInput = {
    AND?: CauseOfDeathScalarWhereInput | CauseOfDeathScalarWhereInput[]
    OR?: CauseOfDeathScalarWhereInput[]
    NOT?: CauseOfDeathScalarWhereInput | CauseOfDeathScalarWhereInput[]
    id?: IntFilter<"CauseOfDeath"> | number
    causeName?: StringFilter<"CauseOfDeath"> | string
    passingRecordId?: IntFilter<"CauseOfDeath"> | number
    familyMemberId?: IntFilter<"CauseOfDeath"> | number
  }

  export type OccupationUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: OccupationWhereUniqueInput
    update: XOR<OccupationUpdateWithoutFamilyMemberInput, OccupationUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<OccupationCreateWithoutFamilyMemberInput, OccupationUncheckedCreateWithoutFamilyMemberInput>
  }

  export type OccupationUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: OccupationWhereUniqueInput
    data: XOR<OccupationUpdateWithoutFamilyMemberInput, OccupationUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type OccupationUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: OccupationScalarWhereInput
    data: XOR<OccupationUpdateManyMutationInput, OccupationUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type OccupationScalarWhereInput = {
    AND?: OccupationScalarWhereInput | OccupationScalarWhereInput[]
    OR?: OccupationScalarWhereInput[]
    NOT?: OccupationScalarWhereInput | OccupationScalarWhereInput[]
    id?: IntFilter<"Occupation"> | number
    jobTitle?: StringFilter<"Occupation"> | string
    startDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Occupation"> | Date | string | null
    familyMemberId?: IntFilter<"Occupation"> | number
  }

  export type FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    update: XOR<FamilyMember_has_PlaceOfOriginUpdateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutFamilyMemberInput>
  }

  export type FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateWithoutFamilyMemberInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: FamilyMember_has_PlaceOfOriginScalarWhereInput
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateManyMutationInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type FamilyMember_has_PlaceOfOriginScalarWhereInput = {
    AND?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
    OR?: FamilyMember_has_PlaceOfOriginScalarWhereInput[]
    NOT?: FamilyMember_has_PlaceOfOriginScalarWhereInput | FamilyMember_has_PlaceOfOriginScalarWhereInput[]
    familyMemberId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    placeOfOriginId?: IntFilter<"FamilyMember_has_PlaceOfOrigin"> | number
    startDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
    endDate?: DateTimeNullableFilter<"FamilyMember_has_PlaceOfOrigin"> | Date | string | null
  }

  export type SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember1Input = {
    where: SpouseRelationshipWhereUniqueInput
    update: XOR<SpouseRelationshipUpdateWithoutFamilyMember1Input, SpouseRelationshipUncheckedUpdateWithoutFamilyMember1Input>
    create: XOR<SpouseRelationshipCreateWithoutFamilyMember1Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember1Input>
  }

  export type SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember1Input = {
    where: SpouseRelationshipWhereUniqueInput
    data: XOR<SpouseRelationshipUpdateWithoutFamilyMember1Input, SpouseRelationshipUncheckedUpdateWithoutFamilyMember1Input>
  }

  export type SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember1Input = {
    where: SpouseRelationshipScalarWhereInput
    data: XOR<SpouseRelationshipUpdateManyMutationInput, SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1Input>
  }

  export type SpouseRelationshipScalarWhereInput = {
    AND?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
    OR?: SpouseRelationshipScalarWhereInput[]
    NOT?: SpouseRelationshipScalarWhereInput | SpouseRelationshipScalarWhereInput[]
    id?: IntFilter<"SpouseRelationship"> | number
    marriageDate?: DateTimeFilter<"SpouseRelationship"> | Date | string
    divorceDate?: DateTimeNullableFilter<"SpouseRelationship"> | Date | string | null
    familyMember1Id?: IntFilter<"SpouseRelationship"> | number
    familyMember2Id?: IntFilter<"SpouseRelationship"> | number
  }

  export type SpouseRelationshipUpsertWithWhereUniqueWithoutFamilyMember2Input = {
    where: SpouseRelationshipWhereUniqueInput
    update: XOR<SpouseRelationshipUpdateWithoutFamilyMember2Input, SpouseRelationshipUncheckedUpdateWithoutFamilyMember2Input>
    create: XOR<SpouseRelationshipCreateWithoutFamilyMember2Input, SpouseRelationshipUncheckedCreateWithoutFamilyMember2Input>
  }

  export type SpouseRelationshipUpdateWithWhereUniqueWithoutFamilyMember2Input = {
    where: SpouseRelationshipWhereUniqueInput
    data: XOR<SpouseRelationshipUpdateWithoutFamilyMember2Input, SpouseRelationshipUncheckedUpdateWithoutFamilyMember2Input>
  }

  export type SpouseRelationshipUpdateManyWithWhereWithoutFamilyMember2Input = {
    where: SpouseRelationshipScalarWhereInput
    data: XOR<SpouseRelationshipUpdateManyMutationInput, SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2Input>
  }

  export type GuestEditorUpsertWithWhereUniqueWithoutFamilyMemberInput = {
    where: GuestEditorWhereUniqueInput
    update: XOR<GuestEditorUpdateWithoutFamilyMemberInput, GuestEditorUncheckedUpdateWithoutFamilyMemberInput>
    create: XOR<GuestEditorCreateWithoutFamilyMemberInput, GuestEditorUncheckedCreateWithoutFamilyMemberInput>
  }

  export type GuestEditorUpdateWithWhereUniqueWithoutFamilyMemberInput = {
    where: GuestEditorWhereUniqueInput
    data: XOR<GuestEditorUpdateWithoutFamilyMemberInput, GuestEditorUncheckedUpdateWithoutFamilyMemberInput>
  }

  export type GuestEditorUpdateManyWithWhereWithoutFamilyMemberInput = {
    where: GuestEditorScalarWhereInput
    data: XOR<GuestEditorUpdateManyMutationInput, GuestEditorUncheckedUpdateManyWithoutFamilyMemberInput>
  }

  export type FamilyTreeUpsertWithoutRootMemberInput = {
    update: XOR<FamilyTreeUpdateWithoutRootMemberInput, FamilyTreeUncheckedUpdateWithoutRootMemberInput>
    create: XOR<FamilyTreeCreateWithoutRootMemberInput, FamilyTreeUncheckedCreateWithoutRootMemberInput>
    where?: FamilyTreeWhereInput
  }

  export type FamilyTreeUpdateToOneWithWhereWithoutRootMemberInput = {
    where?: FamilyTreeWhereInput
    data: XOR<FamilyTreeUpdateWithoutRootMemberInput, FamilyTreeUncheckedUpdateWithoutRootMemberInput>
  }

  export type FamilyTreeUpdateWithoutRootMemberInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwner?: TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutRootMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyMemberCreateWithoutOccupationsInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutOccupationsInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutOccupationsInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutOccupationsInput, FamilyMemberUncheckedCreateWithoutOccupationsInput>
  }

  export type FamilyMemberUpsertWithoutOccupationsInput = {
    update: XOR<FamilyMemberUpdateWithoutOccupationsInput, FamilyMemberUncheckedUpdateWithoutOccupationsInput>
    create: XOR<FamilyMemberCreateWithoutOccupationsInput, FamilyMemberUncheckedCreateWithoutOccupationsInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutOccupationsInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutOccupationsInput, FamilyMemberUncheckedUpdateWithoutOccupationsInput>
  }

  export type FamilyMemberUpdateWithoutOccupationsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutOccupationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberCreateWithoutAchievementsInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutAchievementsInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutAchievementsInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutAchievementsInput, FamilyMemberUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementTypeCreateWithoutAchievementsInput = {
    typeName: string
    familyTree: FamilyTreeCreateNestedOneWithoutAchievementTypesInput
  }

  export type AchievementTypeUncheckedCreateWithoutAchievementsInput = {
    id?: number
    typeName: string
    familyTreeId: number
  }

  export type AchievementTypeCreateOrConnectWithoutAchievementsInput = {
    where: AchievementTypeWhereUniqueInput
    create: XOR<AchievementTypeCreateWithoutAchievementsInput, AchievementTypeUncheckedCreateWithoutAchievementsInput>
  }

  export type FamilyMemberUpsertWithoutAchievementsInput = {
    update: XOR<FamilyMemberUpdateWithoutAchievementsInput, FamilyMemberUncheckedUpdateWithoutAchievementsInput>
    create: XOR<FamilyMemberCreateWithoutAchievementsInput, FamilyMemberUncheckedCreateWithoutAchievementsInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutAchievementsInput, FamilyMemberUncheckedUpdateWithoutAchievementsInput>
  }

  export type FamilyMemberUpdateWithoutAchievementsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type AchievementTypeUpsertWithoutAchievementsInput = {
    update: XOR<AchievementTypeUpdateWithoutAchievementsInput, AchievementTypeUncheckedUpdateWithoutAchievementsInput>
    create: XOR<AchievementTypeCreateWithoutAchievementsInput, AchievementTypeUncheckedCreateWithoutAchievementsInput>
    where?: AchievementTypeWhereInput
  }

  export type AchievementTypeUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: AchievementTypeWhereInput
    data: XOR<AchievementTypeUpdateWithoutAchievementsInput, AchievementTypeUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementTypeUpdateWithoutAchievementsInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    familyTree?: FamilyTreeUpdateOneRequiredWithoutAchievementTypesNestedInput
  }

  export type AchievementTypeUncheckedUpdateWithoutAchievementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type FamilyTreeCreateWithoutAchievementTypesInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwner: TreeOwnerCreateNestedOneWithoutFamilyTreesInput
    rootMember?: FamilyMemberCreateNestedOneWithoutRootForInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateWithoutAchievementTypesInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    rootMemberId?: number | null
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeCreateOrConnectWithoutAchievementTypesInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutAchievementTypesInput, FamilyTreeUncheckedCreateWithoutAchievementTypesInput>
  }

  export type AchievementCreateWithoutAchievementTypeInput = {
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMember: FamilyMemberCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateWithoutAchievementTypeInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMemberId: number
  }

  export type AchievementCreateOrConnectWithoutAchievementTypeInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput>
  }

  export type AchievementCreateManyAchievementTypeInputEnvelope = {
    data: AchievementCreateManyAchievementTypeInput | AchievementCreateManyAchievementTypeInput[]
    skipDuplicates?: boolean
  }

  export type FamilyTreeUpsertWithoutAchievementTypesInput = {
    update: XOR<FamilyTreeUpdateWithoutAchievementTypesInput, FamilyTreeUncheckedUpdateWithoutAchievementTypesInput>
    create: XOR<FamilyTreeCreateWithoutAchievementTypesInput, FamilyTreeUncheckedCreateWithoutAchievementTypesInput>
    where?: FamilyTreeWhereInput
  }

  export type FamilyTreeUpdateToOneWithWhereWithoutAchievementTypesInput = {
    where?: FamilyTreeWhereInput
    data: XOR<FamilyTreeUpdateWithoutAchievementTypesInput, FamilyTreeUncheckedUpdateWithoutAchievementTypesInput>
  }

  export type FamilyTreeUpdateWithoutAchievementTypesInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwner?: TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput
    rootMember?: FamilyMemberUpdateOneWithoutRootForNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutAchievementTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type AchievementUpsertWithWhereUniqueWithoutAchievementTypeInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutAchievementTypeInput, AchievementUncheckedUpdateWithoutAchievementTypeInput>
    create: XOR<AchievementCreateWithoutAchievementTypeInput, AchievementUncheckedCreateWithoutAchievementTypeInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutAchievementTypeInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutAchievementTypeInput, AchievementUncheckedUpdateWithoutAchievementTypeInput>
  }

  export type AchievementUpdateManyWithWhereWithoutAchievementTypeInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutAchievementTypeInput>
  }

  export type FamilyMemberCreateWithoutPassingRecordsInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutPassingRecordsInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutPassingRecordsInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutPassingRecordsInput, FamilyMemberUncheckedCreateWithoutPassingRecordsInput>
  }

  export type CauseOfDeathCreateWithoutPassingRecordInput = {
    causeName: string
    familyMember: FamilyMemberCreateNestedOneWithoutCausesOfDeathInput
  }

  export type CauseOfDeathUncheckedCreateWithoutPassingRecordInput = {
    id?: number
    causeName: string
    familyMemberId: number
  }

  export type CauseOfDeathCreateOrConnectWithoutPassingRecordInput = {
    where: CauseOfDeathWhereUniqueInput
    create: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
  }

  export type BuriedPlaceCreateWithoutPassingRecordInput = {
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BuriedPlaceUncheckedCreateWithoutPassingRecordInput = {
    id?: number
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BuriedPlaceCreateOrConnectWithoutPassingRecordInput = {
    where: BuriedPlaceWhereUniqueInput
    create: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput>
  }

  export type BuriedPlaceCreateManyPassingRecordInputEnvelope = {
    data: BuriedPlaceCreateManyPassingRecordInput | BuriedPlaceCreateManyPassingRecordInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMemberUpsertWithoutPassingRecordsInput = {
    update: XOR<FamilyMemberUpdateWithoutPassingRecordsInput, FamilyMemberUncheckedUpdateWithoutPassingRecordsInput>
    create: XOR<FamilyMemberCreateWithoutPassingRecordsInput, FamilyMemberUncheckedCreateWithoutPassingRecordsInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutPassingRecordsInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutPassingRecordsInput, FamilyMemberUncheckedUpdateWithoutPassingRecordsInput>
  }

  export type FamilyMemberUpdateWithoutPassingRecordsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutPassingRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type CauseOfDeathUpsertWithoutPassingRecordInput = {
    update: XOR<CauseOfDeathUpdateWithoutPassingRecordInput, CauseOfDeathUncheckedUpdateWithoutPassingRecordInput>
    create: XOR<CauseOfDeathCreateWithoutPassingRecordInput, CauseOfDeathUncheckedCreateWithoutPassingRecordInput>
    where?: CauseOfDeathWhereInput
  }

  export type CauseOfDeathUpdateToOneWithWhereWithoutPassingRecordInput = {
    where?: CauseOfDeathWhereInput
    data: XOR<CauseOfDeathUpdateWithoutPassingRecordInput, CauseOfDeathUncheckedUpdateWithoutPassingRecordInput>
  }

  export type CauseOfDeathUpdateWithoutPassingRecordInput = {
    causeName?: StringFieldUpdateOperationsInput | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutCausesOfDeathNestedInput
  }

  export type CauseOfDeathUncheckedUpdateWithoutPassingRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeName?: StringFieldUpdateOperationsInput | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type BuriedPlaceUpsertWithWhereUniqueWithoutPassingRecordInput = {
    where: BuriedPlaceWhereUniqueInput
    update: XOR<BuriedPlaceUpdateWithoutPassingRecordInput, BuriedPlaceUncheckedUpdateWithoutPassingRecordInput>
    create: XOR<BuriedPlaceCreateWithoutPassingRecordInput, BuriedPlaceUncheckedCreateWithoutPassingRecordInput>
  }

  export type BuriedPlaceUpdateWithWhereUniqueWithoutPassingRecordInput = {
    where: BuriedPlaceWhereUniqueInput
    data: XOR<BuriedPlaceUpdateWithoutPassingRecordInput, BuriedPlaceUncheckedUpdateWithoutPassingRecordInput>
  }

  export type BuriedPlaceUpdateManyWithWhereWithoutPassingRecordInput = {
    where: BuriedPlaceScalarWhereInput
    data: XOR<BuriedPlaceUpdateManyMutationInput, BuriedPlaceUncheckedUpdateManyWithoutPassingRecordInput>
  }

  export type BuriedPlaceScalarWhereInput = {
    AND?: BuriedPlaceScalarWhereInput | BuriedPlaceScalarWhereInput[]
    OR?: BuriedPlaceScalarWhereInput[]
    NOT?: BuriedPlaceScalarWhereInput | BuriedPlaceScalarWhereInput[]
    id?: IntFilter<"BuriedPlace"> | number
    location?: StringFilter<"BuriedPlace"> | string
    startDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    endDate?: DateTimeNullableFilter<"BuriedPlace"> | Date | string | null
    passingRecordId?: IntFilter<"BuriedPlace"> | number
  }

  export type PassingRecordCreateWithoutCauseOfDeathInput = {
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMember: FamilyMemberCreateNestedOneWithoutPassingRecordsInput
    buriedPlaces?: BuriedPlaceCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordUncheckedCreateWithoutCauseOfDeathInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMemberId: number
    buriedPlaces?: BuriedPlaceUncheckedCreateNestedManyWithoutPassingRecordInput
  }

  export type PassingRecordCreateOrConnectWithoutCauseOfDeathInput = {
    where: PassingRecordWhereUniqueInput
    create: XOR<PassingRecordCreateWithoutCauseOfDeathInput, PassingRecordUncheckedCreateWithoutCauseOfDeathInput>
  }

  export type FamilyMemberCreateWithoutCausesOfDeathInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutCausesOfDeathInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutCausesOfDeathInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutCausesOfDeathInput, FamilyMemberUncheckedCreateWithoutCausesOfDeathInput>
  }

  export type PassingRecordUpsertWithoutCauseOfDeathInput = {
    update: XOR<PassingRecordUpdateWithoutCauseOfDeathInput, PassingRecordUncheckedUpdateWithoutCauseOfDeathInput>
    create: XOR<PassingRecordCreateWithoutCauseOfDeathInput, PassingRecordUncheckedCreateWithoutCauseOfDeathInput>
    where?: PassingRecordWhereInput
  }

  export type PassingRecordUpdateToOneWithWhereWithoutCauseOfDeathInput = {
    where?: PassingRecordWhereInput
    data: XOR<PassingRecordUpdateWithoutCauseOfDeathInput, PassingRecordUncheckedUpdateWithoutCauseOfDeathInput>
  }

  export type PassingRecordUpdateWithoutCauseOfDeathInput = {
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutPassingRecordsNestedInput
    buriedPlaces?: BuriedPlaceUpdateManyWithoutPassingRecordNestedInput
  }

  export type PassingRecordUncheckedUpdateWithoutCauseOfDeathInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
    buriedPlaces?: BuriedPlaceUncheckedUpdateManyWithoutPassingRecordNestedInput
  }

  export type FamilyMemberUpsertWithoutCausesOfDeathInput = {
    update: XOR<FamilyMemberUpdateWithoutCausesOfDeathInput, FamilyMemberUncheckedUpdateWithoutCausesOfDeathInput>
    create: XOR<FamilyMemberCreateWithoutCausesOfDeathInput, FamilyMemberUncheckedCreateWithoutCausesOfDeathInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutCausesOfDeathInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutCausesOfDeathInput, FamilyMemberUncheckedUpdateWithoutCausesOfDeathInput>
  }

  export type FamilyMemberUpdateWithoutCausesOfDeathInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutCausesOfDeathInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type PassingRecordCreateWithoutBuriedPlacesInput = {
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMember: FamilyMemberCreateNestedOneWithoutPassingRecordsInput
    causeOfDeath?: CauseOfDeathCreateNestedOneWithoutPassingRecordInput
  }

  export type PassingRecordUncheckedCreateWithoutBuriedPlacesInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
    familyMemberId: number
    causeOfDeath?: CauseOfDeathUncheckedCreateNestedOneWithoutPassingRecordInput
  }

  export type PassingRecordCreateOrConnectWithoutBuriedPlacesInput = {
    where: PassingRecordWhereUniqueInput
    create: XOR<PassingRecordCreateWithoutBuriedPlacesInput, PassingRecordUncheckedCreateWithoutBuriedPlacesInput>
  }

  export type PassingRecordUpsertWithoutBuriedPlacesInput = {
    update: XOR<PassingRecordUpdateWithoutBuriedPlacesInput, PassingRecordUncheckedUpdateWithoutBuriedPlacesInput>
    create: XOR<PassingRecordCreateWithoutBuriedPlacesInput, PassingRecordUncheckedCreateWithoutBuriedPlacesInput>
    where?: PassingRecordWhereInput
  }

  export type PassingRecordUpdateToOneWithWhereWithoutBuriedPlacesInput = {
    where?: PassingRecordWhereInput
    data: XOR<PassingRecordUpdateWithoutBuriedPlacesInput, PassingRecordUncheckedUpdateWithoutBuriedPlacesInput>
  }

  export type PassingRecordUpdateWithoutBuriedPlacesInput = {
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutPassingRecordsNestedInput
    causeOfDeath?: CauseOfDeathUpdateOneWithoutPassingRecordNestedInput
  }

  export type PassingRecordUncheckedUpdateWithoutBuriedPlacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
    causeOfDeath?: CauseOfDeathUncheckedUpdateOneWithoutPassingRecordNestedInput
  }

  export type FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput = {
    startDate?: Date | string | null
    endDate?: Date | string | null
    familyMember: FamilyMemberCreateNestedOneWithoutBirthPlacesInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput = {
    familyMemberId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginCreateOrConnectWithoutPlaceOfOriginInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    create: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput>
  }

  export type FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInputEnvelope = {
    data: FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInput | FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMember_has_PlaceOfOriginUpsertWithWhereUniqueWithoutPlaceOfOriginInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    update: XOR<FamilyMember_has_PlaceOfOriginUpdateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutPlaceOfOriginInput>
    create: XOR<FamilyMember_has_PlaceOfOriginCreateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedCreateWithoutPlaceOfOriginInput>
  }

  export type FamilyMember_has_PlaceOfOriginUpdateWithWhereUniqueWithoutPlaceOfOriginInput = {
    where: FamilyMember_has_PlaceOfOriginWhereUniqueInput
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateWithoutPlaceOfOriginInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutPlaceOfOriginInput>
  }

  export type FamilyMember_has_PlaceOfOriginUpdateManyWithWhereWithoutPlaceOfOriginInput = {
    where: FamilyMember_has_PlaceOfOriginScalarWhereInput
    data: XOR<FamilyMember_has_PlaceOfOriginUpdateManyMutationInput, FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutPlaceOfOriginInput>
  }

  export type FamilyMemberCreateWithoutBirthPlacesInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutBirthPlacesInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutBirthPlacesInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutBirthPlacesInput, FamilyMemberUncheckedCreateWithoutBirthPlacesInput>
  }

  export type PlaceOfOriginCreateWithoutFamilyMembersInput = {
    location: string
  }

  export type PlaceOfOriginUncheckedCreateWithoutFamilyMembersInput = {
    id?: number
    location: string
  }

  export type PlaceOfOriginCreateOrConnectWithoutFamilyMembersInput = {
    where: PlaceOfOriginWhereUniqueInput
    create: XOR<PlaceOfOriginCreateWithoutFamilyMembersInput, PlaceOfOriginUncheckedCreateWithoutFamilyMembersInput>
  }

  export type FamilyMemberUpsertWithoutBirthPlacesInput = {
    update: XOR<FamilyMemberUpdateWithoutBirthPlacesInput, FamilyMemberUncheckedUpdateWithoutBirthPlacesInput>
    create: XOR<FamilyMemberCreateWithoutBirthPlacesInput, FamilyMemberUncheckedCreateWithoutBirthPlacesInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutBirthPlacesInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutBirthPlacesInput, FamilyMemberUncheckedUpdateWithoutBirthPlacesInput>
  }

  export type FamilyMemberUpdateWithoutBirthPlacesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutBirthPlacesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type PlaceOfOriginUpsertWithoutFamilyMembersInput = {
    update: XOR<PlaceOfOriginUpdateWithoutFamilyMembersInput, PlaceOfOriginUncheckedUpdateWithoutFamilyMembersInput>
    create: XOR<PlaceOfOriginCreateWithoutFamilyMembersInput, PlaceOfOriginUncheckedCreateWithoutFamilyMembersInput>
    where?: PlaceOfOriginWhereInput
  }

  export type PlaceOfOriginUpdateToOneWithWhereWithoutFamilyMembersInput = {
    where?: PlaceOfOriginWhereInput
    data: XOR<PlaceOfOriginUpdateWithoutFamilyMembersInput, PlaceOfOriginUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type PlaceOfOriginUpdateWithoutFamilyMembersInput = {
    location?: StringFieldUpdateOperationsInput | string
  }

  export type PlaceOfOriginUncheckedUpdateWithoutFamilyMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberCreateWithoutSpouse1Input = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutSpouse1Input = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutSpouse1Input = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutSpouse1Input, FamilyMemberUncheckedCreateWithoutSpouse1Input>
  }

  export type FamilyMemberCreateWithoutSpouse2Input = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    guestEditors?: GuestEditorCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutSpouse2Input = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    guestEditors?: GuestEditorUncheckedCreateNestedManyWithoutFamilyMemberInput
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutSpouse2Input = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutSpouse2Input, FamilyMemberUncheckedCreateWithoutSpouse2Input>
  }

  export type FamilyMemberUpsertWithoutSpouse1Input = {
    update: XOR<FamilyMemberUpdateWithoutSpouse1Input, FamilyMemberUncheckedUpdateWithoutSpouse1Input>
    create: XOR<FamilyMemberCreateWithoutSpouse1Input, FamilyMemberUncheckedCreateWithoutSpouse1Input>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutSpouse1Input = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutSpouse1Input, FamilyMemberUncheckedUpdateWithoutSpouse1Input>
  }

  export type FamilyMemberUpdateWithoutSpouse1Input = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutSpouse1Input = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUpsertWithoutSpouse2Input = {
    update: XOR<FamilyMemberUpdateWithoutSpouse2Input, FamilyMemberUncheckedUpdateWithoutSpouse2Input>
    create: XOR<FamilyMemberCreateWithoutSpouse2Input, FamilyMemberUncheckedCreateWithoutSpouse2Input>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutSpouse2Input = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutSpouse2Input, FamilyMemberUncheckedUpdateWithoutSpouse2Input>
  }

  export type FamilyMemberUpdateWithoutSpouse2Input = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutSpouse2Input = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberCreateWithoutGuestEditorsInput = {
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTree: FamilyTreeCreateNestedOneWithoutFamilyMembersInput
    parent?: FamilyMemberCreateNestedOneWithoutChildrenInput
    children?: FamilyMemberCreateNestedManyWithoutParentInput
    achievements?: AchievementCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipCreateNestedManyWithoutFamilyMember2Input
    rootFor?: FamilyTreeCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberUncheckedCreateWithoutGuestEditorsInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
    parentId?: number | null
    children?: FamilyMemberUncheckedCreateNestedManyWithoutParentInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutFamilyMemberInput
    passingRecords?: PassingRecordUncheckedCreateNestedManyWithoutFamilyMemberInput
    causesOfDeath?: CauseOfDeathUncheckedCreateNestedManyWithoutFamilyMemberInput
    occupations?: OccupationUncheckedCreateNestedManyWithoutFamilyMemberInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedCreateNestedManyWithoutFamilyMemberInput
    spouse1?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember1Input
    spouse2?: SpouseRelationshipUncheckedCreateNestedManyWithoutFamilyMember2Input
    rootFor?: FamilyTreeUncheckedCreateNestedOneWithoutRootMemberInput
  }

  export type FamilyMemberCreateOrConnectWithoutGuestEditorsInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutGuestEditorsInput, FamilyMemberUncheckedCreateWithoutGuestEditorsInput>
  }

  export type FamilyTreeCreateWithoutGuestEditorsInput = {
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwner: TreeOwnerCreateNestedOneWithoutFamilyTreesInput
    rootMember?: FamilyMemberCreateNestedOneWithoutRootForInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeUncheckedCreateWithoutGuestEditorsInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    treeOwnerId: number
    rootMemberId?: number | null
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyTreeInput
    achievementTypes?: AchievementTypeUncheckedCreateNestedManyWithoutFamilyTreeInput
  }

  export type FamilyTreeCreateOrConnectWithoutGuestEditorsInput = {
    where: FamilyTreeWhereUniqueInput
    create: XOR<FamilyTreeCreateWithoutGuestEditorsInput, FamilyTreeUncheckedCreateWithoutGuestEditorsInput>
  }

  export type FamilyMemberUpsertWithoutGuestEditorsInput = {
    update: XOR<FamilyMemberUpdateWithoutGuestEditorsInput, FamilyMemberUncheckedUpdateWithoutGuestEditorsInput>
    create: XOR<FamilyMemberCreateWithoutGuestEditorsInput, FamilyMemberUncheckedCreateWithoutGuestEditorsInput>
    where?: FamilyMemberWhereInput
  }

  export type FamilyMemberUpdateToOneWithWhereWithoutGuestEditorsInput = {
    where?: FamilyMemberWhereInput
    data: XOR<FamilyMemberUpdateWithoutGuestEditorsInput, FamilyMemberUncheckedUpdateWithoutGuestEditorsInput>
  }

  export type FamilyMemberUpdateWithoutGuestEditorsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutGuestEditorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyTreeUpsertWithoutGuestEditorsInput = {
    update: XOR<FamilyTreeUpdateWithoutGuestEditorsInput, FamilyTreeUncheckedUpdateWithoutGuestEditorsInput>
    create: XOR<FamilyTreeCreateWithoutGuestEditorsInput, FamilyTreeUncheckedCreateWithoutGuestEditorsInput>
    where?: FamilyTreeWhereInput
  }

  export type FamilyTreeUpdateToOneWithWhereWithoutGuestEditorsInput = {
    where?: FamilyTreeWhereInput
    data: XOR<FamilyTreeUpdateWithoutGuestEditorsInput, FamilyTreeUncheckedUpdateWithoutGuestEditorsInput>
  }

  export type FamilyTreeUpdateWithoutGuestEditorsInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwner?: TreeOwnerUpdateOneRequiredWithoutFamilyTreesNestedInput
    rootMember?: FamilyMemberUpdateOneWithoutRootForNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutGuestEditorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    treeOwnerId?: IntFieldUpdateOperationsInput | number
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TreeOwnerCreateWithoutUserInput = {
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    familyTrees?: FamilyTreeCreateNestedManyWithoutTreeOwnerInput
  }

  export type TreeOwnerUncheckedCreateWithoutUserInput = {
    id?: number
    fullName: string
    createdAt?: Date | string
    updatedAt?: Date | string | null
    familyTrees?: FamilyTreeUncheckedCreateNestedManyWithoutTreeOwnerInput
  }

  export type TreeOwnerCreateOrConnectWithoutUserInput = {
    where: TreeOwnerWhereUniqueInput
    create: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type TreeOwnerUpsertWithoutUserInput = {
    update: XOR<TreeOwnerUpdateWithoutUserInput, TreeOwnerUncheckedUpdateWithoutUserInput>
    create: XOR<TreeOwnerCreateWithoutUserInput, TreeOwnerUncheckedCreateWithoutUserInput>
    where?: TreeOwnerWhereInput
  }

  export type TreeOwnerUpdateToOneWithWhereWithoutUserInput = {
    where?: TreeOwnerWhereInput
    data: XOR<TreeOwnerUpdateWithoutUserInput, TreeOwnerUncheckedUpdateWithoutUserInput>
  }

  export type TreeOwnerUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyTrees?: FamilyTreeUpdateManyWithoutTreeOwnerNestedInput
  }

  export type TreeOwnerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyTrees?: FamilyTreeUncheckedUpdateManyWithoutTreeOwnerNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    treeOwner?: TreeOwnerUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    treeOwner?: TreeOwnerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type FamilyTreeCreateManyTreeOwnerInput = {
    id?: number
    familyName: string
    origin?: string | null
    establishYear?: number | null
    createdAt?: Date | string
    rootMemberId?: number | null
  }

  export type FamilyTreeUpdateWithoutTreeOwnerInput = {
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootMember?: FamilyMemberUpdateOneWithoutRootForNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateWithoutTreeOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutFamilyTreeNestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyTreeNestedInput
    achievementTypes?: AchievementTypeUncheckedUpdateManyWithoutFamilyTreeNestedInput
  }

  export type FamilyTreeUncheckedUpdateManyWithoutTreeOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    familyName?: StringFieldUpdateOperationsInput | string
    origin?: NullableStringFieldUpdateOperationsInput | string | null
    establishYear?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootMemberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FamilyMemberCreateManyFamilyTreeInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    parentId?: number | null
  }

  export type GuestEditorCreateManyFamilyTreeInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyMemberId: number
  }

  export type AchievementTypeCreateManyFamilyTreeInput = {
    id?: number
    typeName: string
  }

  export type FamilyMemberUpdateWithoutFamilyTreeInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parent?: FamilyMemberUpdateOneWithoutChildrenNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateManyWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GuestEditorUpdateWithoutFamilyTreeInput = {
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMember?: FamilyMemberUpdateOneRequiredWithoutGuestEditorsNestedInput
  }

  export type GuestEditorUncheckedUpdateWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type GuestEditorUncheckedUpdateManyWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementTypeUpdateWithoutFamilyTreeInput = {
    typeName?: StringFieldUpdateOperationsInput | string
    achievements?: AchievementUpdateManyWithoutAchievementTypeNestedInput
  }

  export type AchievementTypeUncheckedUpdateWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
    achievements?: AchievementUncheckedUpdateManyWithoutAchievementTypeNestedInput
  }

  export type AchievementTypeUncheckedUpdateManyWithoutFamilyTreeInput = {
    id?: IntFieldUpdateOperationsInput | number
    typeName?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberCreateManyParentInput = {
    id?: number
    fullName: string
    gender?: $Enums.Gender | null
    birthday?: Date | string | null
    address?: string | null
    profilePicture?: string | null
    generation?: string | null
    isRootPerson?: boolean | null
    isAdopted?: boolean | null
    familyTreeId: number
  }

  export type AchievementCreateManyFamilyMemberInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    achievementTypeId: number
  }

  export type PassingRecordCreateManyFamilyMemberInput = {
    id?: number
    dateOfPassing: Date | string
    createdAt?: Date | string
  }

  export type CauseOfDeathCreateManyFamilyMemberInput = {
    id?: number
    causeName: string
    passingRecordId: number
  }

  export type OccupationCreateManyFamilyMemberInput = {
    id?: number
    jobTitle: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginCreateManyFamilyMemberInput = {
    placeOfOriginId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type SpouseRelationshipCreateManyFamilyMember1Input = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember2Id: number
  }

  export type SpouseRelationshipCreateManyFamilyMember2Input = {
    id?: number
    marriageDate: Date | string
    divorceDate?: Date | string | null
    familyMember1Id: number
  }

  export type GuestEditorCreateManyFamilyMemberInput = {
    id?: number
    accessCode: string
    createDate?: Date | string
    familyTreeId: number
  }

  export type FamilyMemberUpdateWithoutParentInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTree?: FamilyTreeUpdateOneRequiredWithoutFamilyMembersNestedInput
    children?: FamilyMemberUpdateManyWithoutParentNestedInput
    achievements?: AchievementUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
    children?: FamilyMemberUncheckedUpdateManyWithoutParentNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutFamilyMemberNestedInput
    passingRecords?: PassingRecordUncheckedUpdateManyWithoutFamilyMemberNestedInput
    causesOfDeath?: CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberNestedInput
    occupations?: OccupationUncheckedUpdateManyWithoutFamilyMemberNestedInput
    birthPlaces?: FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberNestedInput
    spouse1?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1NestedInput
    spouse2?: SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2NestedInput
    guestEditors?: GuestEditorUncheckedUpdateManyWithoutFamilyMemberNestedInput
    rootFor?: FamilyTreeUncheckedUpdateOneWithoutRootMemberNestedInput
  }

  export type FamilyMemberUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    isRootPerson?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isAdopted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUpdateWithoutFamilyMemberInput = {
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievementType?: AchievementTypeUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievementTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    achievementTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type PassingRecordUpdateWithoutFamilyMemberInput = {
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: CauseOfDeathUpdateOneWithoutPassingRecordNestedInput
    buriedPlaces?: BuriedPlaceUpdateManyWithoutPassingRecordNestedInput
  }

  export type PassingRecordUncheckedUpdateWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    causeOfDeath?: CauseOfDeathUncheckedUpdateOneWithoutPassingRecordNestedInput
    buriedPlaces?: BuriedPlaceUncheckedUpdateManyWithoutPassingRecordNestedInput
  }

  export type PassingRecordUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateOfPassing?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CauseOfDeathUpdateWithoutFamilyMemberInput = {
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecord?: PassingRecordUpdateOneRequiredWithoutCauseOfDeathNestedInput
  }

  export type CauseOfDeathUncheckedUpdateWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type CauseOfDeathUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    causeName?: StringFieldUpdateOperationsInput | string
    passingRecordId?: IntFieldUpdateOperationsInput | number
  }

  export type OccupationUpdateWithoutFamilyMemberInput = {
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OccupationUncheckedUpdateWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OccupationUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobTitle?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUpdateWithoutFamilyMemberInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    placeOfOrigin?: PlaceOfOriginUpdateOneRequiredWithoutFamilyMembersNestedInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutFamilyMemberInput = {
    placeOfOriginId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutFamilyMemberInput = {
    placeOfOriginId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SpouseRelationshipUpdateWithoutFamilyMember1Input = {
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember2?: FamilyMemberUpdateOneRequiredWithoutSpouse2NestedInput
  }

  export type SpouseRelationshipUncheckedUpdateWithoutFamilyMember1Input = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember2Id?: IntFieldUpdateOperationsInput | number
  }

  export type SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember1Input = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember2Id?: IntFieldUpdateOperationsInput | number
  }

  export type SpouseRelationshipUpdateWithoutFamilyMember2Input = {
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1?: FamilyMemberUpdateOneRequiredWithoutSpouse1NestedInput
  }

  export type SpouseRelationshipUncheckedUpdateWithoutFamilyMember2Input = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1Id?: IntFieldUpdateOperationsInput | number
  }

  export type SpouseRelationshipUncheckedUpdateManyWithoutFamilyMember2Input = {
    id?: IntFieldUpdateOperationsInput | number
    marriageDate?: DateTimeFieldUpdateOperationsInput | Date | string
    divorceDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember1Id?: IntFieldUpdateOperationsInput | number
  }

  export type GuestEditorUpdateWithoutFamilyMemberInput = {
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyTree?: FamilyTreeUpdateOneRequiredWithoutGuestEditorsNestedInput
  }

  export type GuestEditorUncheckedUpdateWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type GuestEditorUncheckedUpdateManyWithoutFamilyMemberInput = {
    id?: IntFieldUpdateOperationsInput | number
    accessCode?: StringFieldUpdateOperationsInput | string
    createDate?: DateTimeFieldUpdateOperationsInput | Date | string
    familyTreeId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementCreateManyAchievementTypeInput = {
    id?: number
    title: string
    achieveDate?: Date | string | null
    description?: string | null
    familyMemberId: number
  }

  export type AchievementUpdateWithoutAchievementTypeInput = {
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMember?: FamilyMemberUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateWithoutAchievementTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUncheckedUpdateManyWithoutAchievementTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    achieveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    familyMemberId?: IntFieldUpdateOperationsInput | number
  }

  export type BuriedPlaceCreateManyPassingRecordInput = {
    id?: number
    location: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type BuriedPlaceUpdateWithoutPassingRecordInput = {
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BuriedPlaceUncheckedUpdateWithoutPassingRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BuriedPlaceUncheckedUpdateManyWithoutPassingRecordInput = {
    id?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginCreateManyPlaceOfOriginInput = {
    familyMemberId: number
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUpdateWithoutPlaceOfOriginInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    familyMember?: FamilyMemberUpdateOneRequiredWithoutBirthPlacesNestedInput
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateWithoutPlaceOfOriginInput = {
    familyMemberId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FamilyMember_has_PlaceOfOriginUncheckedUpdateManyWithoutPlaceOfOriginInput = {
    familyMemberId?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}